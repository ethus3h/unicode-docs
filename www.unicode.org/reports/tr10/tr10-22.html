<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
       "http://www.w3.org/TR/html4/loose.dtd"> 

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<title>UTS #10: Unicode Collation Algorithm</title>
<link rel="stylesheet" type="text/css" href="../reports-web.css">
<style type="text/css">
<!--
span.marked  { font-weight: bold; border-style: dotted; border-width: 1px; background-color: 
               #00FF00 }
.unused      { background-color: #DDDDDD }
-->
</style>
</head>

<body bgcolor="#ffffff">

<table class="header">
	<tr>
		<td class="icon"><a href="http://www.unicode.org">
		<img align="middle" alt="[Unicode]" border="0" src="../../webscripts/logo60s2.gif" width="34" height="33"></a>&nbsp;
		<a class="bar" href="../index.html">Technical Reports</a></td>
	</tr>
	<tr>
		<td class="gray">&nbsp;</td>
	</tr>
</table>
<div class="body">
	<h2 align="center">
	<!--
	<span class="changed" style="color: red">Proposed Update</span>
	-->
	Unicode Technical Standard #10</h2>
	<h1>Unicode Collation Algorithm</h1>
	<table class="wide" border="1" cellpadding="2">
		<tr>
			<td>Version</td>
			<td>6.0.0</td>
		</tr>
		<tr>
			<td>Editors</td>
			<td>Mark Davis (<a href="mailto:markdavis@google.com">markdavis@google.com</a>), 
			Ken Whistler (<a href="mailto:ken@unicode.org">ken@unicode.org</a>)</td>
		</tr>
		<tr>
			<td>Date</td>
			<td>2010-10-08</td>
		</tr>
		<tr>
			<td>This Version</td>
			<td>
			<a HREF="tr10-22.html">
			http://www.unicode.org/reports/tr10/tr10-22.html</a></td>
		</tr>
		<tr>
			<td>Previous Version</td>
			<td>
			<a HREF="tr10-20.html">
			http://www.unicode.org/reports/tr10/tr10-20.html</a></td>
		</tr>
		<tr>
			<td>Latest Version</td>
			<td><a href="index.html">http://www.unicode.org/reports/tr10/</a></td>
		</tr>
 	    <tr>
	      <td valign="top">Latest Proposed Update</td>
	      <td valign="top"><a href="proposed.html">
	      http://www.unicode.org/reports/tr10/proposed.html</a></td>
	    </tr>
		<tr>
			<td>Revision</td>
			<td><a href="tr10-22.html#Modifications">22</a></td>
		</tr>
	</table>
	<p>&nbsp;</p>
	
	<h3><i>Summary</i></h3>
	
	<p><i>This report is the 
	specification of the Unicode Collation Algorithm (UCA), 
	which details how to compare two Unicode strings while 
	remaining conformant to the requirements of the Unicode Standard. The UCA also 
	supplies the Default Unicode Collation Element Table (DUCET) as the data specifying 
	the default collation order for all Unicode characters.</i></p>
	
	<h3><i>Status</i></h3>
	   <!-- NOT YET APPROVED
	  <p class="changed"><i>This is a<b><font color="#ff3333"> draft </font></b>document which 
      may be updated, replaced, or superseded by other documents at any time. 
      Publication does not imply endorsement by the Unicode Consortium. This is 
      not a stable document; it is inappropriate to cite this document as other 
      than a work in progress.</i></p>
           END NOT YET APPROVED -->
	  <!-- APPROVED -->
      <p><i>This document has been reviewed by Unicode members and other 
	  interested parties, and has been approved for publication by the Unicode 
	  Consortium. This is a stable document and may be used as reference 
	  material or cited as a normative reference by other specifications.</i></p>
         <!-- END APPROVED -->
	<blockquote>
		<p><i><b>A Unicode Technical Standard (UTS)</b> is an independent specification. 
		Conformance to the Unicode Standard does not imply conformance to any UTS.</i></p>
	</blockquote>
	<p><i>Please submit corrigenda and other comments with the online reporting 
	form [<a href="tr10-22.html#Feedback">Feedback</a>]. Related 
	information that is useful in understanding this document is found in the
	<a href="tr10-22.html#References">References</a>. For the latest 
	version of the Unicode Standard see [<a href="tr10-22.html#Unicode">Unicode</a>]. 
	For a list of current Unicode Technical Reports see [<a href="tr10-22.html#Reports">Reports</a>]. 
	For more information about versions of the Unicode Standard, see [<a href="tr10-22.html#Versions">Versions</a>].</i></p>
	<h3><i>Contents</i></h3>
	<ul class="toc">
		<li>1 <a href="tr10-22.html#Introduction">Introduction</a>
		<ul class="toc">
			<li>1.1 <a href="tr10-22.html#Multi_Level_Comparison">Multi-Level Comparison</a>
			<ul class="toc">
				<li>1.1.1 <a href="tr10-22.html#Collation_And_Code_Chart_Order">Collation Order and Code Chart Order</a></li>
			</ul>
			</li>
			<li>1.2 <a href="tr10-22.html#Canonical_Equivalence">Canonical Equivalence</a></li>
			<li>1.3 <a href="tr10-22.html#Contextual_Sensitivity">Contextual Sensitivity</a></li>
			<li>1.4 <a href="tr10-22.html#Customization">Customization</a></li>
			<li>1.5 <a href="tr10-22.html#Other_Applications_of_Collation">Other Applications of Collation</a></li>
			<li>1.6 <a href="tr10-22.html#Interleaved_Levels">Interleaved Levels</a></li>
			<li>1.7 <a href="tr10-22.html#Performance">Performance</a></li>
			<li>1.8 <a href="tr10-22.html#Common_Misperceptions">What Collation is Not</a></li>
			<li>1.9 <a href="tr10-22.html#Scope">The Unicode Collation Algorithm</a>
			<ul class="toc">
				<li>1.9.1 <a href="tr10-22.html#Goals">Goals</a></li>
				<li>1.9.2 <a href="tr10-22.html#Non-Goals">Non-Goals</a></li>
			</ul>
			</li>
		</ul>
		</li>
		<li>2 <a href="tr10-22.html#Conformance">Conformance</a></li>
		<li>3 <a href="tr10-22.html#Data_Table_Format">Collation Element Table</a>
		<ul class="toc">
			<li>3.1 <a href="tr10-22.html#Notation">Weight Levels and Notation</a></li>
			<li>3.2 <a href="tr10-22.html#Simple_Mappings">Simple Mappings</a></li>
			<li>3.3 <a href="tr10-22.html#Multiple_Mappings">Multiple Mappings</a>
			<ul class="toc">
				<li>3.3.1 <a href="tr10-22.html#Expansions">Expansions</a></li>
				<li>3.3.2 <a href="tr10-22.html#Contractions">Contractions</a></li>
				<li>3.3.3 <a href="tr10-22.html#Many_To_Many">Many-to-Many Mappings</a></li>
				<li>3.3.4 <a href="tr10-22.html#Other_Multiple_Mappings">Other Multiple Mappings</a></li>
			</ul>
			</li>
			<li>3.4 <a href="tr10-22.html#French_Accents">French Accents</a></li>
			<li>3.5 <a href="tr10-22.html#Rearrangement">Rearrangement</a></li>
			<li>3.6 <a href="tr10-22.html#Default_Unicode_Collation_Element_Table">Default Unicode 
			Collation Element Table</a>
			<ul class="toc">
				<li>3.6.1 <a href="tr10-22.html#File_Format">File Format</a></li>
				<li>3.6.2 <a href="tr10-22.html#Variable_Weighting">Variable Weighting</a></li>
				<li>3.6.3 <a href="tr10-22.html#Default_Values">Default Values</a></li>
			</ul>
			</li>
			<li>3.7 <a href="tr10-22.html#Well-Formed">Well-Formed Collation Element Tables</a></li>
			<li>3.8 <a href="tr10-22.html#Stability">Stability</a></li>
		</ul>
		</li>
		<li>4 <a href="tr10-22.html#Main_Algorithm">Main Algorithm</a>
		<ul class="toc">
			<li>4.1 <a href="tr10-22.html#Step_1">Normalize</a></li>
			<li>4.2 <a href="tr10-22.html#Step_2">Produce Array</a></li>
			<li>4.3 <a href="tr10-22.html#Step_3">Form Sort Key</a></li>
			<li>4.4 <a href="tr10-22.html#Step_4">Compare</a></li>
		</ul>
		</li>
		<li>5 <a href="tr10-22.html#Tailoring">Tailoring</a>
		<ul class="toc">
			<li>5.1 <a href="tr10-22.html#Parametic_Tailoring">Parametric Tailoring</a></li>
			<li>5.2 <a href="tr10-22.html#Tailoring_Example">Tailoring Example</a></li>
			<li>5.3 <a href="tr10-22.html#Combining_Grapheme_Joiner">Use of Combining Grapheme Joiner</a></li>
			<li>5.4 <a href="tr10-22.html#Preprocessing">Preprocessing</a></li>
		</ul>
		</li>
		<li>6 <a href="tr10-22.html#Implementation_Notes">Implementation Notes</a>
		<ul class="toc">
			<li>6.1 <a href="tr10-22.html#Reducing_Sort_Key_Lengths">Reducing Sort Key Lengths</a>
			<ul class="toc">
				<li>6.1.1 <a href="tr10-22.html#Eliminating_level_separators">Eliminating Level 
				Separators</a></li>
				<li>6.1.2 <a href="tr10-22.html#L2/L3_in_8_bits">L2/L3 in 8 Bits</a></li>
				<li>6.1.3 <a href="tr10-22.html#Machine_Words">Machine Words</a></li>
				<li>6.1.4 <a href="tr10-22.html#Run-length_Compression">Run-Length Compression</a></li>
			</ul>
			</li>
			<li>6.2 <a href="tr10-22.html#Large_Weight_Values">Large Weight Values</a></li>
			<li>6.3 <a href="tr10-22.html#Reducing_Table_Sizes">Reducing Table Sizes</a>
			<ul class="toc">
				<li>6.3.1 <a href="tr10-22.html#Contiguous_weight_ranges">Contiguous Weight 
				Ranges</a></li>
				<li>6.3.2 <a href="tr10-22.html#Escape_hatch">Escape Hatch</a></li>
				<li>6.3.3 <a href="tr10-22.html#Leveraging_Unicode_tables">Leveraging Unicode 
				Tables</a></li>
				<li>6.3.4 <a href="tr10-22.html#Reducing_the_Repertoire">Reducing the Repertoire</a></li>
				<li>6.3.5 <a href="tr10-22.html#Memory_Table_Size">Memory Table Size</a></li>
			</ul>
			</li>
			<li>6.4 <a href="tr10-22.html#Avoiding_Zero_Bytes">Avoiding Zero Bytes</a></li>
			<li>6.5 <a href="tr10-22.html#Avoiding_Normalization">Avoiding Normalization</a>
			<ul class="toc">
			<li>6.5.1 <a href="tr10-22.html#Canonical_Decompositions">Canonical Decompositions</a></li>
			<li>6.5.2 <a href="tr10-22.html#Compatibility_Decompositions">Compatibility Decompositions</a></li>
			</ul>
			</li>
			<li>6.6 <a href="tr10-22.html#Case_Comparisons">Case Comparisons</a></li>
			<li>6.7 <a href="tr10-22.html#Incremental_Comparison">Incremental Comparison</a></li>
			<li>6.8 <a href="tr10-22.html#Catching_Mismatches">Catching Mismatches</a></li>
			<li>6.9 <a href="tr10-22.html#Collation_Graphemes">Handling Collation Graphemes</a></li>
			<li>6.10 <a href="tr10-22.html#Flat_File_Example">Flat File Example</a>
			<ul class="toc">
				<li>6.10.1 <a href="tr10-22.html#Collation_Element_Format">Collation Element Format</a></li>
				<li>6.10.2 <a href="tr10-22.html#Sample_Code">Sample Code</a></li>
			</ul>
			</li>
		</ul>
		</li>
		<li>7 <a href="tr10-22.html#Weight_Derivation">Weight Derivation</a>
		<ul class="toc">
			<li>7.1 <a href="tr10-22.html#Derived_Collation_Elements">Derived Collation Elements</a>
			<ul class="toc">
				<li>7.1.1 <a href="tr10-22.html#Handling_Illformed">Handling Ill-Formed Code Unit Sequences</a></li>
				<li>7.1.2 <a href="tr10-22.html#Unassigned_And_Other">Unassigned and Other Code Points</a></li>
				<li>7.1.3 <a href="tr10-22.html#Implicit_Weights">Implicit Weights</a></li>
				<li>7.1.4 <a href="tr10-22.html#Trailing_Weights">Trailing Weights</a></li>
				<li>7.1.5 <a href="tr10-22.html#Hangul_Collation">Hangul Collation</a></li>
			</ul>
			</li>
			<li>7.2 <a href="tr10-22.html#Tertiary_Weight_Table">Tertiary Weight Table</a></li>
		</ul>
		</li>
		<li>8 <a href="tr10-22.html#Searching">Searching and Matching</a><ul class="toc">
			<li>8.1 <a href="tr10-22.html#Collation_Folding">Collation Folding</a></li>
		</ul>
		</li>
		<li>9 <a href="tr10-22.html#Data_Files">Data Files</a></li>
		<li>Appendix A: <a href="tr10-22.html#Deterministic_Sorting">Deterministic_Sorting</a></li>
		<li><a href="tr10-22.html#Acknowledgements">Acknowledgements</a></li>
		<li><a href="tr10-22.html#References">References</a></li>
		<li><a href="tr10-22.html#Migration">Migration Issues</a></li>
		<li><a href="tr10-22.html#Modifications">Modifications</a></li>
	</ul>
	<br>
	<hr><br>
	<h2>1 <a name="Introduction">Introduction</a></h2>
	
	<p>Collation is the general term for the process and function of determining 
	the sorting order of strings of characters. It is a key function in computer 
	systems; whenever a list of strings is presented to users, they are likely to 
	want it in a sorted order so that they can easily and reliably find individual 
	strings. Thus it is widely used in user interfaces. It is also crucial for 
	databases, both in sorting records and in selecting sets 
	of records with fields within given bounds.</p>
	<p>Collation varies according to language and culture: 
	Germans, French and Swedes sort the same characters differently. It may also 
	vary by specific application: even within the same language, dictionaries may 
	sort differently than phonebooks or book indices. For non-alphabetic scripts 
	such as East Asian ideographs, collation can be either phonetic or based on 
	the appearance of the character. Collation can also be customized 
	according to user preference, such as ignoring punctuation or not, 
	putting uppercase before lowercase (or vice versa), and so on. Linguistically 
	correct <i>searching</i> needs to use the same mechanisms: just as &quot;v&quot; 
	and &quot;w&quot; sort as if they were the same base letter in Swedish, a loose search 
	should pick up words with either one of them.</p>
	<p>Collation implementations must deal with the complex linguistic 
	conventions for 
	ordering text in specific languages, and provide for common customizations based 
	on user preferences. Furthermore, algorithms that allow for good performance are crucial for 
	any collation mechanisms to be accepted in the marketplace.</p>
	<p><i>Table 1</i> shows some examples of cases where sort order differs 
	by language, usage, or another customization.</p>
	
	<p class="caption"><a name="Example_Differences_Table"></a>Table 1. Example Differences</p>
	
	<div align="center">
		<table border="1" cellspacing="1" cellpadding="4">
			<tr>
				<td width="33%" rowspan="2">Language</td>
				<td width="33%">Swedish:</td>
				<td width="33%">z &lt; ö</td>
			</tr>
			<tr>
				<td>German:</td>
				<td>ö &lt; z</td>
			</tr>
			<tr>
				<td rowspan="2">Usage</td>
				<td>German Dictionary:</td>
				<td>of &lt; öf</td>
			</tr>
			<tr>
				<td>German Telephone:</td>
				<td>öf &lt; of</td>
			</tr>
			<tr>
				<td rowspan="2">Customizations</td>
				<td>Upper-First</td>
				<td>A &lt; a</td>
			</tr>
			<tr>
				<td>Lower-First</td>
				<td>a &lt; A</td>
			</tr>
		</table>
	</div>
		
	<p>Languages vary regarding which types of comparisons to use (and in which 
	order they are to be applied), and in what constitutes a fundamental element 
	for sorting. For example, Swedish treats <em>ä</em> as an individual letter, 
	sorting it after <em>z</em> in the alphabet; German, however, sorts it either 
	like <em>ae</em> or like other accented forms of <em>a</em>, thus following
	<em>a</em>. In Slovak, the digraph <i>ch</i> sorts as if it were a separate 
	letter after <i>h</i>. Examples from other languages and scripts abound. Languages 
	whose writing systems use uppercase and lowercase typically ignore the differences 
	in case, unless there are no other differences in the text.</p>
	
	<p>It is important to ensure that collation meets user expectations as fully 
	as possible. For example, in the majority of Latin languages, ø sorts as an 
	accented variant of o, meaning that most users would expect ø alongside o. However, 
	a few languages, such as Norwegian and Danish, sort ø as 
	a unique element after z. Sorting &quot;Søren&quot; after &quot;Sylt&quot; in a long list, 
	as would be expected in Norwegian or Danish, will cause problems 
	if the user expects ø as a variant of o. A user will look for &quot;Søren&quot; between 
	&quot;Sorem&quot; and &quot;Soret&quot;, not see it in the selection, and assume the string 
	is missing, confused because it was sorted in a completely different 
	location. In matching, the same can occur, which can cause significant problems 
	for software customers; for example, in a database selection the user may not realize 
	what records are missing. See <i>Section 
	1.5, <a href="tr10-22.html#Other_Applications_of_Collation">Other Applications of Collation</a></i>.</p>
	
	<p>With Unicode applications widely deployed, multilingual data is the rule, not 
	the exception. Furthermore, it is increasingly common to see users with many 
	different sorting expectations accessing the data. For example, a French company 
	with customers all over Europe will include names from many different languages. 
	If a German employee at this French 
	company accesses the data, the customer names need to show up in the order that 
	meets this employee&#39;s expectations&#x2014;that is, in a German order&#x2014;even though 
	there will be many different accented characters that do not normally appear 
	in German text.</p>
	<p>For scripts and characters not used in a particular language, explicit 
	rules may not exist. For example, Swedish and French have clearly specified, distinct 
	rules for sorting ä (either after z or as an accented character with a secondary 
	difference from a), but neither defines the ordering of characters such 
	as Ж, ש, ♫, ∞, ◊, or ⌂.</p>
	
	<h3>1.1 <a name="Multi_Level_Comparison">Multi-Level Comparison</a></h3>
	
	<p>To address the complexities of language-sensitive sorting, a <i>multilevel</i> 
	comparison algorithm is employed. In comparing two words, the most 
	important feature is the identity of the base letters&#x2014;for example, the difference between an
	<i>A</i> and a <i>B</i>. Accent differences are typically ignored, if the base letters
	differ. Case differences (uppercase versus 
	lowercase), are typically ignored, if the base letters
	or their accents differ. Treatment of punctuation varies. In some situations a punctuation character 
	is treated like a base letter. In other situations, it should be ignored 
	if there are any base, accent, or case differences. There may also be a final, 
	tie-breaking level, whereby if there are no other differences at all in the 
	string, the (normalized) code point order is used.</p>
	
	<p class="caption"><a name="Comparison_Levels_Table"></a>Table 2. Comparison Levels</p>
	
	<div align="center">
		<table border="1" cellspacing="1" cellpadding="4">
			<tr>
				<th>Level</th>
				<th>Description</th>
				<th>Examples</th>
			</tr>
			<tr>
				<th>L1</th>
				<td>Base characters</td>
				<td>role &lt; roles &lt; rule</td>
			</tr>
			<tr>
				<th>L2</th>
				<td>Accents</td>
				<td>role &lt; r<u>ô</u>le &lt; role<font color="#0000FF">s</font></td>
			</tr>
			<tr>
				<th>L3</th>
				<td>Case</td>
				<td>role &lt; <u>R</u>ole &lt; r<font color="#0000FF">ô</font>le</td>
			</tr>
			<tr>
				<th>L4</th>
				<td>Punctuation</td>
				<td>role &lt; <u>“</u>role<u>”</u> &lt; <font color="#0000FF">R</font>ole</td>
			</tr>
			<tr>
				<th>Ln</th>
				<td>Tie-Breaker</td>
				<td>role &lt; ro<u>□</u>le &lt; <font color="#0000FF">“</font>role<font color="#0000FF">”</font></td>
			</tr>
		</table>
	</div>
	
	<p>The examples in <i>Table 2</i> are in English; the levels may correspond to different writing
	system features 
	in other languages. In each example for levels L2 through Ln, the 
	differences on that level (indicated by the underlined characters) are swamped 
	by the stronger-level differences (indicated by the blue text). For example, 
	the L2 example shows that difference between an <u>o</u> and an accented <u>
	ô</u> is swamped by an L1 difference (the presence or absence of an <i>s</i>). 
	In the last example, the □ represents a format character, which is otherwise 
	completely ignorable.</p>
	<p>The primary level (L1) is for the basic sorting 
	of the text, and the non-primary levels (L2..Ln) are for adjusting string
	weights for other linguistic 
	elements in the writing system that are important to users in ordering, but 
	less important than the order of the basic sorting. In practice, fewer 
	levels may be needed, depending on user preferences or customizations.</p>
	
	<h4>1.1.1 <a name="Collation_And_Code_Chart_Order">Collation Order and Code Chart Order</a></h4>
	
		<p>Many people expect the 
		characters in their language to be in the &quot;correct&quot; order in the Unicode code charts. 
		Because collation varies by language and not just by script, it is not 
		possible to arrange the encoding for characters so that simple binary string 
		comparison produces the desired collation order for all languages. Because 
		multi-level sorting is a requirement, it is not even possible to arrange 
		the encoding for characters so that simple binary string comparison produces 
		the desired collation order for any particular language. Separate data tables 
		are required for correct sorting order. For more information on tailorings 
		for different languages, see [<a href="tr10-22.html#CLDR">CLDR</a>].</p>
		
		
		<p>The basic principle to remember is: <b><i>The position of characters
		in the Unicode code charts does not specify their sorting weight.</i></b></p>
	
	
	<h3>1.2 <a name="Canonical_Equivalence">Canonical Equivalence</a></h3>
	
	<p>There are many cases in Unicode where two sequences of characters 
	are canonically equivalent: the sequences represent essentially the
	same text, but with different actual sequences. For more information, see 
	[<a href="tr10-22.html#UAX15">UAX15</a>].</p>
	<p>Sequences that are canonically equivalent must sort the same. 
	<i>Table 3</i> gives some examples of canonically equivalent sequences. 
	For example, the <i>angstrom sign</i> was encoded 
	for compatibility, and is canonically equivalent to an <i>A-ring</i>. The latter is 
	also equivalent to the decomposed sequence of <i>A</i> plus the <i>combining ring</i> character. 
	The order of certain combining marks is also irrelevant in many cases, so such sequences 
	must also be sorted the same, as shown in the second example. The third example shows
	a composed character that can be decomposed in four different ways, all 
	of which are canonically equivalent.</p>
	
	<p class="caption"><a name="Canonical_Equivalence_Table"></a>Table 3. Canonical Equivalence</p>

	<div align="center">
		<table cellpadding="4">
			<tr>
				<td nowrap rowspan="3">1</td>
				<td nowrap>Å</td>
				<td>U+212B ANGSTROM SIGN</td>
			</tr>
			<tr>
				<td nowrap>Å</td>
				<td>U+00C5 LATIN CAPITAL LETTER A WITH RING ABOVE</td>
			</tr>
			<tr>
				<td nowrap>A ◌̊</td>
				<td>U+0041 LATIN CAPITAL LETTER A, U+030A COMBINING RING ABOVE</td>
			</tr>
			<tr>
				<td nowrap colspan="3">&nbsp;</td>
			</tr>
			<tr>
				<td nowrap rowspan="2">2</td>
				<td nowrap>x ◌̛ ◌̣</td>
				<td>U+0078 LATIN SMALL LETTER X, U+031B COMBINING HORN, U+0323 COMBINING 
				DOT BELOW</td>
			</tr>
			<tr>
				<td nowrap>x ◌̣ ◌̛</td>
				<td>U+0078 LATIN SMALL LETTER X, U+0323 COMBINING DOT BELOW, U+031B 
				COMBINING HORN</td>
			</tr>
			<tr>
				<td nowrap colspan="3">&nbsp;</td>
			</tr>
			<tr>
				<td nowrap rowspan="5">3</td>
				<td nowrap>ự</td>
				<td>U+1EF1 LATIN SMALL LETTER U WITH HORN AND DOT BELOW</td>
			</tr>
			<tr>
				<td nowrap>ụ◌̛</td>
				<td>U+1EE5 LATIN SMALL LETTER U WITH DOT BELOW, U+031B COMBINING 
				HORN</td>
			</tr>
			<tr>
				<td nowrap>u ◌̛ ◌̣</td>
				<td>U+0075 LATIN SMALL LETTER U, U+031B COMBINING HORN, U+0323 COMBINING 
				DOT BELOW</td>
			</tr>
			<tr>
				<td nowrap>ư ◌̣</td>
				<td>U+01B0 LATIN SMALL LETTER U WITH HORN, U+0323 COMBINING DOT 
				BELOW</td>
			</tr>
			<tr>
				<td nowrap>u ◌̣ ◌̛</td>
				<td>U+0075 LATIN SMALL LETTER U, U+0323 COMBINING DOT BELOW, U+031B 
				COMBINING HORN</td>
			</tr>
		</table>
	</div>
		
	<h3>1.3 <a name="Contextual_Sensitivity">Contextual Sensitivity</a></h3>
	
	<p>There are additional complications in certain 
	languages, where the comparison is context sensitive and depends on more than 
	just single characters compared directly against one another, as shown
	in <i>Table 4</i>.</p>
	
	<p>The first example of such a complication consists of <i><b>contractions</b></i>, 
	where two (or more) characters sort as if they were 
	a single base letter. In the table below, <i>CH</i> acts like a single letter sorted after 
	<i>C</i>.</p>
	
	<p>The second example consists of <i><b>expansions</b></i>, where a single character 
	sorts as if it were a sequence of two (or 
	more) characters. In the table below, an <i>Œ</i> ligature sorts as if it 
	were the sequence of <i>O</i> + <i>E</i>.</p>
	
	<p>Both contractions and expansions can be combined: that is, two (or more) characters 
	may sort as if they were a different sequence of two (or more) characters. In 
	the third example, for Japanese, a length mark sorts like the vowel of the previous 
	syllable: as an <i>A after</i> <i>KA</i> and as an <i>I</i> after <i>KI</i>.</p>
	
	<p class="caption"><a name="Context_Sensitivity_Table"></a>Table 4. Context Sensitivity</p>
	
	<div align="center">
		<table border="1" cellspacing="1" cellpadding="4">
			<tr>
				<th>Contractions</th>
				<td>H &lt; Z<i>, but<br>
				</i>CH &gt; CZ</td>
			</tr>
			<tr>
				<th>Expansions</th>
				<td>OE &lt; Œ &lt; OF</td>
			</tr>
			<tr>
				<th>Both</th>
				<td>カー &lt; カイ<i>, but<br>
				</i>キー &gt; キイ</td>
			</tr>
		</table>
	</div>
	
	<p>Some languages have additional oddities in the way they sort. Normally, 
	all differences in sorting are assessed from the start to the end of the 
	string. If all of the base letters are the same, the first accent difference 
	determines the final order. In row 1 of 
	<i>Table 5</i>, the first accent 
	difference is on the <i>o</i>, so that is what determines the order. In French 
	and a few other languages, however, it is the <i>last</i> accent difference 
	that determines the order, as shown in row 2.</p>
	
	<p class="caption"><a name="French_Ordering_Table"></a>Table 5. French Ordering</p>
	
	<div align="center">
		<table border="1" cellspacing="1" cellpadding="4">
			<tr>
				<th>Normal Accent Ordering</th>
				<td>cote &lt; coté &lt; c<span class="marked"><span style="background-color: #00FF00">ô</span></span>te 
				&lt; c<span class="marked"><span style="background-color: #00FF00">ô</span></span>té</td>
			</tr>
			<tr>
				<th>French Accent Ordering</th>
				<td>cote &lt; côte &lt; cot<span class="marked"><span style="background-color: #00FF00">é</span></span> 
				&lt; côt<span class="marked"><span style="background-color: #00FF00">é</span></span></td>
			</tr>
		</table>
	</div>
	
	<h3>1.4 <a name="Customization">Customization</a></h3>
	
	<p>In practice, there are additional features of collation that users need to control. 
	These are expressed in user-interfaces and eventually in APIs. Other customizations 
	or user preferences include the following:</p>
	<ul>
		<li><i>Language.</i> This is the most important feature, 
		because it is crucial that the collation match the expectations of users 
		of the target language community.</li>
		<li><i>Strength.</i> This refers to the number of 
		levels that are to be considered in comparison, and is another important
		feature. Most of 
		the time a three-level strength is needed for comparison of strings. In some cases, a larger 
		number of levels will be needed, while in others&#x2014;especially in searching&#x2014;fewer 
		levels will be desired.</li>
		<li><i>Case Ordering.</i> Some dictionaries and authors collate uppercase before 
		lowercase while others use the reverse, so that preference needs to be customizable. 
		Sometimes the case ordering is mandated by the government, as in Denmark. 
		Often it is simply a customization or user preference.</li>
		<li><i>Punctuation.</i> Another common 
		option is whether to treat punctuation (including spaces) as base characters 
		or treat such characters as only making a level 4 difference.</li>
		<li><i>User-Defined Rules.</i> Such rules provide specified results for 
		given combinations of letters. For example, in an index, an author may wish 
		to have symbols sorted as if they were spelled out; thus &quot;?&quot; may sort as 
		if it were the string &quot;question mark&quot;.</li>
		<li><i>Merged Tailorings.</i> An option may allow the merging of sets of rules 
		for different languages. For example, someone may want Latin characters 
		sorted as in French, and Arabic characters sorted as in Persian. 
		In such an approach, generally one of the tailorings is designated the “master” in 
		cases of conflicting weights for a given character.</li>
		<li><i>Script Order.</i> A user may wish to specify which scripts come 
		first. For example, in a book index an author may want index entries
		in the predominant script that the book itself is written in 
		to come ahead of entries for any other script. For example:
		<blockquote>
			<p>b &lt; ב &lt; β &lt; б [Latin < Hebrew < Greek < Cyrillic] <i>versus</i><br>
			β &lt; b &lt; б &lt; ב [Greek < Latin < Cyrillic < Hebrew]</p>
		</blockquote>
		<p>Attempting to achieve this effect by introducing an extra strength 
		level before the first (primary) level would give incorrect ordering results for 
		strings which mix characters of more than one script.</p>
		</li>
		<li><i>Numbers.</i> A customization may be desired to allow sorting numbers in numeric order. 
		If strings including numbers 
		are merely sorted alphabetically, the string “A-10” comes before the string “A-2”, which is often not 
		desired. This behavior can be customized, but it is complicated by 
		ambiguities in recognizing numbers within strings (because they may 
		be formatted according to different language conventions). Once each number 
		is recognized, it can be preprocessed to convert it into a format that allows 
		for correct numeric sorting, such as a textual version of the IEEE numeric 
		format.</li>
	</ul>
	<p>Phonetic sorting of Han characters requires use of either a lookup 
	dictionary of words or, more typically, special construction of programs or 
	databases to maintain an associated phonetic spelling for the words in the text.</p>
	
	<h3>1.5 <a name="Other_Applications_of_Collation">Other Applications of Collation</a></h3>
	
	<p>The same principles about collation behavior apply to realms beyond sorting. 
	In particular, searching should behave consistently with sorting. For example, 
	if <i>v</i> and <i>w</i> are treated as identical base letters in Swedish sorting, 
	then they should also be treated the same for searching. The ability to set the 
	maximal strength level is very important for searching.</p>
	
	<p>Selection is the process of using the comparisons between the endpoints of 
	a range, as when using a SELECT command in a database query. It is crucial that 
	the range returned be correct according to the user's expectations. 
	For example, if a German businessman making a database selection to 
	sum up revenue in each of of the cities from <i>O...</i> to <i>P...</i> for 
	planning purposes does not realize that all cities starting with <i>Ö</i> were 
	excluded because the query selection was using a Swedish collation,  
	he will be one very unhappy customer.</p>
	<p>A sequence of characters considered a unit in collation, such as
	<i>ch</i> in Slovak, represents a <i>tailored</i> grapheme cluster. For applications 
	of this concept, see Unicode Technical Standard #18, "Unicode 
	Regular Expressions" [<a href="tr10-22.html#UTS18">UTS18</a>]. For more information 
	on grapheme clusters, see  Unicode Standard Annex #29, "Unicode Text Segmentation"
        [<a href="tr10-22.html#UAX29">UAX29</a>].</p>

	<h3>1.6 <a name="Interleaved_Levels">Interleaved Levels</a></h3>
	
	<p>Levels may also need to be interleaved. For example, the simplest way to sort a database 
	according to two fields is to sort field by field, sequentially. 
	This gives the results in column one in 
	<i>Table 6</i>. (The examples in this table are ordered using
	the <b>Shifted</b> option for handling variable collation elements such as the space character;
	see <i>Section 3.6.2 <a href="tr10-22.html#Variable_Weighting">Variable Weighting</a></i> for details.) All the 
	levels in Field 1 are compared first, and then all the levels in Field 2. The problem 
	with this approach is that high-level differences in the second field are swamped 
	by minute differences in the first field, which results in unexpected ordering for 
	the first names.</p>
	
	<p class="caption"><a name="Merged_Fields_Table"></a>Table 6. Merged Fields</p>

	<div align="center">
		<table border="1" cellspacing="0" cellpadding="4">
			<tr>
				<th width="33%">Sequential</th>
				<th width="33%">Weak First</th>
				<th width="34%">Merged</th>
			</tr>
			<tr>
				<td width="33%">F1<sub>L1</sub>, F1<sub>L2</sub>, F1<sub>L3</sub>,<br>
				<font color="#0000FF">F2<sub>L1</sub>, F2<sub>L2</sub>, F2<sub>L3</sub></font></td>
				<td width="33%">F1<sub>L1</sub>,<br>
				<font color="#0000FF">F2<sub>L1</sub>, F2<sub>L2</sub>, F2<sub>L3</sub></font></td>
				<td width="34%">F1<sub>L1</sub>, <font color="#0000FF">F2<sub>L1</sub>,<br>
				</font>F1<sub>L2</sub>, <font color="#0000FF">F2<sub>L2</sub>,<br>
				</font>F1<sub>L3</sub>, <font color="#0000FF">F2<sub>L3</sub></font></td>
			</tr>
			<tr>
				<td width="33%">
				<table border="0" width="100%" class="noborder" cellpadding="2">
					<tr>
						<td width="50%"><font color="#FF0000">di&nbsp;Silva</font></td>
						<td width="50%">Fred</td>
					</tr>
					<tr>
						<td width="50%"><font color="#FF0000">di&nbsp;Silva</font></td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">diSilva</td>
						<td width="50%">Fred</td>
					</tr>
					<tr>
						<td width="50%">diSilva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">disílva</td>
						<td width="50%">Fred</td>
					</tr>
					<tr>
						<td width="50%">disílva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
				</table>
				</td>
				<td width="33%">
				<table border="0" width="100%" class="noborder" cellspacing="0" cellpadding="2">
					<tr>
					  <td>disílva</td>
					  <td>Fred</td>
				  </tr>
					<tr>
					  <td>diSilva</td>
					  <td>Fred</td>
				  </tr>
					<tr>
					  <td><font color="#FF0000">di&nbsp;Silva</font></td>
					  <td>Fred</td>
				  </tr>
					<tr>
						<td width="50%"><font color="#FF0000">di&nbsp;Silva</font></td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">diSilva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">disílva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
				</table>
				</td>
				<td width="34%">
				<table border="0" width="100%" class="noborder" cellspacing="0" cellpadding="2">
					<tr>
					  <td><font color="#FF0000">di&nbsp;Silva</font></td>
					  <td>Fred</td>
				  </tr>
					<tr>
					  <td>diSilva</td>
					  <td>Fred</td>
				  </tr>
					<tr>
					  <td>disílva</td>
					  <td>Fred</td>
				  </tr>
					<tr>
						<td width="50%"><font color="#FF0000">di&nbsp;Silva</font></td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">diSilva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">disílva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
				</table>
				</td>
			</tr>
		</table>
		</div>
		
	<p>A second way to do the sorting is to ignore all but base-level differences in the 
	sorting of the first field. This gives the results in the second column. The first 
	names are all in the right order, but the problem is now that the first 
	field is not correctly ordered except by the base character level.</p>
	
	<p>The correct way to sort two fields is to merge the fields, as shown in the 
	"Merged" column. Using this technique, all differences in the fields are taken into 
	account, and the levels are considered uniformly. Accents in all fields are 
	ignored if there are any base character differences in any of the field, and case 
	in all fields is ignored if there are accent or base character differences in 
	any of the fields.</p>
	
	<h3>1.7 <a name="Performance">Performance</a></h3>
	
	<p>Collation is one of the most performance-critical features in a system. Consider 
	the number of comparison operations that are involved in sorting or searching 
	large databases, for example. Most production implementations will use a number 
	of optimizations to speed up string comparison.</p>
	
	<p>Strings are often preprocessed into sort keys, so that multiple comparisons 
	operations are much faster. With this mechanism, a collation engine 
	generates a <i>sort key</i> from any given string. The binary comparison 
	of two sort keys yields the same result (less, equal, or greater) as 
	the collation engine would return for a comparison of the original strings. 
	Thus, for a given collation C and any two strings A and B:</p>
	
	<p align="center">A ≤ B according to C if and only if sortkey(C, A) ≤ sortkey(C, B)</p>
	
	<p>However, simple string comparison is faster for any individual comparison, 
	because the generation of a sort key requires processing 
	an entire string, while differences in most string comparisons are found before 
	all the characters are processed. Typically, there is a considerable difference 
	in performance, with simple string comparison being about 5 to 10 times faster 
	than generating sort keys and then using a binary comparison.</p>
	
	<p>Sort keys, on the other hand, can be much faster for multiple comparisons. Because binary 
	comparison is much faster than string comparison, it is faster to
	use sort keys whenever there will 
	be more than about 10 comparisons per string, if the system can afford the 
	storage.</p>
	
	<h3>1.8 <a name="Common_Misperceptions">What Collation is Not</a></h3>
	
	<p>There are a number of common expectations about and misperceptions of collation. 
	This section points out many things that collation is not and cannot be.</p>
	
		<p><b>Collation is not aligned with character sets or repertoires of 
		characters.</b></p>

		<blockquote>		
		<p>Swedish and German share most of the same characters, for example, 
		but have very different sorting orders.</p>
		</blockquote>
		
		<p><b>Collation is not code point (binary) order.</b></p>
		
		<blockquote>		
		<p>A simple example 
		of this is the fact that capital Z comes before lowercase a in the
		code charts. As noted earlier, beginners may complain 
		that a particular Unicode character is “not in the right place in 
		the code chart.” That is a misunderstanding of the role of the character 
		encoding in collation. While the Unicode Standard does not gratuitously 
		place characters such that the binary ordering is odd, the only way to get 
		the linguistically-correct order is to use a language-sensitive collation, 
		not a binary ordering.</p>
		</blockquote>
		
		<p><b>Collation is not a property of strings.</b></p>
		
		<blockquote>		
		<p>In a list of cities, 
		with each city correctly tagged with its language, a German 
		user will expect to see all of the cities sorted according to German order, 
		and will not expect to see a word with <i>ö</i> appear after <i>z</i>, simply 
		because the city has a Swedish name. As in the earlier example, it is crucially 
		important that if a German businessman makes a database selection, such 
		as to sum up revenue in each of of the cities from <i>O...</i> to <i>P...</i> 
		for planning purposes, cities starting with <i>Ö</i> <i>not</i> 
		be excluded.</p>
		</blockquote>
		
		<p><b>Collation order is not preserved under concatenation or substring 
		operations, in general.</b></p>
		
		<blockquote>		
		<p>For example, the fact that x is less than y does 
		not mean that x + z is less than y + z, because characters may form 
		contractions across the substring or concatenation boundaries. 
		In summary:</p>
		</blockquote>
		
		<p align="center">
		x &lt; y does not imply that xz &lt; yz<br>
		x &lt; y does not imply that zx &lt; zy<br>
		xz &lt; yz does not imply that x &lt; y<br>
		zx &lt; zy does not imply that x &lt; y<br>
&nbsp;</p>

		<p><b>Collation order is not preserved when comparing sort keys generated 
		from different collation sequences.</b></p>
		
		<blockquote>		
		<p>Remember that sort keys are a preprocessing 
		of strings according to a given set of collation features. Different 
		features result in different binary sequences. For example, if
		there are two collations, F and G, where F is a French collation (with accents 
		compared from the end), and G is a German phonebook ordering, then:</p>
		<ul>
			<li>A ≤ B according to F if and only if sortkey(F, A) ≤ sortkey(F, B),
			<i>and</i></li>
			<li>A ≤ B according to G if and only if sortkey(G, A) ≤ sortkey(G, B)</li>
			<li>The relation between sortkey(F, A) and sortkey(G, B) says
			nothing about whether A ≤ B according to F, or whether A 
			≤ B according to G.</li>
		</ul>
		</blockquote>

		<p><b>Collation order is not a stable sort.</b></p>
		
		<blockquote>		
		<p>Stability is a property of a 
		sort algorithm, not of a collation sequence. For more information, see <i>
		Section 3.8, <a href="tr10-22.html#Stability">Stability</a></i>.</p>
		</blockquote>
		
		<p><b>Collation order is not fixed.</b></p>
		
		<blockquote>		
		<p>Over time, collation order will 
		vary: there may be fixes needed as more information becomes 
		available about languages; there may be new government or industry standards 
		for the language that require changes; and finally, new characters 
		added to the Unicode Standard will interleave with the previously-defined 
		ones. This means that collations must be carefully versioned.</p>
		</blockquote>
	
	<h3>1.9 <a name="Scope">The Unicode Collation Algorithm</a></h3>
	
	<p>The Unicode Collation Algorithm (UCA) details how to 
	compare two Unicode strings while remaining conformant to the requirements of
	the Unicode Standard. The UCA also supplies the Default Unicode Collation 
	Element Table (DUCET), which is data specifying the default collation order 
	for all Unicode characters. This table is designed so that it can be <i>tailored</i> 
	to meet the requirements of different languages and customizations.</p>
	<p>Briefly stated, the Unicode Collation Algorithm takes an input Unicode string 
	and a Collation Element Table, containing mapping data for characters. It produces 
	a sort key, which is an array of unsigned 16-bit integers. Two or more sort 
	keys so produced can then be binary-compared to give the correct comparison 
	between the strings for which they were generated.</p>
	<p>The Unicode Collation Algorithm assumes multiple-level key weighting, along 
	the lines widely implemented in IBM technology, and as described in the Canadian 
	sorting standard [<a href="tr10-22.html#CanStd">CanStd</a>] and the International String 
	Ordering standard [<a href="tr10-22.html#ISO14651">ISO14651</a>].</p>
	<p>By default, the algorithm makes use of three fully-customizable levels. For 
	the Latin script, these levels correspond roughly to:</p>
	<ol>
		<li>alphabetic ordering </li>
		<li>diacritic ordering </li>
		<li>case ordering. </li>
	</ol>
	<p>A final level may be used for tie-breaking 
	between strings not otherwise distinguished.</p>
	<p>This design allows implementations to produce culturally acceptable collation, 
	with a minimal burden on memory requirements 
	and performance. In particular, Collation Element Tables only require storage 
	of 32 bits of collation data per significant character.</p>
	<p>Implementations of the Unicode Collation Algorithm are not limited 
	to supporting only three levels. They are free to support a fully customizable 
	4th level (or more levels), as long as they can produce the same results as 
	the basic algorithm, given the right Collation Element Tables. For example, 
	an application which uses the algorithm, but which must treat some collection 
	of special characters as ignorable at the first three levels <i>and</i> must 
	have those specials collate in non-Unicode order (for example to emulate 
	an existing EBCDIC-based collation), may choose to have a fully customizable 
	4th level. The downside of this choice is that such an application will require 
	more storage, both for the Collation Element Table and in constructed sort keys.</p>
	<p>The Collation Element Table may be tailored to produce particular culturally 
	required orderings for different languages or locales. As in the algorithm itself, 
	the tailoring can provide full customization for three (or more) levels.</p>
	
	<h4>1.9.1 <a name="Goals">Goals</a></h4>
	
	<p>The algorithm is designed to satisfy the following goals:</p>
	<ol>
		<li>A complete, unambiguous, specified ordering for all characters in Unicode.</li>
		<li>A complete resolution of the handling of canonical and compatibility 
		equivalences as relates to the default ordering.</li>
		<li>A complete specification of the meaning and assignment of collation 
		levels, including whether a character is ignorable by default in collation.</li>
		<li>A complete specification of the rules for using the level weights to 
		determine the default collation order of strings of arbitrary length.</li>
		<li>Allowance for override mechanisms (<i>tailoring</i>) to create language-specific 
		orderings. Tailoring can be provided by any well-defined syntax that takes 
		the default ordering and produces another well-formed ordering.</li>
		<li>An algorithm that can be efficiently implemented, in terms of both performance 
		and memory requirements.</li>
	</ol>
	<p>Given the standard ordering and the tailoring for any particular language, 
	any two companies or individuals&#x2014;with their own proprietary implementations&#x2014;can 
	take any arbitrary Unicode input and produce exactly the same ordering 
	of two strings. In addition, when given a tailoring specifying French accents 
	this algorithm passes the Canadian and ISO 14651 benchmarks ([<a href="tr10-22.html#CanStd">CanStd</a>], 
	[<a href="tr10-22.html#ISO14651">ISO14651</a>]).</p>
	<blockquote>
		<p><b>Note:</b> The Default Unicode Collation Element Table does not explicitly 
		list weights for all assigned Unicode characters. However, the algorithm 
		is well defined over <i>all</i> Unicode code points. See <i>
		Section 7.1.2, <a href="tr10-22.html#Unassigned_And_Other">Unassigned and Other Code Points</a></i>.</p>
	</blockquote>
	
	<h4>1.9.2 <a name="Non-Goals">Non-Goals</a></h4>
	
	<p>The Default Unicode Collation Element Table (DUCET) explicitly does not provide for 
	the following features:</p>
	<ol>
		<li><i>Reversibility:</i> from a Collation Element one is not guaranteed 
		to be able to recover the original character.</li>
		<li><i>Numeric formatting:</i> numbers composed of a string of digits or 
		other numerics will not necessarily sort in <i>numerical order.</i> </li>
		<li><i>API:</i> no particular API is specified or required for the algorithm.
		</li>
		<li><i>Title sorting:</i> removing articles such as <i>a</i> 
		and <i>the</i> during bibliographic sorting is not provided.</li>
		<li><i>Stability of binary sort key values between versions:</i> weights in
		the DUCET may change between versions. For more 
		information, see <i>Section 3.8, <a href="tr10-22.html#Stability">Stability</a></i>.</li>
		<li><i>Linguistic applicability:</i> to meet most user expectations, a linguistic 
		tailoring is needed. For more information, see <i>Section 
		5, <a href="tr10-22.html#Tailoring">Tailoring</a></i>.</li>
	</ol>

	<p>The feature of linguistic applicability deserves further
	discussion. DUCET does not and cannot actually provide linguistically
	correct sorting for every language without further tailoring.
	That would be impossible, due to conflicting requirements for
	ordering different languages that share the same script. It
	is not even possible in the specialized cases where a script
	may be predominantly used by a single language, because of the
	limitations of the DUCET table design and because of the
	requirement to minimize implementation overhead for
	all users of DUCET.</p>

	<p>Instead, the goal of DUCET is to provide a reasonable default
	ordering for all scripts that are <i>not</i> tailored.
	Any characters used in the language of primary
	interest for collation are expected to be tailored to meet all the appropriate
	linguistic requirements for that language. For example, for
	a user interested primarily in the Malayalam language, DUCET
	would be tailored to get all details correct for the expected Malayalam
	collation order, while leaving other characters
	(Greek, Cyrillic, Han, and so forth) in the default order, because the order
	of those other characters is not of primary concern. Conversely,
	a user interested primarily in the Greek language would use
	a Greek-specific tailoring, while leaving the Malayalam
	(and other) characters in their default order in the table.</p>


	<h2><a name="Conformance"></a>2 Conformance</h2>
	
	<p>The Unicode Collation Algorithm does not restrict the
	many different ways in which implementations can compare strings. However, any 
	Unicode-conformant implementation that purports to implement the Unicode Collation 
	Algorithm must do so as described in this document.</p>
	
	<p>A conformance test for the UCA is available 
	in [<a href="tr10-22.html#Tests10">Tests10</a>].</p>

	<p>The algorithm is a <i>logical</i> specification. Implementations are free to change any 
	part of the algorithm as long as any two strings compared by the implementation 
	are ordered the same as they would be by the algorithm as specified. 
	Implementations may also 
	use a different format for the data in the Collation Element Table. The sort 
	key is a logical intermediate object: if an implementation 
	produces the same results in comparison of strings, the sort keys can differ 
	in format from what is specified in this document. 
	(See <i>Section 6, <a href="tr10-22.html#Implementation_Notes">Implementation Notes</a></i>.)</p>
	
	<p>The conformance requirements of the Unicode Collation Algorithm are as follows:</p>
	<table class="noborder" cellpadding="8">
		<tr>
			<td class="noborder"><b><a name="C1">C1</a></b></td>
			<td class="noborder"><i>Given a well-formed Unicode Collation Element 
			Table, a conformant implementation shall replicate the same comparisons 
			of strings as those produced by Section 4,
			<a href="tr10-22.html#Main_Algorithm">Main Algorithm</a>.</i>
			<p>In particular, a conformant implementation 
			must be able to compare any two canonical-equivalent strings as being 
			equal, for all Unicode characters supported by that implementation.</p>
			<p>If a conformant implementation compares strings in a legacy character 
			set, it must provide the same results as if those strings had been transcoded 
			to Unicode.</p>
			</td>
		</tr>
		<tr>
			<td width="1%" class="noborder"><b><a name="C2">C2</a></b></td>
			<td class="noborder"><i>A conformant implementation shall support at 
			least three levels of collation.</i>
			<p>A conformant implementation is 
			only required to implement three levels. However, it may implement four 
			(or more) levels if desired.</p>
			</td>
		</tr>
		<tr>
			<td width="1%" class="noborder"><b><a name="C3">C3</a></b></td>
			<td class="noborder"><i>A conformant implementation that supports any 
			of the following features: backward levels, variable weighting, and semi-stability, 
			shall do so in accordance with this specification.</i>
			<p>A conformant 
			implementation is not required to support these features; however, if 
			it does, it must interpret them properly. Unless they are functioning 
			in a very restricted domain, it is strongly recommended that implementations 
			support a backwards secondary level, because this is required for French.</p>
			</td>
		</tr>
		<tr>
			<td width="1%" class="noborder"><b><a name="C4">C4</a></b></td>
			<td class="noborder"><i>A conformant implementation must specify the 
			version number of this Unicode Technical Standard.</i>
			<p>The precise values of the collation elements for the characters may 
			change over time as new characters are added to the Unicode Standard. 
			The version number of this document is synchronized with the version 
			of the Unicode Standard which specifies the repertoire covered.</p>
			</td>
		</tr>
		<tr>
			<td width="1%" class="noborder"><b><a name="C5">C5</a></b></td>
			<td class="noborder"><i>An implementation claiming conformance to Matching 
			and Searching according to UTS #10, shall meet the requirements described 
			in Section 8, <a href="tr10-22.html#Searching">Searching and 
			Matching</a>.</i></td>
		</tr>
		<tr>
			<td width="1%" class="noborder"><b><a name="C6">C6</a></b></td>
			<td class="noborder"><i>An implementation claiming conformance to standard 
			UCA parametric tailoring shall do so in accordance with the specifications 
			Section 5, <a href="tr10-22.html#Tailoring">Tailoring</a>.</i>
			<p>An implementation 
			claiming such conformance does not have to support all of the parameter 
			attributes and values; however, those
			it claims to support must behave as specified.</p>
			</td>
		</tr>
	</table>
	
	<h2><a name="Data_Table_Format">3 Collation Element Table</a></h2>
	
	<p>A Collation Element Table contains a mapping from one (or more) characters 
	to one (or more) <i>collation elements</i>, where a collation element is an 
	ordered list of three or more 16-bit weights. (All code points not explicitly 
	mentioned in the mapping are given an implicit weight: see <i>
	Section 7, <a href="tr10-22.html#Weight_Derivation">Weight Derivation</a></i>).</p>
	<blockquote>
		<p><b>Note:</b> Implementations can produce the same result without using 
		16-bit weights. See <i>Section 6, <a href="tr10-22.html#Implementation_Notes">Implementation 
		Notes</a></i>.</p>
	</blockquote>
	
	<h3><a name="Notation">3.1 Weight Levels and Notation</a></h3>
	
	<p>The first weight is called the <i>Level 1</i> or <i>primary</i> weight; 
	the second is called the <i>Level 2</i> or <i>secondary</i> weight; the 
	third is called the <i>Level 3</i> or <i>tertiary</i> weight; the fourth 
	is called the <i>Level 4</i> or <i>quaternary</i> weight, and so on. For 
	a collation element X, these can be abbreviated as X<sub>1</sub>, X<sub>2</sub>, 
	X<sub>3</sub>, X<sub>4</sub>, and so on.</p>
	
	<p>Given two collation elements X and Y, this document uses the notation
	in <i>Table 7</i> and <i>Table 8</i>.</p>
	
	<p class="caption"><a name="Equals_Notation_Table"></a>Table 7. Equals Notation</p>

	<div align="center">
		<table cellpadding="2">
			<tr>
				<th>Notation</th>
				<th>Reading</th>
				<th>Meaning</th>
			</tr>
			<tr>
				<td>X =<sub>1</sub> Y</td>
				<td><i>X is primary equal to Y</i></td>
				<td>X<sub>1</sub> = Y<sub>1</sub></td>
			</tr>
			<tr>
				<td>X =<sub>2</sub> Y</td>
				<td><i>X is secondary equal to Y</i></td>
				<td>X<sub>2</sub> = Y<sub>2</sub> and X =<sub>1</sub> 
				Y</td>
			</tr>
			<tr>
				<td>X =<sub>3</sub> Y</td>
				<td><i>X is tertiary equal to Y</i></td>
				<td>X<sub>3</sub> = Y<sub>3</sub> and X =<sub>2</sub> 
				Y</td>
			</tr>
			<tr>
				<td>X =<sub>4</sub> Y</td>
				<td><i>X is quaternary equal to Y</i></td>
				<td>X<sub>4</sub> = Y<sub>4</sub> and X =<sub>3</sub> 
				Y</td>
			</tr>
		</table>
	</div>
	
	<p class="caption"><a name="Less_Than_Notation_Table"></a>Table 8. Less Than Notation</p>

	<div align="center">
		<table cellpadding="2">
			<tr>
				<th>Notation</th>
				<th>Reading</th>
				<th>Meaning</th>
			</tr>
			<tr>
				<td>X &lt;<sub>1</sub> Y</td>
				<td><i>X is primary less than Y</i></td>
				<td>X<sub>1</sub> &lt; Y<sub>1</sub></td>
			</tr>
			<tr>
				<td>X &lt;<sub>2</sub> Y</td>
				<td><i>X is secondary less than Y</i></td>
				<td>X &lt;<sub>1</sub> Y or (X =<sub>1</sub> Y and X<sub>2</sub> &lt; 
				Y<sub>2</sub>)</td>
			</tr>
			<tr>
				<td>X &lt;<sub>3</sub> Y</td>
				<td><i>X is tertiary less than Y</i></td>
				<td>X &lt;<sub>2</sub> Y or (X =<sub>2</sub> Y and X<sub>3</sub> &lt; 
				Y<sub>3</sub>)</td>
			</tr>
			<tr>
				<td>X &lt;<sub>4</sub> Y</td>
				<td><i>X is quaternary less than Y</i></td>
				<td>X &lt;<sub>3</sub> Y or (X =<sub>3</sub> Y and X<sub>4</sub> &lt; 
				Y<sub>4</sub>)</td>
			</tr>
		</table>
	</div>
	
	<p>Other operations are given their customary definitions in terms of the above. 
	That is:</p>
	<ul>
		<li>X ≤<sub>n</sub> Y if and only if X &lt;<sub>n</sub> 
		Y or X =<sub>n</sub> Y</li>
		<li>X &gt;<sub>n</sub> Y if and only if Y &lt;<sub>n</sub> X</li>
		<li>X ≥<sub>n</sub> Y if and only if Y
		≤<sub>n</sub> X</li>
	</ul>
	
	<p>This notation for collation elements is also adapted to
	refer to ordering between strings, as shown in <i>Table 9</i>, where
	A and B refer to two strings.</p>
	
	<p class="caption"><a name="String_Order_Notation_Table"></a>Table 9. Notation for String Ordering</p>

	<div align="center">
		<table cellpadding="2">
			<tr>
				<th>Notation</th>
				<th>Meaning</th>
			</tr>
			<tr>
				<td>A &lt;<sub>2</sub> B</td>
				<td>A is less than B, and there is a primary or secondary difference between them</td>
			</tr>
			<tr>
				<td>A &lt;<sub>2</sub> B and A=<sub>1</sub> B</td>
				<td>A is less than B, but there is <i>only</i> a secondary difference between them</td>
			</tr>
			<tr>
				<td>A &#x2261; B</td>
				<td>A and B are equivalent (equal at all levels) according to a given Collation Element Table</td>
			</tr>
			<tr>
				<td>A = B</td>
				<td>A and B are bit-for-bit identical</td>
			</tr>
		</table>
	</div>
	
	<p>Where only plain text ASCII characters are available 
	the fallback notation in <i>Table 10</i> can be used.</p>
	
	<p class="caption"><a name="Fallback_Notation_Table"></a>Table 10. Fallback Notation</p>
	
	<div align="center">
		<table cellpadding="2">
			<tr>
				<th>Notation</th>
				<th>Fallback</th>
			</tr>
			<tr>
				<td>X &lt;<sub>n</sub> Y</td>
				<td>X &lt;[n] Y</td>
			</tr>
			<tr>
				<td>X<sub>n</sub></td>
				<td>X[n]</td>
			</tr>
			<tr>
				<td>X &#x2264;<sub>n</sub> Y</td>
				<td>X &lt;=[n] Y</td>
			</tr>
			<tr>
				<td>A &#x2261; B</td>
				<td>A =[a] B</td>
			</tr>
		</table>
	</div>
							
	<p>If a weight is 0000, then that collation element is <i>ignorable</i> at that 
	level: the weight at that level is not taken into account in sorting. A <i>Level 
	N ignorable</i> is a collation element that is ignorable at level N but not at level 
	N+1. Thus:</p>
	<ul>
		<li>A <i>Level 1</i> or <i>primary ignorable</i> is a collation element 
		that is ignorable at Level 1, but not at Level 2.</li>
		<li>A <i>Level 2</i> or <i>secondary ignorable</i> is ignorable at 
		Levels 1 and 2, but not Level 3.</li>
		<li>A <i>Level 3</i> or <i>tertiary ignorable</i> is ignorable at Levels 
		1, 2, and 3 but not Level 4.</li>
	</ul>
	<p>In addition:</p>
	<ul>
		<li>A collation element that is not ignorable at any level is called a
		<i>non-ignorable</i>.</li>
		<li>A collation element with zeros at every level is called <i>completely 
		ignorable.</i></li>
	</ul>
	<p>For a given Collation Element Table, <i>MIN<sub>n</sub></i> is the least 
	weight in any collation element at level <i>n</i>, and <i>MAX<sub>n</sub></i> 
	is the maximum weight in any collation element at level <i>n</i>.</p>
	
	<h3><a name="Simple_Mappings">3.2 Simple Mappings</a></h3>
	
	<p>Most of the mappings in a collation element table are simple: they
	consist of the mapping of a single character to a single collation element.</p>
	
	<p>The following list shows several simple mappings that are used in the examples 
	illustrating the algorithm. Unless otherwise noted, all weights used
	in the collation elements are in hexadecimal format. The
	specific weight values shown are illustrative only; they may not match the weights
	in the latest Default Unicode Collation Element Table [<a href="tr10-22.html#Allkeys">Allkeys</a>].</p>
	
	<table class="wide">
		<tr>
			<th align="LEFT" width="15%">
			<p align="LEFT">Character</p>
			</th>
			<th align="LEFT" width="30%">
			<p align="LEFT">Collation Element</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Name</p>
			</th>
		</tr>
		<tr>
			<td><code>0300 &quot;`&quot;</code></td>
			<td><code>[0000.0021.0002]</code></td>
			<td><code>COMBINING GRAVE ACCENT</code></td>
		</tr>
		<tr>
			<td><code>0061 &quot;a&quot;</code></td>
			<td><code>[06D9.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER A</code></td>
		</tr>
		<tr>
			<td><code>0062 &quot;b&quot;</code></td>
			<td><code>[06EE.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER B</code></td>
		</tr>
		<tr>
			<td><code>0063 &quot;c&quot;</code></td>
			<td><code>[0706.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER C</code></td>
		</tr>
		<tr>
			<td><code>0043 &quot;C&quot;</code></td>
			<td><code>[0706.0020.0008]</code></td>
			<td><code>LATIN CAPITAL LETTER C</code></td>
		</tr>
		<tr>
			<td><code>0064 &quot;d&quot;</code></td>
			<td><code>[0712.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER D</code></td>
		</tr>
	</table>
	
	<h3>3.3 <a name="Multiple_Mappings">Multiple Mappings</a></h3>
	
	<p>The mapping from characters to collation elements may not always be a simple mapping 
	from one character to one collation element. In general, the mapping may be from one 
	to many, from many to one, or from many to many.</p>
	
	<h4>3.3.1 <a name="Expansions">Expansions</a></h4>
	
	<p>The Latin letter <i>æ</i> is treated as an independent letter by default. 
	Collations such as English, which may require treating it as equivalent to an
	<i>&lt;a e&gt;</i> sequence, can tailor the letter to map to a sequence of more than 
	one collation element, such as in the following example:</p>
	
	<table class="wide">
		<tr>
			<th align="LEFT" width="15%">
			<p align="LEFT">Character</p>
			</th>
			<th align="LEFT" width="30%">
			<p align="LEFT">Collation Element</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Name</p>
			</th>
		</tr>
		<tr>
			<td><code>00E6</code></td>
			<td><code>[06D9.0020.0002], [073A.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER AE; &quot;æ&quot;</code></td>
		</tr>
	</table>
	<p>In this example, the collation element <tt>[06D9.0020.0002]</tt> gives the 
	weight values for <i>a</i>, and the collation element <tt>[073A.0020.0002]</tt> 
	gives the weight values for <i>e</i>.</p>
	
	<h4>3.3.2 <a name="Contractions">Contractions</a></h4>
	
	<p>Similarly, where <i>ch</i> is treated as a single letter, as for instance in traditional 
	Spanish, it is represented as a mapping from two characters to a single collation 
	element, such as in the following example:</p>
	<table class="wide">
		<tr>
			<th align="LEFT" width="15%">
			<p align="LEFT">Character</p>
			</th>
			<th align="LEFT" width="30%">
			<p align="LEFT">Collation Element</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Name</p>
			</th>
		</tr>
		<tr>
			<td><code>0063<br>
			0068</code></td>
			<td><code>[0707.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER C,<br>
			LATIN SMALL LETTER H; &quot;ch&quot;</code></td>
		</tr>
	</table>
	<p>In this example, the collation element <tt>[0707.0020.0002]</tt> has a primary 
	value one greater than the primary value for the letter <i>c</i> by itself, 
	so that the sequence <i>ch</i> will collate after <i>c</i> and before <i>d</i>. 
	This example shows the result of a tailoring of collation elements to weight 
	sequences of letters as a single unit.</p>
	<p>Any character (such as <i>soft hyphen</i>) that is not completely ignorable 
	between two characters of a contraction will cause them to sort as separate 
	characters. Thus a soft hyphen can be used to separate and cause distinct weighting 
	of sequences such as Slovak <i>ch</i> or Danish <i>aa</i> that would normally 
	be weighted as units.</p>
	<p>Contractions that end with <i>non-starter</i> characters are known as <i>
	discontiguous contractions.</i> For example, suppose that there is a contraction 
	of <i>&lt;<b>a, combining ring above</b>&gt;</i>, as in Danish where this sorts as 
	after &quot;z&quot;. If the input text contains the sequence <i>&lt;<b>a</b>, combining dot 
	below, <b>combining ring above</b>&gt;</i>, then the contraction still needs to 
	be detected. This is required because the rearrangement of the combining marks 
	is canonically equivalent:</p>
	<p align="center"><i>&lt;<b>a</b>, combining dot below, <b>combining ring above</b>&gt;<br>
	≡<br>
	&lt;<b>a</b>, <b>combining ring above</b>, combining dot below&gt;.</i></p>
	<p>That is, discontiguous contractions must be detected in input text whenever 
	the final sequence of non-starter characters could be rearranged so as to make 
	a contiguous matching sequence that is canonically equivalent. In the formal 
	algorithm this is handled by rule Rule <a href="tr10-22.html#S2.1">S2.1</a>. For information 
	on non-starters, see [<a href="tr10-22.html#UAX15">UAX15</a>].</p>
	
	<h4>3.3.3 <a name="Many_To_Many">Many-to-Many Mappings</a></h4>
	
	<p>In some cases a sequence of two or more characters is mapped to a sequence
	of two or more collation elements. For example, this technique is used in the
	Default Unicode Collation Element Table [<a href="tr10-22.html#Allkeys">Allkeys</a>] to handle weighting of rearranged
	sequences of Thai or Lao left-side-vowel + consonant. See <i>Section 3.5, <a href="tr10-22.html#Rearrangement">Rearrangement</a></i>.</p>

	<p>Both many-to-many mappings and many-to-one mappings are referred to
	as <i>contractions</i> in the discussion of the Unicode Collation Algorithm, even though
	many-to-many mappings often do not actually shorten anything. The key issue for implementations
	is that for both many-to-one mappings and many-to-many mappings, the weighting algorithm
	must first identify a sequence of characters in the input string and "contract" them
	together as a unit for weight lookup in the table. The identified unit
	may then be mapped to any number of collation elements. Contractions pose particular
	issues for implementations, because all eligible contraction targets must be
	identified first, before the application of simple mappings, so that processing
	for simple mappings does not bleed away the context needed to correctly identify the contractions.</p>
		
	<h4>3.3.4 <a name="Other_Multiple_Mappings">Other Multiple Mappings</a></h4>
	
	<p>Certain characters may both expand and contract. See <i>
	Section 1.3, <a href="tr10-22.html#Contextual_Sensitivity">Contextual Sensitivity</a>.</i></p>
	
	<h3>3.4 <a name="French_Accents">French Accents</a></h3>
	
	<p>In some languages (notably French), accents are sorted from the back of the 
	string to the front of the string. This behavior is not marked in the Default 
	Unicode Collation Element Table, but may occur in tailored tables. In such a 
	case, the collation elements for the accents and their base characters are marked 
	as being <i>backwards</i> at Level 2.</p>
	
	<h3>3.5 <a name="Rearrangement">Rearrangement</a></h3>
	
	<p>Certain characters, such as the Thai vowels 
	เ through ไ 
	(and related vowels in the Lao and Tai Viet scripts of
	Southeast Asia), are not represented in strings in logical order.
	The exact list of such characters is given by the Logical_Order_Exception 
	property in the Unicode Character Database [<a href="tr10-22.html#UAX44">UAX44</a>]. For collation, 
	they are rearranged by swapping them with the following character before further 
	processing, because logically they belong afterward. This is done by providing 
	these sequences as many-to-many mappings in the Collation Element Table.</p>
	
	<h3>3.6 <a name="Default_Unicode_Collation_Element_Table">Default Unicode Collation 
	Element Table</a></h3>
	
	<p>The Default Unicode Collation Element Table is provided in [<a href="tr10-22.html#Allkeys">Allkeys</a>]. 
	This table provides a mapping from characters to collation elements for all 
	the explicitly weighted characters. The mapping lists characters in the order 
	that they are weighted. Any code points that are not explicitly mentioned 
	in this table are given a derived collation element, as described in <i>
	Section 7, <a href="tr10-22.html#Weight_Derivation">Weight Derivation</a></i>. There are 
	three types of mappings:</p>
	<ul>
		<li><b>Simple.</b> One Unicode character maps to one collation element.</li>
		<li><b>Expansions.</b> One Unicode character maps to a sequence of collation 
		elements.</li>
		<li><b>Contractions.</b> A sequence of Unicode characters maps to a sequence 
		of (one or more) collation elements.</li>
	</ul>
	<p>The Default Unicode Collation Element Table does not aim to provide precisely 
	correct ordering for each language and script; tailoring is required for correct 
	language handling in almost all cases. The goal is instead to have all the
	<i>other</i> characters, those that are not tailored, show up in a reasonable 
	order. This is particularly true for contractions, because contractions 
	can result in larger tables and significant performance degradation. 
	Contractions are required in tailorings, but their use is kept to
	a minimum in the Default Unicode Collation Element Table to enhance performance.</p>
	
	<p>In the Default Unicode Collation Element Table, contractions are necessary where 
	a canonical decomposable character requires a distinct 
	primary weight in the table, so that the canonical-equivalent character sequences 
	are given the same weights. For example, Indic two-part vowels have primary 
	weights as units, and their canonical-equivalent sequence of vowel parts must 
	be given the same primary weight by means of a contraction entry in the table. 
	The same applies to a number of precomposed Cyrillic characters with diacritic 
	marks and to a small number of Arabic letters with <i>madda</i> or <i>hamza</i> 
	marks.</p>
	
	<p>Contractions are also entered in the table for Thai, Lao, and Tai Viet logical order 
	exception vowels. Because these scripts all have five vowels that are represented 
	in strings in visual order, the vowels cannot simply be 
	weighted by their representation order in strings. One option is to preprocess
	Thai, Lao, and Tai Viet strings to identify and reorder all logical order 
	exception vowels around the following consonant. That approach was used in Version 
	4.0 and earlier of the UCA. Starting with Version 4.1 of the UCA, contractions 
	for the relevant combinations of Thai and Lao vowel+consonant have been entered 
	in the Default Unicode Collation Element Table instead.</p>
	
	<p>Those are the only classes of contractions allowed in the Default Unicode 
	Collation Element Table. Generic contractions of the sort needed 
	to handle digraphs such as &quot;ch&quot; in Spanish or Czech sorting, should be dealt 
	with in tailorings to the default table&#x2014;because they often 
	vary in ordering from language to language, and because every contraction 
	entered into the default table has a significant implementation cost for all 
	applications of the default table, even those which may not be particularly 
	concerned with the affected script. See the Unicode
	Common Locale Data Repository [<a href="tr10-22.html#CLDR">CLDR</a>]
	for extensive tailorings of the DUCET for various languages, including those 
	requiring contractions.</p>
	
	<p>The Default Unicode Collation Element Table is constructed to be consistent with 
	the Unicode Normalization algorithm, and to respect the Unicode character properties. It is not, however, 
	merely algorithmically derivable based on considerations of canonical equivalence and an
	inspection of character properties, because the assignment of 
	levels also takes into account characteristics of particular scripts. For example, 
	the combining marks are generally Level 1 ignorables; however, the Indic combining 
	vowels are given non-zero Level 1 weights, because they are as significant in 
	sorting as the consonants.</p>
	
	<p>Any character may have variant forms or applied accents which affect collation. 
	Thus, for <tt>FULL STOP</tt> there are three compatibility variants: a fullwidth 
	form, a compatibility form, and a small form. These get different tertiary weights, 
	accordingly. For more information on how the table was constructed, see
	<i>Section 7.2, <a href="tr10-22.html#Tertiary_Weight_Table">Tertiary Weight Table</a></i>.</p>
	
	<p><i>Table 11</i> summarizes the overall ordering of the collation elements in the Default 
	Unicode Collation Element Table.
	The collation elements are ordered by primary, secondary, tertiary, and Unicode value weights, with
	primary, secondary, and tertiary weights for variables blanked (replaced by "0000"). 
	Entries in the table which contain a sequence of collation elements have a multi-level ordering
	applied: comparing the primary weights first, then the secondary weights, and so on. This
	construction of the table makes it easy to see the order in which characters would be
	collated.</p>
	
	<p class="caption"><a name="DUCET_Order_Table"></a>Table 11. DUCET Ordering</p>
	
	<div align="center">
	<table cellpadding="2">
		<tr>
			<th align="center">Values</th>
			<th align="center">Type</th>
			<th align="center">Examples of Characters</th>
		</tr>
		<tr>
			<td>X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub> = 0</td>
			<td>tertiary ignorables</td>
			<td>- Control Codes<br>
			- Format Characters<br>
			- Hebrew Points<br>
			- Tibetan Signs<br>
			...</td>
		</tr>
		<tr>
			<td>X<sub>1</sub>, X<sub>2</sub> = 0;<br>
			X<sub>3</sub> ≠ 0</td>
			<td>secondary ignorables</td>
			<td><i>None in DUCET; could be in tailorings</i></td>
		</tr>
		<tr>
			<td>X<sub>1</sub> = 0;<br>
			X<sub>2</sub>, X<sub>3</sub> ≠ 0</td>
			<td>primary ignorable</td>
			<td>- Most nonspacing marks</td>
		</tr>
		<tr>
			<td rowspan="4">X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub> ≠ 0</td>
			<td><a href="tr10-22.html#Variable_Weighting">variable</a></td>
			<td>- Whitespace<br>
			- Punctuation<br>
			- Symbols</td>
		</tr>
		<tr>
			<td>regular</td>
			<td>- Small number of extender symbols (for example, U+02D0 (ː)
			MODIFIER LETTER TRIANGULAR COLON)<br>
			- Numbers<br>
			- Latin<br>
			- Greek<br>
			...</td>
		</tr>
		<tr>
			<td><a href="tr10-22.html#Implicit_Weights">implicit</a></td>
			<td>- CJK Unified Ideographs from the URO and CJK Compatibility blocks<br>
			- CJK Extensions A, B, C, ...<br>
			- Unassigned and others given implicit weights</td>
		</tr>
		<tr>
			<td><a href="tr10-22.html#Trailing_Weights">trailing</a></td>
			<td><i>None in DUCET; could be in tailorings</i></td>
		</tr>
	</table>
	</div>
	
	<p>For most languages, some degree of tailoring is required to match user expectations. 
	For more information, see <i>Section 5, <a href="tr10-22.html#Tailoring">Tailoring</a></i>.</p>
	
	<h4>3.6.1 <a name="File_Format">File Format</a></h4>
	
	<p>Each of the files consists of a version line followed by an optional variable-weight 
	line, optional backwards lines, and a series of entries, all separated by newlines. 
	A &#39;#&#39; or &#39;%&#39; and any following characters on a line are comments. Whitespace 
	between literals is ignored. The following is an extended BNF description of 
	the format, where &quot;<i>x</i>+&quot; indicates one or more <i>x</i>&#39;s, &quot;<i>x</i>*&quot; 
	indicates zero or more <i>x</i>&#39;s, &quot;<i>x?</i>&quot; indicates zero or one <i>x</i>, 
	and &lt;char&gt; is a hexadecimal Unicode code value.</p>
	<pre>&lt;collationElementTable&gt; := &lt;version&gt; 
                           &lt;variable&gt;?
                           &lt;backwards&gt;*
                           &lt;entry&gt;+</pre>
	<p>The version line is of the form:</p>
	<pre>@&lt;version&gt; := &lt;major&gt;.&lt;minor&gt;.&lt;variant&gt; &lt;eol&gt;</pre>
	<p>The variable-weight line has three possible values that may change the weights 
	of collation elements in processing (see <i>
	Section 3.6.2, <a href="tr10-22.html#Variable_Weighting">Variable Weighting</a></i>). 
  The default is <code>shifted</code>.</p>
	<pre>&lt;variable&gt;       := &#39;@variable &#39; &lt;variableChoice&gt; &lt;eol&gt;
&lt;variableChoice&gt; := &#39;blanked&#39; | &#39;non-ignorable&#39; | &#39;shifted&#39;<span style="background-color:#FFFF00"></span></pre>
	<p>A backwards line lists a level that is to be processed in reverse order. 
  A forwards line does the reverse. The default is for lines to be forwards.</p>
	<pre>&lt;backwards&gt; := (&#39;@backwards &#39; | &#39;@forwards &#39;) &lt;levelNumber&gt; &lt;eol&gt;</pre>
	<p>Each entry is a mapping from character(s) to collation element(s), and is 
	of the following form:</p>
	<pre>&lt;entry&gt;       := &lt;charList&gt; &#39;;&#39; &lt;collElement&gt;+ &lt;eol&gt;
&lt;collElement&gt; := &quot;[&quot; &lt;alt&gt; &lt;char&gt; &quot;.&quot; &lt;char&gt; &quot;.&quot; &lt;char&gt; (&quot;.&quot; &lt;char&gt;)* &quot;]&quot;
&lt;alt&gt;         := &quot;*&quot; | &quot;.&quot;</pre>
	<p>In the Default Unicode Collation Element Table, the comment may contain informative 
	tags.</p>
	<p>Here are some selected entries taken from a particular version of the data 
	file. (It may not match the actual values in the current data file.)</p>
	<pre>0020 ; [*0209.0020.0002.0020] % SPACE
02DA ; [*0209.002B.0002.02DA] % RING ABOVE; COMPATSEQ
0041 ; [.06D9.0020.0008.0041] % LATIN CAPITAL LETTER A
3373 ; [.06D9.0020.0017.0041] [.08C0.0020.0017.0055] % SQUARE AU; COMPATSEQ
00C5 ; [.06D9.002B.0008.00C5] % LATIN CAPITAL LETTER A WITH RING ABOVE; CANONSEQ
212B ; [.06D9.002B.0008.212B] % ANGSTROM SIGN; CANONSEQ
0042 ; [.06EE.0020.0008.0042] % LATIN CAPITAL LETTER B
0043 ; [.0706.0020.0008.0043] % LATIN CAPITAL LETTER C
0106 ; [.0706.0022.0008.0106] % LATIN CAPITAL LETTER C WITH ACUTE; CANONSEQ
0044 ; [.0712.0020.0008.0044] % LATIN CAPITAL LETTER D</pre>

	<p>Although this document describes collation elements as three 
	levels, the file contains a fourth level (as in <tt>[.0712.0020.0008.<b>0044</b>]</tt>),
	which is computable. In most cases the fourth level is
	equal to the code point itself. For composite characters which have
	have collation weights using a sequence of collation elements, the fourth level 
	for each collation element is based on the decomposition
	of the character. For completely ignorable collation elements, the fourth level
	is set to zero. For more information on the use
	of the fourth level and stable sorts, see <i>Section 
	3.8, <a href="tr10-22.html#Stability">Stability</a></i>.</p>
	<p>Implementations can also add more customizable levels, as discussed 
	in <i>Section 2, <a href="tr10-22.html#Conformance">Conformance</a></i>. 
	For example, an implementation might want to handle the standard 
	Unicode Collation, but also be capable of emulating 
	an EBCDIC multi-level ordering (having a fourth-level EBCDIC binary order).
	</p>
	
	<h4>3.6.2 <a name="Variable_Weighting">Variable Weighting</a></h4>
	
	<p>Collation elements that are marked with an asterisk in a Unicode Collation 
	Element Table are known as <i>variable collation elements.</i></p>
	<table class="wide">
		<tr>
			<th align="LEFT" width="15%">
			<p align="LEFT">Character</p>
			</th>
			<th align="LEFT" width="30%">
			<p align="LEFT">Collation Element</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Name</p>
			</th>
		</tr>
		<tr>
			<td><tt>0020 &quot; &quot;</tt></td>
			<td><tt>[*0209.0020.0002]</tt></td>
			<td>SPACE</td>
		</tr>
	</table>
	<p>Based on the setting of the variable weighting tag, collation elements can 
	be either treated as ignorables or not. When they are treated as ignorables, 
	any sequence of ignorable characters that immediately follows the variable 
	collation element is also affected.</p>
	<p>There are four possible options for variable weighted characters:</p>
	<ul>
		<li><b>Blanked:</b> Variable collation elements and any subsequent ignorables 
		are reset so that their weights at levels one through three are zero. For 
		example,
		<ul>
			<li><i>SPACE</i> would have the value <tt>[.0000.0000.0000]</tt>
			</li>
			<li>A combining grave accent after a space would have the value <tt>
			[.0000.0000.0000]</tt></li>
			<li><i>Capital A</i> would be unchanged, with the value <tt>[.06D9.0020.0008]</tt>
			</li>
			<li>A combining grave accent after a <i>Capital A </i>would be unchanged</li>
		</ul>
		</li>
		<li><b>Non-ignorable: </b>Variable collation elements are not reset to be ignorable, 
		but get the weights explicitly mentioned in the file.
		<ul>
			<li><i>SPACE </i>would have the value <tt>[.0209.0020.0002]</tt>
			</li>
			<li><i>Capital A</i> would be unchanged, with the value <tt>[.06D9.0020.0008]</tt>
			</li>
			<li>Ignorables are unchanged.</li>
		</ul>
		</li>
		<li><b>Shifted:</b> Variable collation elements are reset 
		to zero at 
		levels one through three. In addition, a new fourth-level weight is appended, 
		whose value depends on the type, as shown in <i>Table 12</i>.<br>
		
		<p class="caption"><a name="L4_For_Shifted_Table"></a>Table 12. L4 Weights for Shifted Variables</p>

		<div align="center">
			<table>
				<tr>
					<th>Type</th>
					<th>L4</th>
					<th>Examples</th>
				</tr>
				<tr>
					<td>Tertiary Ignorable</td>
					<td>0000</td>
					<td>NULL<br>
					<tt>[.0000.0000.0000.0000]</tt></td>
				</tr>
				<tr>
					<td>Primary or Secondary Ignorable,<br>
					following a Variable</td>
					<td>0000</td>
					<td>COMBINING GRAVE<br>
					<tt>[.0000.0000.0000.0000]</tt></td>
				</tr>
				<tr>
					<td>Variable</td>
					<td>old L1</td>
					<td>SPACE<br>
					<tt>[.0000.0000.0000.0209]</tt></td>
				</tr>
				<tr>
					<td>None of the above</td>
					<td>FFFF</td>
					<td><i>Capital A</i><br>
					<tt>[.06D9.0020.0008.FFFF]</tt></td>
				</tr>
			</table>
		</div>
		
		<p>Any subsequent primary or secondary ignorables following a variable are reset so that their weights at levels one 
		through four are zero.</p>
		<ul>
			<li>A combining grave accent after a space would have the value <tt>
			[.0000.0000.0000.0000]</tt>.</li>
			<li>A combining grave accent after a <i>Capital A </i>would be unchanged.</li>
		</ul>
		<p>The <i>shifted</i> option provides for improved orderings when the variable 
		collation elements are ignorable, while still only requiring three fields 
		to be stored in memory for each collation element. It results in somewhat 
		longer sort keys, although they can be compressed (see <i>
		Section 6.1, <a href="tr10-22.html#Reducing_Sort_Key_Lengths">Reducing Sort Key Lengths</a></i> 
		and <i>Section 6.3, <a href="tr10-22.html#Reducing_Table_Sizes">Reducing Table Sizes)</a></i>.</p>
		</li>
		<li><b>Shift-Trimmed:</b> This option is the same as <b>Shifted</b>, except that all trailing 
		FFFFs are trimmed from the sort key. This could be used to emulate 
		POSIX behavior.</li>
	</ul>
	<p><i>Table 13</i> shows the differences between orderings 
	using the different options for variable collation elements. In this example, 
	sample strings differ by the third character: a letter, <i>space,</i> &#39;-&#39; <i>
	hyphen-minus (002D)</i>, or &#39;-&#39; <i>hyphen (2010);</i> followed by an uppercase/lowercase 
	distinction. In the first column, the words with <i>hyphen-minus</i> or
	<i>hyphen</i> are separated by "deluge", because the letter "l" comes between 
	them in Unicode code order. In the second column, they are grouped together 
	but before all letters in the third position. This is because they are no longer 
	ignorable, and have primary values that differ from the letters. In the third 
	column, the <i>hyphen-minus</i> and <i>hyphen</i> are grouped together, and 
	their differences are less significant than 
	the casing differences in the letter "l". This grouping
	results from the fact that they are ignorable, but their fourth level differences are according 
	to the original primary order, which is more intuitive than Unicode order.</p>
	
	<p class="caption"><a name="Comparison_Variable_Table"></a>Table 13. Comparison of Variable Ordering</p>

	<div align="center">
		<table>
			<tr>
				<th style="text-align: center" width="25%">
				<p>Blanked</p>
				</th>
				<th style="text-align: center" width="25%">
				<p>Non-<br>
				ignorable</p>
				</th>
				<th style="text-align: center" width="25%">
				<p>Shifted</p>
				</th>
				<th style="text-align: center" width="25%">
				<p>Shift-<br>
				Trimmed</p>
				</th>
			</tr>
			<tr>
				<td>
				<p>death<br>
				<font color="#0000FF">de luge<br>
				de-luge</font><br>
				deluge<br>
				<font color="#0000FF">de-luge<br>
				de Luge<br>
				de-Luge</font><br>
				deLuge<br>
				<font color="#0000FF">de-Luge</font><br>
				demark</p>
				</td>
				<td>
				<p><font color="#0000FF">de luge<br>
				de Luge<br>
				de-luge<br>
				de-Luge<br>
				de-luge<br>
				de-Luge</font><br>
				death<br>
				deluge<br>
				deLuge<br>
				demark</p>
				</td>
				<td>
				<p>death<br>
				<font color="#0000FF">de luge<br>
				de-luge<br>
				de-luge</font><br>
				deluge<br>
				<font color="#0000FF">de Luge<br>
				de-Luge<br>
				de-Luge<br>
				deLuge</font><br>
				demark</p>
				</td>
				<td>
				<p>death<br>
				deluge<br>
				<font color="#0000FF">de luge<br>
				de-luge<br>
				de-luge</font><br>
				deLuge<br>
				<font color="#0000FF">de Luge<br>
				de-Luge<br>
				de-Luge</font><br>
				demark</p>
				</td>
			</tr>
		</table>
	</div>
	
	<p><a name="Interleaving"></a>Primaries for variable collation elements are not <i>interleaved</i> with 
	other primary weights. This allows for more compact storage of memory tables. 
	Rather than using a bit per collation element to determine whether the collation 
	element is variable, the implementation only needs to store the maximum primary 
	value for all the variable elements. All collation elements with primary weights 
	from 1 to that maximum are variables; all other collation elements are not.</p>
	
	<h4>3.6.3 <a name="Default_Values">Default Values</a></h4>
	
	<p>In the Default Unicode Collation Element Table and in typical tailorings, 
	most unaccented letters differ in the primary weights, but have secondary weights 
	(such as <i>a<sub>1</sub></i>) equal to <i>MIN<sub>2</sub></i>. The primary 
	ignorables will have secondary weights greater than <i>MIN<sub>2</sub></i>. 
	Characters that are compatibility or case variants will have equal primary and 
	secondary weights (for example, <i>a<sub>1</sub> = A<sub>1</sub></i> and <i>
	a<sub>2</sub> = A<sub>2</sub></i>), but have different tertiary weights (for 
	example, <i>a<sub>3</sub> &lt; A<sub>3</sub></i>). The unmarked characters will 
	have tertiary weights (such as <i>a<sub>3</sub></i>) equal to <i>MIN<sub>3</sub>.</i></p>
	
	<p>This use of secondary and tertiary weights does not guarantee 
	that the meaning of a secondary or tertiary weight is uniform across tables. 
	For example, a <i>capital A</i> and <i>katakana ta</i> could both have a tertiary 
	weight of 3.</p>
	
	<h3>3.7 <a name="Well-Formed">Well-Formed Collation Element Tables</a></h3>
	
	<p><a name="well-formed_definition"></a>A well-formed Collation Element Table 
	meets the following conditions:</p>
	<blockquote>
		<ol>
			<li>Except in special cases detailed in <i>
			Section 6.2, <a href="tr10-22.html#Large_Weight_Values">Large Weight Values</a></i>, 
			no collation element can have a zero weight at Level N and a non-zero 
			weight at Level N-1.
			<p>For example, the secondary can only be ignorable if the primary is 
			ignorable. See Step 4 of the main algorithm for an explanation.</p>
			</li>
			<li>All Level N weights in Level N-1 ignorables must be strictly less 
			than all weights in Level N-2 ignorables.
			<p>For example, secondaries in non-ignorables must be strictly less 
			than those in primary ignorables: 
				Given collation elements [C, D, E] and [0, A, B], where C ≠ 
				0 and A ≠ 0,
				D <i>must be</i> less than A.</p>
			</li>
			<li>No variable collation element has an ignorable primary.</li>
			<li>For all variable collation elements U, V, if there is a collation 
			element W such that U<sub>1</sub> ≤ W<sub>1</sub> 
			and W<sub>1</sub> ≤ V<sub>1</sub>, then W is also 
			variable.
			<p>This provision prevents <a href="tr10-22.html#Interleaving">interleaving</a>.</p>
			</li>
		</ol>
	</blockquote>
	
	<h3>3.8 <a name="Stability">Stability</a></h3>
	
	<p>The notion of <i>stability</i> in sorting often causes confusion when discussing 
	collation.</p>
	
	<p>A <i>stable sort</i> is one where two records with a field that compares as 
	equal will retain their order if sorted according to that field. This is a property 
	of the sorting algorithm, <i>not</i> of the comparison mechanism. For example, 
	a bubble sort is stable, while a quick sort is not. This is a useful property, 
	but cannot be accomplished by modifications to the comparison mechanism or tailorings.</p>
	
	<p>A <i>semi-stable collation</i> is different. It is a collation where strings 
	that are not canonical equivalents will not be judged to be equal. This is a 
	property of the comparison, not of the sorting algorithm. This is 
	not a particularly useful property&#x2014;its implementation also requires 
	extra processing in string comparison or an extra level in sort keys, and thus 
	may degrade performance to little purpose. However, if a semi-stable collation 
	is required, the specified mechanism is to append the NFD form of the original 
	string after the sort key, in <i>Section 4.3, <a href="tr10-22.html#Step_3">Form Sort Key</a></i>. 
	See also <i>Appendix A, <a href="tr10-22.html#Deterministic_Sorting">Deterministic Sorting</a></i>.</p>
	
	<p>The fourth-level weights in the Default Collation Element Table can be used 
	to provide an approximation of a semi-stable collation.</p>
	
	<p>Neither of the above refers to the stability of the Default Collation 
	Element Table itself. The contents of that table will remain unchanged in any particular
	version of the UCA. However, the contents may change between 
	successive versions of the UCA as new characters are added, or more information
	is obtained about existing characters.</p>
	
	<p>Implementers should be aware that using different versions of the UCA 
	or different versions of the Unicode Standard could result in different 
	collation results of their data. There are numerous ways collation data could 
	vary across versions, for example:</p>
	<ol>
		<li>Code points that were unassigned in a previous version of the Unicode 
		Standard are now assigned in the current version, and will have 
		a sorting semantic appropriate to the repertoire to which they belong. For 
		example, the code points U+103D0..U+103DF were undefined in Unicode 3.1. 
		Because they were assigned characters in Unicode 3.2, their sorting semantics 
		and respective sorting weights changed as of that version.</li>
		<li>Certain semantics of the Unicode standard could change between versions, 
		such that code points are treated in a manner different than previous versions 
		of the standard.</li>
		<li>More information is gathered about a particular script, and  
		the weight of a code point may need to be
		adjusted to provide a more linguistically accurate sort.</li>
	</ol>
	<p>Any of these reasons could necessitate a change between versions with regards 
	to collation weights for code points. It is therefore important that the implementers 
	specify the version of the UCA, as well as the version of the Unicode Standard 
	under which their data is sorted.</p>
	
	<h2><a name="Main_Algorithm"></a>4 Main Algorithm</h2>
	
	<p>The main algorithm has four steps. First is to normalize each input string, 
	second is to produce an array of collation elements for each string, and third 
	is to produce a sort key for each string from the collation elements. Two sort 
	keys can then be compared with a binary comparison; the result is the ordering 
	for the original strings.</p>
	<h3><a name="Step_1"></a>4.1 Normalize</h3>
	<p><b>Step 1. </b>Produce a normalized form of each input string, applying
	S1.1.</p>
	<p><b><a name="S1.1">S1.1</a> </b>Use the Unicode canonical algorithm to decompose 
	characters according to the canonical mappings. That is, put the string into 
	Normalization Form D (see [<a href="tr10-22.html#UAX15">UAX15</a>]).</p>
	<ul>
		<li>Conformant implementations may skip this step <i>in certain circumstances:
		</i>see <i>Section 6.5, <a href="tr10-22.html#Avoiding_Normalization">Avoiding Normalization</a></i> 
		for more information.</li>
	</ul>
	
	<h3><a name="Step_2"></a>4.2 Produce Array</h3>
	
	<p><b>Step 2. </b>The collation element array is built by sequencing through 
	the normalized form , applying S2.1 through S2.6</p>
	
	<p class="caption"><a name="String_To_Array_Table"></a>Figure 1. String to Collation Element Array</p>
	
	<div class="center">
	<table>
		<tr>
			<th>Normalized String</th>
			<th>Collation Element Array</th>
		</tr>
		<tr>
			<td>ca´b</td>
			<td><tt>[0706.0020.0002], [06D9.0020.0002], [0000.0021.0002], [06EE.0020.0002]</tt></td>
		</tr>
	</table>
	</div>
		
	<p><b><a name="S2.1">S2.1</a> </b>Find the longest initial substring S at each 
	point that has a match in the table. </p>
	<blockquote>
		<p><b><a name="S2.1.1">S2.1.1</a> </b>If there are any non-starters following 
		S, process each non-starter C.</p>
		<p><b><a name="S2.1.2">S2.1.2</a> </b>If C is not blocked from S, find if 
		S + C has a match in the table.</p>
	<blockquote>
		<p><b>Note:</b> A non-starter in a string is called <i>blocked</i> if there 
		is another non-starter of the same canonical combining class or zero between 
		it and the last character of canonical combining class 0.</p>
	</blockquote>
		<p><b><a name="S2.1.3">S2.1.3</a> </b>If there is a match, replace S by 
		S + C, and remove C.</p>
	</blockquote>
	<p><b><a name="S2.2">S2.2</a></b> Fetch the corresponding collation element(s) 
	from the table if there is a match. If there is no match, synthesize a weight 
	as described in <i>Section 7.1, <a href="tr10-22.html#Derived_Collation_Elements">Derived 
	Collation Elements</a></i>.</p>
	<p><b><a name="S2.3">S2.3</a> </b>Process collation elements according to the 
	variable-weight setting, as described in <i>
	Section 3.6.2, <a href="tr10-22.html#Variable_Weighting">Variable Weighting</a></i>.</p>
	<p><b><a name="S2.4">S2.4</a></b> Append the collation element(s) to the collation 
	element array.</p>
	<p><b><a name="S2.5">S2.5</a> </b>Proceed to the next point in the string (past 
	S).</p>
	<p><b><a name="S2.6">S2.6</a> </b>Loop until the end of the string is reached.</p>
	<blockquote>
		<p><b>Note:</b> The extra non-starter C  
		needs to be considered in Step 2.1.1 because otherwise irrelevant characters 
		could interfere with matches in the table. 
		For example, suppose that the contraction <i>&lt;a, combining_ring&gt;</i> (=
		<i>å</i>) is ordered after <i>z</i>. If a string consists of the three characters
		<i>&lt;a, combining_ring, combining_cedilla&gt;</i>, then the normalized form 
		is <i>&lt;a, combining_cedilla, combining_ring&gt;</i>, which separates the <i>
		a</i> from the <i>combining_ring</i>. Without considering 
		the extra non-starter, this string would compare incorrectly as after <i>
		a</i> and not after <i>z</i>.</p>
		<p>If the desired ordering treats <i>&lt;a, combining_cedilla&gt;</i> as a contraction 
		which should take precedence over <i>&lt;a, combining_ring&gt;,</i> then an additional 
		mapping for the combination <i>&lt;a, combining_ring, combining_cedilla&gt;</i> 
		can be introduced to produce this effect.</p>
		<p>For conformance to Unicode canonical equivalence, only unblocked non-starters are matched in
		Step 2.1.2. For example, <i>&lt;a, 
		combining_macron, combining_ring&gt;</i> would compare as after <i>a-macron</i>, 
		and not after <i>z</i>. Additional mappings can 
		be added to customize behavior.</p>
	</blockquote>
			
	<h3><a name="Step_3"></a>4.3 Form Sort Key</h3>
	
	<p><b>Step 3.</b> The sort key is formed by successively appending all non-zero weights from 
	the collation element array. The weights are appended from each level in turn, 
	from 1 to 3. (Backwards weights are inserted in reverse order.)</p>
	
	<p class="caption"><a name="Array_To_Sort_Key_Table"></a>Figure 2. Collation Element Array to Sort Key</p>
	
	<div class="center">
	<table>
		<tr>
			<th>Collation Element Array</th>
			<th>Sort Key</th>
		</tr>
		<tr>
			<td><tt>[0706.0020.0002], [06D9.0020.0002], [0000.0021.0002], [06EE.0020.0002]</tt></td>
			<td><tt>0706 06D9 06EE 0000 0020 0020 0021 0020 0000 0002 0002 0002 0002</tt></td>
		</tr>
	</table>
	</div>
	
	<p>An implementation may allow the maximum level to be set to a smaller 
	level than the available levels in the collation element array. For example, 
	if the maximum level is set to 2, then level 3 and higher weights are not appended 
	to the sort key. Thus any differences at levels 3 and higher will be ignored, 
	leveling any such differences in string comparison.</p>
	<p>Here is a more detailed statement of the algorithm:</p>
	<p><b><a name="S3.1">S3.1</a> </b>For each weight level L in the collation element 
	array from 1 to the maximum level, </p>
	<blockquote>
		<p><b><a name="S3.2">S3.2</a> </b>If L is not 1, append a <i>level separator</i></p>
	<blockquote>
		<p><b>Note:</b>The level separator is zero (0000), which is guaranteed to be 
		lower than any weight in the resulting sort key. This guarantees that when 
		two strings of unequal length are compared, where the shorter string is 
		a prefix of the longer string, the longer string is always sorted after 
		the shorter&#x2014;in the absence of special features like contractions. For 
		example: &quot;abc&quot; &lt; &quot;abcX&quot; where &quot;X&quot; can be any character(s).</p>
	</blockquote>
		<p><b><a name="S3.3">S3.3</a> </b>If the collation element table is forwards 
		at level L,</p>
		<blockquote>
			<p><b><a name="S3.4">S3.4</a> </b>For each collation element CE in the 
			array</p>
			<blockquote>
				<p><b><a name="S3.5">S3.5</a> </b>Append CE<sub>L</sub> to the sort 
				key if CE<sub>L</sub> is non-zero.</p>
			</blockquote>
		</blockquote>
		<p><b><a name="S3.6">S3.6</a> </b>Else the collation table is backwards 
		at level L, so</p>
		<blockquote>
			<p><b><a name="S3.7">S3.7</a> </b>Form a list of all the non-zero CE<sub>L</sub> 
			values.</p>
			<p><b><a name="S3.8">S3.8</a> </b>Reverse that list</p>
			<p><b><a name="S3.9">S3.9</a> </b>Append the CE<sub>L</sub> values from 
			that list to the sort key.</p>
		</blockquote>
	</blockquote>

	<p><b><a name="S3.10">S3.10</a></b> If a semi-stable sort is required, then 
	after all the level weights have been added, append a copy of the NFD version 
	of the original string. This strength level is called &quot;identical&quot;. (See also
	<i>Appendix A, <a href="tr10-22.html#Deterministic_Sorting">Deterministic Sorting</a></i>.)</p>
				
	<h3><a name="Step_4"></a>4.4 Compare</h3>
	
	<p><b>Step 4. </b>Compare the sort keys for each of the input strings, using 
	a binary comparison. This means that:</p>
	<ul>
		<li>Level 3 differences are ignored if there are any Level 1 or 2 differences.</li>
		<li>Level 2 differences are ignored if there are any Level 1 differences.</li>
		<li>Level 1 differences are never ignored.</li>
	</ul>
	
	<p class="caption"><a name="Comparison_Of_Sort_Keys_Table"></a>Figure 3. Comparison of Sort Keys</p>
	
	<div align="center">
		<table>
			<tr>
				<th>&nbsp;</th>
				<th>String</th>
				<th>Sort Key</th>
			</tr>
			<tr>
				<td>1</td>
				<td>cab</td>
				<td><tt><u><b><font color="#ff9c05">0706</font></b></u> 06D9 06EE 
				0000 0020 0020 <u><b><font color="#00ba00">0020</font></b></u> 0000
				<u><b><font color="#0099ff">0002</font></b></u> 0002 0002</tt></td>
			</tr>
			<tr>
				<td>2</td>
				<td>Cab</td>
				<td><tt><u><b><font color="#ff9c05">0706</font></b></u> 06D9 06EE 
				0000 0020 0020 <u><b><font color="#00ba00">0020</font></b></u> 0000
				<u><b><font color="#0099ff">0008</font></b></u> 0002 0002</tt></td>
			</tr>
			<tr>
				<td>3</td>
				<td>cáb</td>
				<td><tt><u><b><font color="#ff9c05">0706</font></b></u> 06D9 06EE 
				0000 0020 0020 <u><b><font color="#00ba00">0021</font></b></u> 0020 
				0000 0002 0002 0002 0002</tt></td>
			</tr>
			<tr>
				<td>4</td>
				<td>dab</td>
				<td><tt><u><b><font color="#ff9c05">0712</font></b></u> 06D9 06EE 
				0000 0020 0020 0020 0000 0002 0002 0002</tt></td>
			</tr>
		</table>
	</div>
		
	<p>In <i>Figure 3</i>, &quot;cab&quot; &lt;<sub>3</sub> &quot;Cab&quot; &lt;<sub>2</sub> &quot;cáb&quot; &lt;<sub>1</sub> 
	&quot;dab&quot;. The differences that produce the ordering are shown by the <u><b>bold 
	underlined</b></u> items:</p>
	<ul>
		<li>For strings 1 and 2, the first difference is in <b><tt>
		<font color="#0099ff">0002</font></tt></b> versus <b><tt>
		<font color="#0099ff">0008</font></tt></b> (Level 3).</li>
		<li>For strings 2 and 3, the first difference is in <b><tt>
		<font color="#00ba00">0020</font></tt></b> versus <b><tt>
		<font color="#00ba00">0021</font></tt></b> (Level 2).</li>
		<li>For strings 3 and 4, the first difference is in <b><tt>
		<font color="#ff9c05">0706</font></tt></b> versus <b><tt>
		<font color="#ff9c05">0712</font></tt></b> (Level 1).</li>
	</ul>
		<p>Only <a href="tr10-22.html#well-formed_definition">well-formed weights</a> are
		allowed because if ill-formed weights were allowed, the ordering of elements 
		could be incorrectly reflected in the sort key. For example, suppose the secondary 
		weights of the Latin characters were zero (ignorable) and that (as normal) 
		the primary weights of case-variants are equal: that is, <i>a<sub>1</sub> 
		= A<sub>1</sub>.</i> Then the following incorrect keys would be generated:</p>
		
		<table class="wide">
			<tr>
				<th>Order</th>
				<th>String</th>
				<th>Normalized</th>
				<th>Sort Key</th>
			</tr>
			<tr>
				<td>1</td>
				<td>&quot;áe&quot;</td>
				<td>a, acute, e</td>
				<td>a<sub>1</sub> e<sub>1</sub> 0000 acute<sub>2</sub> 
			0000 <u><b>a<sub>3</sub></b></u> acute<sub>3</sub> e<sub>3</sub>...</td>
			</tr>
			<tr>
				<td>2</td>
				<td>&quot;Aé&quot;</td>
				<td>A, e, acute</td>
				<td>a<sub>1</sub> e<sub>1</sub> 0000 acute<sub>2</sub> 
			0000 <u><b>A<sub>3</sub></b></u> acute<sub>3</sub> e<sub>3</sub>...</td>
			</tr>
		</table>
		
		<p>Because the secondary weights for <i>a, A, </i>and<i> e</i> are lost 
		in forming the sort key, the relative order of the acute is also lost, resulting 
		in an incorrect ordering based solely on the case of <i>A</i> versus <i>
		a</i>. With well-formed weights, this does not happen, and 
		the following 
		correct ordering is obtained:</p>
		
		<table class="wide">
			<tr>
				<th>Order</th>
				<th>String</th>
				<th>Normalized</th>
				<th>Sort Key</th>
			</tr>
			<tr>
				<td>1</td>
				<td>&quot;Aé&quot;</td>
				<td>A, e, acute</td>
				<td>a<sub>1</sub> e<sub>1</sub> 0000 a<sub>2</sub>
			<u><b>e<sub>2</sub></b></u> acute<sub>2</sub> 0000 a<sub>3</sub> acute<sub>3</sub> 
			e<sub>3</sub>...</td>
			</tr>
			<tr>
				<td>2</td>
				<td>&quot;áe&quot;</td>
				<td>a, acute, e</td>
				<td>a<sub>1</sub> e<sub>1</sub> 0000 a<sub>2</sub>
			<u><b>acute<sub>2</sub></b></u> e<sub>2</sub> 0000 A<sub>3</sub> acute<sub>3</sub> 
			e<sub>3</sub>...</td>
			</tr>
		</table>
		
		<p>However, there are circumstances&#x2014;typically in expansions&#x2014;where higher-level 
		weights in collation elements can be zeroed (resulting in ill-formed collation 
		elements) without consequence (see <i>Section 
		6.2, <a href="tr10-22.html#Large_Weight_Values">Large Weight Values</a></i>). Implementations are free to do this as 
		long as they produce the same result as with well-formed tables.</p>
	
	<h2><a name="Tailoring"></a>5 Tailoring</h2>
	
	<p>Tailoring is any well-defined syntax that takes the Default 
	Unicode Collation Element Table and produces another well-formed Unicode Collation 
	Element Table. This syntax can provide linguistically-accurate collation, if 
	desired. Such syntax will usually allow the following:</p>
	
	<ol>
		<li>
		<p>Reordering any character (or contraction) with respect to 
		others in the standard ordering. The reordering can represent a Level 
		1 difference, Level 2 difference, Level 3 difference, or identity (in levels 
		1 to 3). Because such reordering includes sequences, arbitrary multiple 
		mappings can be specified.</p>
		</li>
		<li>
		<p>Setting the secondary level to be backwards (French) or forwards (normal).</p>
		</li>
		<li>
		<p>Set variable weighting options.</p>
		</li>
		<li>
		<p>Customizing the exact list of variable collation elements.</p>
		</li>
	</ol>

	<p>For best interoperability, it is recommended that tailorings for
	particular locales (or languages) make use of the tables provided in
	the Unicode Common Locale Data Repository [<a href="tr10-22.html#CLDR">CLDR</a>].</p>
	
        <p>For an example of a tailoring syntax, see
	<i>Section 5.2, <a href="tr10-22.html#Tailoring_Example">Tailoring Example</a></i>.</p>
		
  <h3>5.1 <a name="Parametic_Tailoring">Parametric Tailoring</a></h3>
	
	<p>Parametric tailoring, if supported, is specified using a set 
	of attribute-value pairs that specify a particular kind of behavior relative 
	to the UCA. The standard parameter names (attributes) and their posible values 
	are listed in <i>Table 14</i>, and follow those defined 
	in the <i>Unicode Locale Data Markup Language (LDML)</i> [<a href="tr10-22.html#UTS35">UTS35</a>] 
	in the table <i>Collation Settings</i> (<i>Section 5.14.3,
	<a href="http://unicode.org/reports/tr35/#Collation_Elements">Setting Options</a></i>). 
	The bold values are the defaults for the UCA.</p>
	
	<p class="caption"><a name="Collation_Parameters_Table"></a>Table 14. Collation Parameters</p>

	<div align="center">	
	<table>
		<tr>
			<th>Attribute</th>
			<th>Options</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>locale&nbsp; (or language)</td>
			<td><i>locale_id</i></td>
			<td>Specifies the tailoring rules for the language and/or variant. The 
			locale_id for locale or language uses the syntax from [<a href="tr10-22.html#UTS35">UTS35</a>],
			<i>Section 3, <a href="http://unicode.org/reports/tr35/#Identifiers">
			Unicode Language and Locale Identifiers</a></i>. Unless otherwise specified, tailoring by locale 
			uses the tables from the Unicode Common Locale Data Repository [<a href="tr10-22.html#CLDR">CLDR</a>]. 
			This choice may override the defaults 
			for the attributes given below. <b>UCA behavior</b> is the default if
			nothing is specified.</td>
		</tr>
		<tr>
			<td><font color="#000000">strength</font></td>
			<td>primary (1)<br>
			secondary (2)<br>
			<b>tertiary</b> (3)<br>
			quaternary (4)<br>
			identical (5)</td>
			<td>Sets the default strength for comparison, as described in the UCA. 
			The parenthesized numbers are alternate forms.</td>
		</tr>
		<tr>
			<td>alternate</td>
			<td>non-ignorable<br>
			<b>shifted</b><br>
			<i>blanked</i></td>
			<td>Sets alternate handling for variable weights, as described in
			<i>Section 3.6.2, <a href="tr10-22.html#Variable_Weighting">Variable 
			Weighting</a></i>. Note that in [<a href="tr10-22.html#UTS35">UTS35</a>], <i>blanked</i> 
			is not supported, and <b>shifted</b> is the default.</td>
		</tr>
		<tr>
			<td>backwards</td>
			<td>on<br>
			<b>off</b></td>
			<td>Sets the comparison for the second level<i> only </i>to be backwards 
			(&quot;French&quot;), as described in <i>Section 
			3.4 <a href="tr10-22.html#French_Accents">French Accents</a></i> 
			and specified in <a href="tr10-22.html#S3.3">S3.3</a>-<a href="tr10-22.html#S3.6">S3.6</a>. 
			The default is <b>on</b> for the French locales and <b>off</b> for others.</td>
		</tr>
		<tr>
			<td>normalization</td>
			<td><b>on</b><br>
			off</td>
			<td>Conformant implementations may skip [<b><a name="S1.2">S1.1</a>]</b> 
			in certain circumstances. If <i>on</i>, then the normal UCA algorithm 
			is used. If <i>off</i>, all strings that normalized will sort correctly, 
			but others won&#39;t necessarily sort correctly. So it should only be set
			<i>off</i> if the the strings to be compared are normalized. (It is 
			recommended that implementations correctly sort all strings that are 
			in the format known as "Fast C or D form" 
			(FCD) even if normalization is <i>off</i>. 
			For more information on FCD, see [<a href="tr10-22.html#UTN5">UTN5</a>].)</td>
		</tr>
		<tr>
			<td>caseLevel</td>
			<td>on<br>
			<b>off</b></td>
			<td>If set to <i>on,</i> a level consisting only of case characteristics 
			will be inserted in front of tertiary level. To ignore accents but take 
			cases into account, set strength to primary and case level to <i>on</i>.
			</td>
		</tr>
		<tr>
			<td>caseFirst</td>
			<td>upper<br>
			lower<br>
			<b>off</b></td>
			<td>If set to <i>upper</i>, causes uppercase to sort before lowercase. 
			If set to <i>lower</i>, lowercase will sort before uppercase. Useful 
			for locales that have already supported ordering but require different 
			order of cases. Affects case and tertiary levels.</td>
		</tr>
		<tr>
			<td>hiraganaQuaternary</td>
			<td>on<br>
			<b>off</b></td>
			<td>Controls special treatment of Hiragana code points on quaternary 
			level. If turned <i>on</i>, Hiragana codepoints will get lower values 
			than all the other non-variable code points. The strength must be greater 
			or equal than quaternary for this attribute to take effect. 
			The default is <b>on</b> for the Japanese locales and <b>off</b> for 
			others.</td>
		</tr>
		<tr>
			<td>numeric</td>
			<td>on<br>
			<b>off</b></td>
			<td>If set to <i>on</i>, any sequence of Decimal Digits (General_Category 
			= Nd in the Unicode Character Database [<a href="tr10-22.html#UAX44">UAX44</a>]) is sorted at a primary level with 
			its numeric value. For example, &quot;A-21&quot; &lt; &quot;A-123&quot;.</td>
		</tr>
		<tr>
			<td>variableTop</td>
			<td><i>uXXuYYYY</i></td>
			<td>The parameter value is an encoded Unicode string, with code points 
			in hex, leading zeros removed, and "u" inserted between successive elements.<p>
			Sets the default value for the variable top. All the code points with 
			primary strengths less than variable top will be considered variable, 
			and thus affected by the alternate handling. If not specified, then 
			the default is the value in DUCET.</p>
			</td>
		</tr>
		<tr>
			<td>match-boundaries:</td>
			<td nowrap>none<br>
			whole-character<br>
			whole-word</td>
			<td>Defined in <i>Section 8, <a href="tr10-22.html#Searching">Searching and Matching</a>.</i></td>
		</tr>
		<tr>
			<td>match-style</td>
			<td>minimal<br>
			medial<br>
			maximal</td>
			<td>Defined in <i>Section 8, <a href="tr10-22.html#Searching">Searching and Matching</a>.</i></td>
		</tr>
	</table>
	</div>
	<p>&nbsp;</p>
	
	<h3><a name="Tailoring_Example"></a>5.2 Tailoring Example</h3>
	
  <p>Unicode [<a href="tr10-22.html#CLDR">CLDR</a>] provides a powerful tailoring syntax 
  in [<a href="tr10-22.html#UTS35">UTS35</a>], as well as tailoring data for many locales.  
  The tailorings are based on the DUCET table, although there are some general tailorings always 
  applied to the DUCET in CLDR 1.9. This XML format maps to a simpler representation in ICU, 
  shown in <i>Table 15</i>. A simpler version of this syntax is also used in Java, 
  although at the time of this writing, Java does not implement the UCA.</p>
	
  <p class="caption"><a name="ICU_Tailoring_Syntax_Table"></a>Table 15. ICU Tailoring Syntax</p>

	<div align="center">	
	<table>
		<tr>
			<th>Syntax</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>&nbsp;&amp; y &lt; x</td>
			<td>Make x primary-greater than y</td>
		</tr>
		<tr>
			<td>&nbsp;&amp; y &lt;&lt; x</td>
			<td>Make x secondary-greater than y</td>
		</tr>
		<tr>
			<td>&nbsp;&amp; y &lt;&lt;&lt; x</td>
			<td>Make x tertiary-greater than y</td>
		</tr>
		<tr>
			<td>&nbsp;&amp; y = x</td>
			<td>Make x equal to y</td>
		</tr>
	</table>
	</div>
	
	<p>Either <i>x</i> or <i>y</i> in this syntax can 
	represent more than one character, to handle contractions and 
	expansions.</p>
	
  <p>Entries for tailoring can be abbreviated in a number of ways: </p>
	<ul>
		<li>They do not need to be separated by newlines.</li>
		<li>Characters can be specified directly, instead of using their hexadecimal 
		Unicode values.</li>
		<li>In rules of the form &quot;x &lt; y &amp; y &lt; z&quot;, 
		&quot;&amp; y&quot; can be omitted, leaving just &quot;x &lt; y &lt; z&quot;.</li>
	</ul>
	<p>These abbreviations can be applied successively, so the 
	examples shown in <i>Table 16</i> are equivalent in ordering.</p>
	
	<p class="caption"><a name="Equivalent_Tailorings_Table"></a>Table 16. Equivalent Tailorings</p>
	
	<div align="center">
	<table>
		<tr>
			<th><div align="center">ICU</div></th>
			<th><div align="center">Unicode Collation Element Table</div></th>
		</tr>
		<tr>
			<td><p>&nbsp;a &lt;&lt;&lt; A &lt;&lt; &#x00E0; &lt;&lt;&lt; &#x00C0;</p>
		    <p>&lt; b &lt;&lt;&lt; B&nbsp;</p></td>
			<td>
			<pre>
0061 ; [.0001.0001.0001] % a
0040 ; [.0001.0001.0002] % A
00E0 ; [.0001.0002.0001] % &#x00E0;
00C0 ; [.0001.0002.0002] % &#x00C0;
0042 ; [.0002.0001.0001] % b
0062 ; [.0002.0001.0002] % B</pre>
			</td>
		</tr>
	</table>
  </div>
			
	<p>The syntax has many other capabilities: for more information, see  
	[<a href="tr10-22.html#UTS35">UTS35</a>] and [<a href="tr10-22.html#ICUCollator">ICUCollator</a>].</p>
	
	<h3>5.3 <a name="Combining_Grapheme_Joiner">Use of Combining Grapheme Joiner</a></h3>
	
	<p>The Unicode Collation Algorithm involves the normalization of Unicode text 
	strings before collation weighting. U+034F COMBINING GRAPHEME JOINER (CGJ) 
	is ordinarily ignored in collation key weighting in the UCA, but it can be used 
	to block the reordering of combining marks in a string as described in [<a href="tr10-22.html#Unicode">Unicode</a>]. 
	In that case, its effect can be to invert the order of secondary key weights 
	associated with those combining marks. Because of this, the two strings would 
	have distinct keys, making it possible to treat them distinctly in searching 
	and sorting without having to further tailor either the combining grapheme joiner 
        or the combining marks.</p>
	<p>The CGJ can also be used to prevent the formation of contractions in the 
	Unicode Collation Algorithm. Thus, for example, while <i>ch</i> is sorted as 
	a single unit in a tailored Slovak collation, the sequence &lt;<i>c</i>, CGJ,
	<i>h</i>&gt; will sort as a <i>c</i> followed by an <i>h</i>. This can also be 
	used in German, for example, to force <i>ü</i> to be sorted as <i>u + umlaut</i> 
	(thus <i>u</i> &lt;<sub>2</sub> <i>ü</i>), even where a dictionary sort is being 
	used (which would sort <i>ue</i> &lt;<sub>3</sub> <i>ü)</i>. This happens without 
	having to further tailor either the combining grapheme joiner or the sequence.</p>
	<blockquote>
		<p><b>Note: </b>As in a few other cases in Unicode, the name of the CGJ 
		can be misleading: the usage above is in some sense the inverse of &quot;joining&quot;.</p>
	</blockquote>
	<p>Sequences of characters which include the combining grapheme joiner or other 
	completely ignorable characters may also be given tailored weights. Thus the 
	sequence &lt;c, CGJ, h&gt; could be weighted completely differently 
	from either the contraction "ch" or the sequence "c" followed by "h" 
	without the contraction. However, this application of CGJ is not 
	recommended, because it would produce effects much different than the normal 
	usage above, which is to simply interrupt contractions.</p>
	
	<h3>5.4 <a name="Preprocessing"></a>Preprocessing</h3>
	
	<p>In addition to tailoring, some implementations may choose to 
	preprocess the text for special purposes. Once such preprocessing is done, the 
	standard algorithm can be applied.</p>
	<p>Examples include:</p>
	<ul>
		<li>mapping &quot;McBeth&quot; to &quot;MacBeth&quot;</li>
		<li>mapping &quot;St.&quot; to &quot;Street&quot; or &quot;Saint&quot;, depending on the context</li>
		<li>dropping articles, such as "a" or "the"</li>
		<li>using extra information, such as pronunciation data for 
		Han characters</li>
	</ul>
	<p>Such preprocessing is outside of the scope of this document.</p>
	
	<h2><a name="Implementation_Notes"></a>6 Implementation Notes</h2>
	
	<p>As noted above for efficiency, implementations may vary from 
	this logical algorithm as long as they produce the same result. The following 
	items discuss various techniques that can be used for reducing sort key length, 
	reducing table sizes, customizing for additional environments, searching, and 
	other topics.</p>
	
	<h3><a name="Reducing_Sort_Key_Lengths"></a>6.1 Reducing Sort Key Lengths</h3>
	
	<p>The following discuss methods of reducing sort key lengths. 
	If these methods are applied to all of the sort keys produced by an implementation, 
	they can result in significantly shorter and more efficient sort keys while 
	retaining the same ordering.</p>
	
	<h4>6.1.1 <a name="Eliminating_level_separators">Eliminating Level Separators</a></h4>
	
	<p>Level separators are not needed between two levels in the sort key, if the 
	weights are properly chosen. For example, if all L3 weights are less than all 
	L2 weights, then no level separator is needed between them. If there is a fourth 
	level, then the separator before it needs to be retained.</p>
	<p>The following example shows a sort key with these level separators removed.</p>
	
	<table class="wide">
		<tr>
			<th width="10%">String</th>
			<th width="20%">Technique(s) Applied</th>
			<th>Sort Key</th>
		</tr>
		<tr>
			<td>càb</td>
			<td>none</td>
			<td><tt>0706 06D9 06EE <font color="#00ba00"><b>0000</b></font> 0020 0020 0021 0020 <font color="#00ba00"><b>0000</b></font> 0002 
			0002 0002 0002</tt></td>
		</tr>
		<tr>
			<td>càb</td>
			<td>1</td>
			<td><tt>0706 06D9 06EE 0020 0020 0021 0020 0002 0002 0002 0002</tt></td>
		</tr>
	</table>
	
	<p>While this technique is relatively easy to implement, it can interfere with 
	other compression methods.</p>
	<h4>6.1.2 <a name="L2/L3_in_8_bits">L2/L3 in 8 Bits</a></h4>
	<p>The L2 and L3 weights commonly are small values. Where that condition occurs 
	for all possible values, they can then be represented as single 8-bit quantities.</p>
	<p>The following example modifies the first example with both these changes (and grouping by bytes). 
	Note that the separator has to remain after the primary weight when combining 
	these techniques. If any separators are retained (such as before the fourth 
	level), they need to have the same width as the previous level.</p>
	
	<table class="wide">
		<tr>
			<th width="10%">String</th>
			<th width="20%">Technique(s) Applied</th>
			<th>Sort Key</th>
		</tr>
		<tr>
			<td>càb</td>
			<td>none</td>
			<td><tt>07 06 06 D9 06 EE <font color="#00ba00"><b>00 00</b></font> 
			<font color="#0099ff">00</font> 20 <font color="#0099ff">00</font> 20 
			<font color="#0099ff">00</font> 21 <font color="#0099ff">00</font> 20 <font color="#00ba00"><b>00 00</b></font> 
			<font color="#0099ff">00</font> 02 <font color="#0099ff">00</font> 02 
			<font color="#0099ff">00</font> 02 <font color="#0099ff">00</font> 02</tt></td>
		</tr>
		<tr>
			<td>càb</td>
			<td>1, 2</td>
			<td><tt>07 06 06 D9 06 EE <font color="#00ba00"><b>00 00</b></font> 20 20 21 20 02 02 02 02</tt></td>
		</tr>
	</table>
	
	<h4>6.1.3 <a name="Machine_Words">Machine Words</a></h4>
	
	<p>The sort key can be represented as an array of different quantities depending 
	on the machine architecture. For example, comparisons as arrays of 32-bit quantities 
	may be much faster on some machines. 
	When using arrays of 32-bit quantities, the original is to be 
	padded with trailing (not leading) zeros as necessary.</p>
	
	<table class="wide">
		<tr>
			<th width="10%">String</th>
			<th width="20%">Technique(s) Applied</th>
			<th>Sort Key</th>
		</tr>
		<tr>
			<td>càb</td>
			<td>1, 2</td>
			<td><tt>07 06 06 D9 06 EE 00 00 20 20 21 20 02 02 02 02</tt></td>
		</tr>
		<tr>
			<td>càb</td>
			<td>1, 2, 3</td>
			<td><tt>070606D9 06EE0000 20202120 02020202</tt></td>
		</tr>
	</table>
	
	<h4>6.1.4 <a name="Run-length_Compression">Run-Length Compression</a></h4>
	<p>Generally sort keys do not differ much in the secondary or tertiary weights, 
	which tends to result in keys with a lot of repetition. This also occurs with 
	quaternary weights generated with the shifted parameter. By the structure of 
	the collation element tables, there are also many weights that are never assigned 
	at a given level in the sort key. One can take advantage of these regularities 
	in these sequences to compact the length&#x2014;while retaining the same sort 
	sequence&#x2014;by using the following technique. (There are other techniques that can also 
	be used.)</p>
	<p>This is a logical statement of the process; the actual implementation can 
	be much faster and performed as the sort key is being generated.</p>
	<ul>
		<li>For each level <b><i>n, </i></b>find the most common value COMMON produced 
		at that level by the collation element table for typical strings. For example, 
		for the Default Unicode Collation Element Table, this is:
		<ul>
			<li>0020 for the secondaries (corresponding to unaccented characters)
			</li>
			<li>0002 for tertiaries (corresponding to lowercase or unmarked letters)
			</li>
			<li>FFFF for quaternaries (corresponding to non-ignorables with the 
			shifted parameter) </li>
		</ul>
		</li>
		<li>Reassign the weights in the collation element table at level <b><i>n</i></b> 
		to create a gap of size GAP above COMMON. Typically for secondaries or tertiaries 
		this is done after the values have been reduced to a byte range by the above 
		methods. Here is a mapping that moves weights up or down to create a gap 
		in a byte range.<br>
		<tt>w &#x2192; w + 01 - MIN, for MIN &lt;= w &lt; COMMON<br>
		w &#x2192; w + FF - MAX, for COMMON &lt; w &lt;= MAX</tt> </li>
		<li>At this point, weights go from 1 to MINTOP, and from MAXBOTTOM to MAX. 
		These new unassigned values are used to run-length encode sequences of COMMON 
		weights. </li>
		<li>When generating a sort key, look for maximal sequences of <b>m</b> COMMON 
		values in a row. Let W be the weight right after the sequence.
		<ul>
			<li>If W &lt; COMMON (or there is no W), replace the sequence by a synthetic 
			low weight equal to (MINTOP + m). </li>
			<li>If W &gt; COMMON, replace the sequence by a synthetic high weight equal 
			to (MAXBOTTOM - m). </li>
		</ul>
		<p>In the example shown in <i>Figure 4</i>, the low weights are 01, 02; the high weights 
		are FE, FF; and the common weight is 77. </p>
		</li>
	</ul>
	
	<p class="caption"><a name="Run_Length_Compression_Table"></a>Figure 4. Run-Length Compression</p>

	<div align="center">
		<table>
			<tr>
				<th width="50%">Original Weights</th>
				<th width="50%">Compressed Weights</th>
			</tr>
			<tr>
				<td width="50%">
				<pre>01
02
77 01
77 02
77 77 01
77 77 02
77 77 77 01
77 77 77 02
...
77 77 77 FE
77 77 77 FF
77 77 FE
77 77 FF
77 FE
77 FF
FE
FF</pre>
				</td>
				<td width="50%">
				<pre>01
02
03 01
03 02
04 01
04 02
05 01
05 02
...
FB FE
FB FF
FC FE
FC FF
FD FE
FD FF
FE
FF</pre>
				</td>
			</tr>
		</table>
	</div>
	
	<ul>
		<li>The last step is a bit too simple, because the synthetic 
		weights must not collide with other values having long strings of COMMON weights. 
		This is done by using a sequence of synthetic weights, absorbing as much 
		length into each one as possible. A value BOUND is defined
		between MINTOP and MAXBOTTOM. The exact value for BOUND can be chosen based 
		on the expected frequency of synthetic low weights versus high weights for 
		the particular collation element table.
		<ul>
			<li>If a synthetic low weight would not be less than BOUND, use a sequence 
			of low weights of the form (BOUND-1)..(BOUND-1)(MINTOP + remainder) 
			to express the length of the sequence. </li>
			<li>Similarly, if a synthetic high weight would be less than BOUND, 
			use a sequence of high weights of the form (BOUND)..(BOUND)(MAXBOTTOM 
			- remainder). </li>
		</ul>
		</li>
	</ul>
	<p>This process results in keys that are never longer than the original, are 
	generally much shorter, and result in the same comparisons.</p>
	
	<h3><a name="Large_Weight_Values"></a>6.2 Large Weight Values</h3>
	
	<p>If a collation sequence requires more than 
	65,535 weight values (or 65,024 values where zero bytes are avoided), 
	this requirement can still be accommodated by assigning multiple collation elements to 
	single characters. For example, suppose that 50,000 supplementary 
	private-use characters are used 
	in a particular implementation, and that these are to be sorted after 
	a character whose primary weight is <code>X</code>. Simply 
	assign them all dual collation elements of the following form:</p>
	<blockquote>
		<p><code>[(X+1).0000.0000], [yyyy.zzzz.wwww]</code> </p>
	</blockquote>
	<p>If there is an element with the primary weight <code>(X+1)</code>, 
	then it also needs to be converted into a dual collation element.</p>
	<p>The private-use characters will then sort properly with respect 
	to each other and the rest of the characters. The first collation element of this dual
	collation element pair is one of the instances in which ill-formed collation 
	elements are allowed. The second collation element
	of each of these pairs is well-formed, and the first element only occurs in combination
	with them. In this way, ordering is preserved with respect to other, non-paired
	collation elements.</p>
	
	<h3><a name="Reducing_Table_Sizes"></a>6.3 Reducing Table Sizes</h3>
	
	<p>The data tables required for  
	collation of the entire Unicode repertoire can be quite sizable. This 
	section discusses ways to significantly reduce the table size in memory. These recommendations
	have very important implications for implementations.</p>
	
	<h4>6.3.1 <a name="Contiguous_weight_ranges">Contiguous Weight Ranges</a></h4>
	
	<p>The Default Unicode Collation Element Table has secondary weights that are 
	greater than 00FF. This is the result of the derivation described in <i>
	Section 7, <a href="tr10-22.html#Weight_Derivation">Weight Derivation</a></i>. However, 
	these values can be compacted to a range of values that do not exceed 00FF. 
	Whenever collation elements have different primary weights, the ordering of 
	their secondary weights is immaterial. Thus all of the secondaries that share 
	a single primary can be renumbered to a contiguous range without affecting the 
	resulting order. Composite characters still need to be handled correctly if 
	normalization is avoided as discussed in 
	<i>Section 6.5, <a href="tr10-22.html#Avoiding_Normalization">Avoiding Normalization</a></i>.</p>
	
	<p>For example, for the primary value 1724 (for the letter "O", as of
	UCA Version 6.0.0), there are 18 distinct secondary values ranging from 0020 to 
	015F. These can be renumbered 
	to the contiguous range from 0020 to 0031, which is less than 00FF.</p>
	
	<h4>6.3.2 <a name="Escape_hatch">Escape Hatch</a></h4>
	
	<p>Although the tertiary weights for the Default Unicode Collation 
	Element Table can fit within one byte, any particular tailored 
	table could conceivably end up with tertiary weights that exceed 
	what can be contained in a single byte. Secondary weights in
	the Default Unicode Collation Element Table already far exceed what can be represented
	by a single byte, ranging from 0020 to 019A as of UCA Version 6.0.0. However, the same technique used for 
	large weight values can also be used for implementations that do not want to 
	handle more than 00FF values for a particular weight.</p>
	<p>For example, the Java collation implementation only stored 8-bit quantities 
	in level 2 and level 3. However, characters can be given L2 or L3 weights with 
	greater values by using a series of two collation elements. For example, 
	if characters require 2,000 weights at L2, then 248 characters can be given single 
	keys, while 1,752 (2000 - 248) can be given two collation keys of the form [yyyy.00zz.00ww] 
	[0000.00nn.0001].</p>
	<p>The 248 in this example can be chosen to be the higher frequency characters, while there 
	would need to be eight distinct zz values to cover the remaining characters. 
  These zz values must only be used with dual collation elements.</p>
	<h4>6.3.3 <a name="Leveraging_Unicode_tables">Leveraging Unicode Tables</a></h4>
	<p>Because all canonically decomposable characters are decomposed in Step 1.1, 
	no collation elements need to be supplied for them. This includes a very large 
	number of characters&#x2014;not only a large number of Latin and Greek characters, 
	but also the very large number of Hangul syllables.</p>
	<p>Because most compatibility decomposable characters in the default table can 
	be algorithmically generated from the decomposition, no collation elements need 
	to be stored for those decomposable characters: the collation elements can be 
	generated on the fly with only a few exceptions entered in the table. The collation 
	elements for the Han characters (unless tailored) are algorithmically derived; 
	no collation elements need to be stored for them either. For more information, 
	see <i>Section 7, <a href="tr10-22.html#Weight_Derivation">Weight Derivation</a></i>.</p>
	<p>This means that only a small fraction of the total number of Unicode characters 
	need to have an explicit collation element. This can cut down the memory storage 
	considerably.</p>
	
	<h4>6.3.4 <a name="Reducing_the_Repertoire">Reducing the Repertoire</a></h4>
	
	<p>If characters are not fully supported by an implementation, then their code 
	points can be treated as if they were unassigned. This allows them to be algorithmically 
	constructed from code point values instead of including them in a table. This 
	can significantly reduce the size of the required tables. See <i>
	Section 7.1, <a href="tr10-22.html#Derived_Collation_Elements">Derived Collation Elements</a></i> 
	for more information.</p>
	
	<h4>6.3.5 <a name="Memory_Table_Size">Memory Table Size</a></h4>
	
	<p>Applying the above techniques, an implementation can thus safely pack all 
	of the data for a collation element into a single 32-bit quantity: 16 for the 
	primary, 8 for the secondary and 8 for the tertiary. Then applying techniques 
	such as the Two-Stage table approach described in <i>&quot;Multistage Tables&quot;</i> 
	in <i>Section 5.1, Transcoding to Other Standards</i> of [<a href="tr10-22.html#Unicode">Unicode</a>], 
	the mapping table from characters to collation elements can both fast and small. 
	For an example of how this can be done, see <i>
	Section 6.10, <a href="tr10-22.html#Flat_File_Example">Flat File Example</a></i>.</p>
	
	<h3><a name="Avoiding_Zero_Bytes"></a>6.4 Avoiding Zero Bytes</h3>
	
	<p>If the resulting sort key is to be a C-string, then zero bytes must be avoided. 
	This can be done by:</p>
	<ul>
		<li>using the value 0101<sub>16</sub> for the level separator instead of 
		0000</li>
		<li>preprocessing the weight values to avoid zero bytes, 
		for example by remapping as follows:</li>
	</ul>
		<blockquote>
			x &#x2192; 0101<sub>16</sub> + (x / 255)*256 + (x % 255)
		</blockquote>

	<p>Where the values are limited to 8-bit quantities (as discussed above), 
	zero bytes are even more easily avoided by just using 01 as the level separator 
	(where one is necessary), and mapping weights by:</p>
		<blockquote>
			x &#x2192; 01 + x
		</blockquote>
	
	<h3><a name="Avoiding_Normalization"></a>6.5 Avoiding Normalization</h3>
	
	<p>Implementations that do not handle separate combining 
	marks can map decomposable characters (such as &quot;à&quot;) to single collation elements 
	with different Level 2 weights for the different accents. However, 
	this requires including the mappings for these characters in the collation 
	table, which will increase the size substantially unless the collation elements 
	for the Hangul syllables are computed algorithmically.</p>
	
	<h4>6.5.1 <a name="Canonical_Decompositions">Canonical Decompositions</a></h4>
	
	<p>Characters with canonical decompositions do not require mappings to collation 
	elements, because <a href="tr10-22.html#S1.1">S1.1</a> maps them to collation elements based upon their 
	decompositions. However, they may be given mappings to collation elements anyway. 
	The weights in those collation elements must be computed in such a way that they 
	will sort in the same relative location as if the characters were decomposed 
	using Normalization Form D. Including these mappings allows an implementation 
	handling a restricted repertoire of supported characters to compare strings 
	correctly without performing the normalization in <a href="tr10-22.html#S1.1">S1.1</a> of the algorithm.</p>
	
	<p>A combining character sequence is called <i>impeding</i> if it contains any 
	conjoining jamo, or if it contains an L1-ignorable combining mark and there 
	is some character that canonically decomposes to a sequence containing the same 
	base character. For example, the sequence &lt;a, cedilla&gt; is an impediment, because
	<i>cedilla</i> is an L1-ignorable character, and there is some character (for 
	example, <i>a-grave</i>) that decomposes to a sequence containing the same base 
	letter <i>a</i>. Note that although strings in Normalization Form C generally 
	do not contain impeding sequences, there is nothing prohibiting them from containing 
	them. Conformant implementations that do not support impeding 
		character sequences as part of their repertoire can also avoid 
		performing the normalization in <a href="tr10-22.html#S1.1">S1.1</a> of the algorithm.</p>
	
	<h4>6.5.2 <a name="Compatibility_Decompositions">Compatibility Decompositions</a></h4>
	
	<p>Most characters with compatibility decompositions can 
	have collation elements computed at runtime to save space, duplicating the work 
	that was done to compute the Default Unicode Collation Element Table. This can 
	be an important savings in memory space. The process works as follows.</p>
	<p><b>1. </b>Derive the compatibility decomposition. For example,</p>
	<blockquote>
		<pre>2475 PARENTHESIZED DIGIT TWO =&gt; 0028, 0032, 0029</pre>
	</blockquote>
	<p><b>2. </b>Look up the collation
	element for each character in the decomposition. For example,</p>
	<blockquote>
		<pre>0028 [*023D.0020.0002] % LEFT PARENTHESIS
0032 [.06C8.0020.0002] % DIGIT TWO
0029 [*023E.0020.0002] % RIGHT PARENTHESIS</pre>
	</blockquote>
	<p><b>3. </b>Set the first two L3 values to be lookup (L3), where the lookup function uses the table in <i>Section 7.2, <a href="tr10-22.html#Tertiary_Weight_Table">Tertiary 
	Weight Table</a></i>. Set the remaining L3 values to MAX (which in the default 
	table is 001F). For example,</p>
	<blockquote>
		<pre>0028 [*023D.0020.0004] % LEFT PARENTHESIS
0032 [.06C8.0020.0004] % DIGIT TWO
0029 [*023E.0020.001F] % RIGHT PARENTHESIS</pre>
	</blockquote>
	<p><b>4.</b> Concatenate the result to produce the sequence of collation elements 
	that the character maps to. For example,</p>
	<blockquote>
		<pre>2475 [*023D.0020.0004] [.06C8.0020.0004] [*023E.0020.001F] </pre>
	</blockquote>
	<p>Some characters cannot be computed in this way. They must be filtered out 
	of the default table and given specific values. For example,</p>
	<blockquote>
		<pre>017F [.085D.00FD.0004.017F] % LATIN SMALL LETTER LONG S; COMPAT</pre>
	</blockquote>
	
	<h3><a name="Case_Comparisons"></a>6.6 Case Comparisons</h3>
	
	<p>In some languages, it is common to sort lowercase before uppercase; in other 
	languages this is reversed. Often this is more dependent on the individual concerned, 
	and is not standard across a single language. It is strongly recommended that 
	implementations provide parameterization that allows uppercase to be sorted before 
	lowercase, and provides information as to the standard (if any) for particular 
	countries. This can easily be done to the Default Unicode Collation Element 
	Table before tailoring by remapping the L3 weights (see <i>
	Section 7, <a href="tr10-22.html#Weight_Derivation">Weight Derivation</a></i>). It can be 
	done after tailoring by finding the case pairs and swapping the collation elements.</p>
	
	<h3><a name="Incremental_Comparison"></a>6.7 Incremental Comparison</h3>
	
	<p>Implementations do not actually have to produce full sort keys. Collation 
	elements can be incrementally generated as needed from two strings, and compared 
	with an algorithm that produces the same results as sort keys would have. The 
	choice of algorithm depends on the number of comparisons between 
	the same strings.</p>
	<ul>
		<li>Generally incremental comparison is <i>more</i> efficient than producing 
		full sort keys if strings are only to be compared once and if they are generally 
		dissimilar, because differences are caught in the first few characters without 
		having to process the entire string. </li>
		<li>Generally incremental comparison is <i>less</i> efficient than producing 
		full sort keys if items are to be compared multiple times. </li>
	</ul>
	<p>However, it is very tricky to produce an incremental comparison that produces 
	correct results. For example, some implementations have not even been transitive! 
	Be sure to test any code for incremental comparison thoroughly.</p>
	
	<h3><a name="Catching_Mismatches"></a>6.8 Catching Mismatches</h3>
	
	<p>Sort keys from two different tailored collations cannot be compared, because 
	the weights may end up being rearranged arbitrarily. To catch this case, implementations 
	can produce a hash value from the collation data, and prepend it to the sort 
	key. Except in extremely rare circumstances, this will distinguish the sort 
	keys. The implementation then has the opportunity to signal an error.</p>
	
	<h3>6.9 <a name="Collation_Graphemes">Handling Collation Graphemes</a></h3>
	
	<p>A collation ordering determines a <i>collation grapheme cluster</i> (also 
	known as a collation grapheme or collation character), which is a sequence of 
	characters that is treated as a primary unit by the ordering. For example,
	<i>ch</i> is a collation grapheme for a traditional Spanish ordering. These 
	are generally contractions, but may include additional ignorable characters. 
	To determine the boundaries for a collation grapheme starting at a given position, 
	use the following process:</p>
	<ol>
		<li>Set <code>oldPosition</code> to be equal to <code>position</code>.</li>
		<li>If <code>position</code> is at the end of the string, return it.</li>
		<li>Fetch the next collation element(s) mapped to by the character(s) at
		<code>position</code>.</li>
		<li>If the collation element(s) contain a non-ignorable and <code>position</code> 
		is not equal to <code>oldPosition</code>, return <code>position</code>.</li>
		<li>Otherwise set <code>position</code> to be the end of the characters 
		mapped.</li>
		<li>Loop back to step 2.</li>
	</ol>
	<p>For information on the use of collation graphemes, see [<a href="tr10-22.html#UTS18">UTS18</a>].</p>
	
	<h3>6.10 <a name="Flat_File_Example">Flat File Example</a></h3>
	<p>This section contains a sample flat-file binary layout and sample code for collation 
	data. It is included only for illustration. Data in the format of <i>Table 17</i> is used to generate collation 
	elements from characters, either going forward or backward, and detect the 
	start of a contraction. The backward generation is for searching backward 
	or Boyer-Moore-style searching; the contraction detection is for random access.</p>
	<p>In the file representation, ints are 32 bit values, shorts are 16 bits, bytes 
	are 8 bits. Negatives are two&#39;s-complement. For alignment, the ends of all arrays 
	are padded out to multiples of 32 bits. The signature determines endianness. 
	The locale uses an ASCII representation for the Java locale: a 2-byte ISO language 
	code, optionally followed by &#39;_&#39; and 2-byte ISO country code, followed optionally 
	by a series of variant tags separated by &#39;_&#39;; any unused bytes are zero.</p>
	
	<p class="caption"><a name="Flat_File_Format_Table"></a>Table 17. Flat File Format</p>

	<div align="center">	
	<table>
		<tr>
			<th>Data</th>
			<th colspan="2">Comment</th>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int signature;</td>
			<td colspan="2">Constant <code>0x636F6C74</code>, used also for big-endian detection</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int tableVersion;</td>
			<td colspan="2">Version of the table format</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int dataVersion;</td>
			<td colspan="2">Version of the table data</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>byte[32] locale;</td>
			<td colspan="2">Target locale (if any)</td>
		</tr>
		<tr>
			<td>int flags;</td>
			<td colspan="2">Bit01 = 1 if French secondary.
			Other values are reserved.</td>
		</tr>
		<tr>
			<td>int limitVariable;</td>
			<td colspan="2">Every CE below this value that has a 
			non-zero primary is variable. Because variables are not interleaved, 
			this does not need to be stored on a per-character basis.</td>
		</tr>
		<tr>
			<td>int maxCharsPerCE;</td>
			<td colspan="2">Maximum number of characters that are part of a contraction</td>
		</tr>
		<tr>
			<td>int maxCEsPerChar;</td>
			<td colspan="2">Maximum number of collation elements that are generated by an expansion</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int indexOffset;</td>
			<td colspan="2">Offset to index table</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int collationElementsOffset;</td>
			<td colspan="2">Offset to main data table</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int expansionsOffset;</td>
			<td colspan="2">Offset to expansion table</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int contractionMatchOffset;</td>
			<td colspan="2">Offset to contraction match table</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int contractionResultOffset;</td>
			<td colspan="2">Offset to contraction values table</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int nonInitialsOffset;</td>
			<td colspan="2">Offset to non-initials table. These are used for random access.</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int[10] reserved;</td>
			<td colspan="2">Reserved</td>
		</tr>
		<tr>
			<td>int indexLength;</td>
			<td colspan="2">Length of following table</td>
		</tr>
		<tr>
			<td>int[] index;</td>
			<td colspan="2">Index for high-byte (trie) table. Contains 
			offsets into Collation Elements. Data is accessed by:<br>
			<code>ce = collationElements[index[char&gt;&gt;8]+char&amp;0xFF]</code></td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int&nbsp;collationElementsLength;</td>
			<td colspan="2">Length of following table</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int[] collationElements;</td>
			<td colspan="2">Each element is either 
			a real collation element, an expansionsOffset, or a contractionsOffset. 
			See below for more information.</td>
		</tr>
		<tr>
			<td>int expansionsLength;</td>
			<td colspan="2">Length of following table</td>
		</tr>
		<tr>
			<td>int[] expansions;</td>
			<td colspan="2">The expansionOffsets in the collationElements 
			table point into sublists in this table. Each list is terminated by 
			FFFFFFFF.</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int&nbsp;contractionMatchesLength;</td>
			<td colspan="2">Length of following table</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td rowspan="4">short[] contractionMatches;</td>
			<td colspan="2">The contractionOffsets 
			in the collationElements table point into sublists in this table. Each 
			sublist is of the following format:</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>short backwardsOffset;</td>
			<td>When processing backward, offset to true contractions table</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>short length;</td>
			<td>Number of chars in list to search</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>short[] charsToMatch;</td>
			<td>Characters in sorted order</td>
		</tr>
		<tr>
			<td>int contractionCEsLength;</td>
			<td colspan="2">Length of following table</td>
		</tr>
		<tr>
			<td>int[] contractionCEs;</td>
			<td colspan="2">List of CEs. Each corresponds to a position 
			in the contractionChars table. The one corresponding to the length in 
			a sublist is the <i>bail-out;</i> this specifies what to do if a match is not found.</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>int nonInitialsLength;</td>
			<td colspan="2">Length of following table</td>
		</tr>
		<tr bgcolor="#FFFFCC">
			<td>short[] nonInitials;</td>
			<td colspan="2">List of characters 
			(in sorted order) that can be non-initials in contractions. That is, 
			if &quot;ch&quot; is a contraction, then &quot;h&quot; is in this list. If &quot;abcd&quot; is a contraction, 
			then &quot;b&quot;, &quot;c&quot;, and &quot;d&quot; are in the list.</td>
		</tr>
	</table>
	</div>
	
	<p>&nbsp;</p>
	
	<h4>6.10.1 <a name="Collation_Element_Format">Collation Element Format</a></h4>
	<ul>
		<li>&#39;real&#39; collationElement
		<ul>
			<li>16 bits primary (FFE0..FFFF not allowed)</li>
			<li>10 bits secondary</li>
			<li>&nbsp;6 bits tertiary</li>
		</ul>
		</li>
		<li>expansionsOffset
		<ul>
			<li>12 bits = FFF</li>
			<li>20 bits = offset (allows for 1,048,576 items)</li>
		</ul>
		</li>
		<li>contractionsOffset
		<ul>
			<li>12 bits = FFE</li>
			<li>20 bits = offset (allows for 1,048,576 items)</li>
		</ul>
		</li>
	</ul>
	<p>An alternative structure would have the offsets be byte offsets from the 
	start of the table, instead of indexes into the arrays. That would limit the 
	size of the table, but use fewer machine instructions.</p>
	
	<h4>6.10.2 <a name="Sample_Code">Sample Code</a></h4>
	
	<p>The following is a pseudo code using this table for the required operations. 
	Although using Java syntax in general, the code example uses 
	arrays, which are more familiar to users of C and C++. <i>The code is presented for illustration 
	only; it is not a complete statement of the algorithm. </i></p>
	<pre>char[] input;   <span class="codeComment">// input buffer (i)</span>
int inputPos;   <span class="codeComment">// position in input buffer (io)</span>
int[] output;   <span class="codeComment">// output buffer (o)</span>
int outputPos;  <span class="codeComment">// position in output buffer (io)</span>
boolean forwards;   <span class="codeComment">// 0 for forwards, 1 for backwards (i)</span>
    
<span class="codeComment">/**
* Reads characters from input, writes collation elements in output
*/
</span>void getCollationElements() {
    char c = input[inputPos++];
    int ce = collationElements[index[c&gt;&gt;8] + c&amp;0xFF];
    processCE(ce);
}
    
<span class="codeComment">/**
* Normally just returns ce. However, special forms indicate that
* the ce is actually an expansion, or that we have to search
* to see if the character was part of a contraction.
* Expansions use 
*/
</span>void processCE(int ce) {
    if (ce &lt; 0xFFF00000) {
        output[outputPos++] = ce;
    } else if (ce &gt;= 0xFFE00000) {
        copyExpansions(ce &amp; 0x7FFFFF);
    } else {
        searchContractions(ce &amp; 0x7FFFFF);
    }
}
    
<span class="codeComment">/**
* Search through a contraction sublist to see if there is a match.
* Because the list is sorted, we can exit if our value is too high.&lt;p&gt;
* Because we have a length, we could implement this as a
* binary search, although we do not right now.&lt;p&gt;
* If we do find a match, we need to recurse. That&#39;s how &quot;abc&quot; would
* be handled.&lt;p&gt;
* If we fail, we return the non-matching case. That can be an expansion
* itself (it would never be a contraction).
*/
</span>void searchContractions(int offset) {
    if (forwards) inputPos++;
    else offset += input[inputPos++];
    short goal = (short)input[inputPos++];
    int limit = offset + contractionMatches[offset];
    for (int i = offset; i &lt; limit; ++i) {
        short cc = contractionMatches[i];
        if (cc &gt; goal) { <span class="codeComment">// definitely failed</span>
            processCE(contractionCEs[offset]);
            break;
        } else if (cc == goal) { <span class="codeComment">// found match</span>
            processCE(contractionCEs[i]);
            break;
        }
    }
}
    
<span class="codeComment">/**
* Copy the expansion collation elements up to the terminator.
* Do not use 00000000 as a terminator, because that may be a valid CE.
* These elements do not recurse.
*/
</span>void copyExpansions (int offset) {
    int ce = expansions[offset++];
    while (ce != 0xFFFFFFFF) {
        output[outputPos++] = ce;
        ce = expansions[offset++];
    }
}
    
<span class="codeComment">/**
* For random access, gets the start of a collation element.
* Any non-initial characters are in a sorted list, so
* we just check that list.&lt;p&gt;
* Because we have a length, we could implement this as a
* binary search, although we do not right now.
*/
</span>int getCollationElementStart(char[] buffer, int offset) {
    int i;
    main:
    for (i = offset; i &gt; 0; --i) {
        char c = buffer[i];
        for (int j = 0; j &lt; nonInitialsLength; ++j) {
            char n = nonInitials[j];
            if (c == n) continue main;
            if (c &gt; n) break main;
        }
        break;
    }
    return i;
}</pre>
	<h2><a name="Weight_Derivation"></a>7 Weight Derivation</h2>
	<p>This section describes the generation of the Unicode Default Unicode Collation 
	Element Table, and the assignment of weights to code points that are not explicitly 
	mentioned in a Collation Element Table. This uses information from the Unicode 
	Character Database [<a href="tr10-22.html#UAX44">UAX44</a>].</p>
	<h3>7.1 <a name="Derived_Collation_Elements">Derived Collation Elements</a></h3>
	<p>CJK Ideographs and Hangul syllables are not explicitly mentioned in the default 
	table. CJK ideographs are mapped to collation elements that are derived from 
	their Unicode code point value as described in <i>
	Section 7.1.3, <a href="tr10-22.html#Implicit_Weights">Implicit Weights</a></i>.</p>
	<p>The collation algorithm requires that Hangul syllables be decomposed. However, 
	if the table is tailored so that the primary weights for Hangul jamo (and all 
	related characters) are adjusted, then the Hangul syllables can be left as single 
	code points and treated in the same way as CJK ideographs. That will provide 
	a collation which is approximately the same as UCA, and may be sufficient in 
	environments where individual jamo are not expected.</p>
	<p>The adjustment is to move each initial jamo (and related characters) to have 
	a primary weight corresponding to the first syllables starting with that jamo, 
	and make all non-initial jamo (and related characters) be ignorable at a primary 
	level.</p>
	
	<h4><a name="Handling_Illformed">7.1.1 Handling Ill-Formed Code Unit Sequences</a></h4>
	
	<p>Unicode strings sometimes contain ill-formed code unit sequences.
	Such ill-formed sequences must not be interpreted as valid Unicode characters.
	See <i>Section 3.2, Conformance Requirements</i> in [<a href="tr10-22.html#Unicode">Unicode</a>].
	For example, expressed in UTF-32, a Unicode string might contain a 32-bit value
	corresponding to an surrogate code point (General_Category Cs) or an out-of range
	value (&lt; 0 or &gt; 10FFFF), or a UTF-8 string might contain misconverted byte values
	that cannot be interpreted. Implementations of the Unicode Collation Algorithm may
	choose to treat such ill-formed code unit sequences as error conditions and
	respond appropriately, such as by throwing an exception.</p>
	<p>An implementation of the Unicode Collation Algorithm may also 
	choose not to treat ill-formed sequences as an error condition, but instead to give
	them explicit weights. This strategy provides for determinant comparison results
	for Unicode strings, even when they contain ill-formed sequences. However, to avoid security
	issues when using this strategy, ill-formed code sequences should not be
	given an ignorable primary weight. There are 
	two recommended approaches, based on how these ill-formed sequences are typically
	handled by character set converters. The first approach is to weight each maximal ill-formed 
	subsequence as if it were U+FFFD REPLACEMENT CHARACTER. (For more information about maximal ill-formed 
	subsequences, see <i>Section 3.9, Unicode Encoding Forms</i> in [<a href="tr10-22.html#Unicode">Unicode</a>].) 
	A second approach, only applicable to UTF-16 strings, is to generate an implicit weight for 
	any unpaired surrogate code point as if it were an unassigned code point, using the method of 
	<i>Section 7.1.3, <a href="tr10-22.html#Implicit_Weights">Implicit Weights</a></i>.</p>

	<h4><a name="Unassigned_And_Other">7.1.2 Unassigned and Other Code Points</a></h4>
	
	<p>Each unassigned code point and each other code point that is not explicitly mentioned in the table 
	is mapped to a sequence of two collation elements as described in
	<i>Section 7.1.3, <a href="tr10-22.html#Implicit_Weights">Implicit Weights</a></i>.</p>
	
	<h4>7.1.3 <a name="Implicit_Weights">Implicit Weights</a></h4>
	
	<p>This section describes how a code point is mapped to an implicit weight. The result 
	of this process consists of collation elements that are sorted in code point 
	order, that do not collide with any explicit values in the table, and that can 
	be placed anywhere (for example, at BASE) with respect to the explicit collation element mappings. 
	By default, implicit mappings are given higher weights than all explicit collation elements.</p>
	
	<p>To derive the collation elements, the value of the code point is used to calculate two numbers, by bit shifting and bit masking. The bit operations are chosen so that the resultant numbers have the desired ranges for constructing implicit weights. The first number is calculated by taking the code point expressed as a 32-bit binary integer CP and bit shifting it right by 15 bits. Because code points range from U+0000 to U+10FFFF, the result will be a number in the range 0 to 21<sub>16</sub> (= 33<sub>10</sub>). This number is then added to the special value BASE.</p>
    <blockquote>
      <p>AAAA = BASE + (CP &gt;&gt; 15);</p>
    </blockquote>
	<p>Now mask off the bottom 15 bits of CP. OR a 1 into bit 15, so that the resultant value is non-zero.</p>
    <blockquote>
      <p>BBBB = (CP &amp; 0x7FFF) | 0x8000;</p>
    </blockquote>
	<p>AAAA and BBBB are interpreted as unsigned 16-bit integers. The implicit weight mapping given to the code point is then constructed as:</p>
	<blockquote>
	  <p>[.AAAA.0020.0002.][.BBBB.0000.0000.]</p>
  </blockquote>
	<p>If a fourth or higher weights are used, then the same pattern is 
	followed for those weights. They 
	are set to a non-zero value in the first collation element and zero 
	in the second. (Because all distinct code points have a different <b>AAAA/BBBB</b> 
	combination, the exact non-zero value does not matter.)</p>
  <p>The value for BASE depends on the type of character. The first BASE value is for the core Han Unified Ideographs. 
  The second BASE value is for all other Unified Han ideographs. In both of these cases, compatibility 
  decomposibles are excluded, because they are otherwise handled in the UCA. Unassigned code points are also 
  excluded from these first two BASE values. The final BASE value is for all other code points, 
  including unassigned code points.</p>

	<p class="caption"><a name="Values_For_Base_Table"></a>Table 18. Values for Base</p>
	
	<div align="center">
	<table>
		<tr>
			<th>Base</th>
			<th>Applicable Ranges</th>
		</tr>
		<tr>
			<td>FB40</td>
			<td>Unified_Ideograph=True <strong>AND</strong><br>
		    ((Block=CJK_Unified_Ideograph) OR (Block=CJK_Compatibility_Ideographs))
			  <p>In regex notation: 			    
			  <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\p{Block%3DCJK_Unified_Ideographs}\p{Block%3DCJK_Compatibility_Ideographs}-\P{unified_ideograph}]">[\p{unified_ideograph}&amp;[\p{Block=CJK_Unified_Ideographs}\p{Block=CJK_Compatibility_Ideographs}]]</a>
			</p></td>
		</tr>
		<tr>
			<td>FB80</td>
			<td>Unified_Ideograph=True <strong>AND NOT</strong><br>
		    ((Block=CJK_Unified_Ideograph) OR (Block=CJK_Compatibility_Ideographs))
		    <p>In regex notation:
			<a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\p{unified+ideograph}-\p{Block%3DCJK_Unified_Ideographs}-\p{Block%3DCJK_Compatibility_Ideographs}]">[\p{unified ideograph}-[\p{Block=</a><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\p{unified+ideograph}-\p{Block%3DCJK_Unified_Ideographs}-\p{Block%3DCJK_Compatibility_Ideographs}]">CJK_Unified_Ideographs}\p{Block=CJK_Compatibility_Ideographs}]]</a></p></td>
		</tr>
		<tr>
			<td>FBC0</td>
			<td>Any other code point</td>
		</tr>
	</table>
	</div>
	
	<p>These results make AAAA (in each case) larger than any explicit primary weight; 
	thus the implicit weights will not collide with explicit weights. It is not 
	generally necessary to tailor these values to be within the range of explicit 
	weights. However if this is done, the explicit primary weights must be shifted 
	so that none are between each of the BASE values and BASE + 34.</p>
	
	<h4>7.1.4 <a name="Trailing_Weights">Trailing Weights</a></h4>
	
	<p>The range of 1,024 primary weights from FC00 to FFFF is available for use as trailing 
	weights.</p>
		
	<p>In many writing systems, the convention for collation is to
	order by syllables (or other units similar to syllables). In most cases a good
	approximation to syllabic ordering can be obtained in the UCA by weighting initial
	elements of syllables in the appropriate primary order, followed by medial
	elements (such as vowels), followed by final elements, if any. The default
	weights for the UCA in the DUCET are assigned according to this general
	principle for many scripts. This approach handles syllables within a given script
	fairly well, but unexpected results can occur when syllables of different lengths are adjacent
	to characters with higher primary weights, as illustrated in the following
	example:</p>
	
	<div align="center">
		<table class="noborder" cellpadding="4">
			<tr>
				<th width="50%" align="center" class="noborder">Case 1</th>
				<th width="50%" align="center" class="noborder">Case 2</th>
			</tr>
			<tr>
				<td width="50%" class="noborder">
					<table cellpadding="4">
						<tr>
							<th>1</th>
							<td>{G}{A}</td>
						</tr>
						<tr>
							<th>2</th>
							<td>{G}{A}{K}</td>
						</tr>
					</table>
				</td>
				<td width="50%" class="noborder">
					<table cellpadding="4">
						<tr>
							<th>2</th>
							<td>{G}{A}{K}&#x4E8B;</td>
						</tr>
						<tr>
							<th>1</th>
							<td>{G}{A}&#x4E8B;</td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
	</div>
	
	<p>In this example, the symbols {G}, {A}, and {K} represent letters in a script 
	where syllables (or other sequences of characters) are sorted as units. By proper 
	choice of weights for the individual letters, the syllables can be ordered correctly. 
	However, the weights of the following characters may cause syllables of different lengths 
	to change order. Thus {G}{A}{K} comes after {G}{A} in Case 
	1, but in Case 2, it comes <i>before</i>. That is, the order of these two syllables 
	would be reversed when each is followed by a CJK 
	ideograph, with a high primary weight: in this case, U+4E8B (&#x4E8B;).</p>
	
	<p>This unexpected behavior can be avoided by using trailing weights to tailor
	the non-initial letters in such syllables. The trailing weights, by design, have higher
	values than the primary weights for characters in all scripts, including the implicit weights
	used for CJK ideographs. Thus in the example, if {K} is tailored with a trailing weight, it
	would have a higher weight than any CJK ideograph, and as a result, the relative order of
	the two syllables {G}{A}{K} and {G}{A} would not be affected by the presence of a CJK ideograph
	following either syllable.</p>
	
	<h4>7.1.5 <a name="Hangul_Collation">Hangul Collation</a></h4>

	<p>The Hangul script for Korean is in a rather unique position, because of its large number of  
	precomposed syllable characters, and because those precomposed characters are the normal 
	(NFC) form of interchanged text.</p>
	
	<p>The situation for collation of Hangul is even more
	complex when the syllables for Old Korean are taken into account. 
	The general pattern for Korean syllables is of the form 
	L+ V+ T*: that is, one or more leading consonants (L), followed by
	one or more vowels (V), followed optionally by any number of trailing consonants (T). For more information, 
	see <i>Section 3.12, Conjoining Jamo Behavior</i> in [<a href="tr10-22.html#Unicode">Unicode</a>].</p>
	
	<p>For Hangul syllables to sort correctly, either 
	the UCA data must be tailored or the UCA algorithm (and data) must be tailored. 
	The following three methods are possible solutions.</p>
	<p><b>Data Method</b></p>
	<ol>
		<li>Tailor the Vs and Ts to be Trailing Weights, with the ordering T &lt; V</li>
		<li>Tailor each sequence of multiple L&#39;s that occurs in the repertoire as 
		a contraction, with an independent primary weight after any prefix&#39;s weight<ul>
			<li>This means that if L<sub>1</sub> has a primary weight of 555, and 
			L<sub>2</sub> has 559, then L<sub>1</sub>L<sub>2</sub> would have to 
			be given a weight from 556 to 558.</li>
		</ul>
		</li>
	</ol>
	<p><b>Terminator Method</b></p>
	<ol>
		<li>Add an internal terminator primary weight (<font face="Arial Unicode MS">Ⓣ</font>).</li>
		<li>Tailor all jamo so that <font face="Arial Unicode MS">Ⓣ</font> &lt; T &lt; 
		V &lt; L</li>
		<li>Algorithmically add the terminator primary weight (<font face="Arial Unicode MS">Ⓣ</font>) 
		to the end of every standard Hangul syllable.<ul>
			<li>This is done by adding the terminator between any pairs of characters 
			that are not kept together according to the rules of <i>Section 3.12,
			Conjoining Jamo Behavior</i> in [<a href="tr10-22.html#Unicode">Unicode</a>]</li>
		</ul>
		</li>
	</ol>
	<p><b>Interleaving Method</b></p>
	<ol>
		<li>Generate a modified weight table:<ol type="a">
			<li>Assign a weight to each precomposed Hangul syllable character, with 
			a 1-weight gap between each one. (See
			<i>Section 6.2, <a href="tr10-22.html#Large_Weight_Values">Large Weight Values</a></i>)</li>
			<li>Give each jamo a 1-byte internal weight. Also add an internal terminator 
			1-byte weight (<font face="Arial Unicode MS">Ⓣ</font>). These are assigned 
			so that all <font face="Arial Unicode MS">Ⓣ</font> &lt; T &lt;&nbsp; V &lt; L.<ul>
				<li>These weights are separate from the default weights, and are 
				just used internally.</li>
			</ul>
			</li>
		</ol>
		</li>
		<li>When any string of jamo and/or Hangul syllables is encountered, break 
		it into syllables according to the rules of <i>Section 3.12, Conjoining Jamo 
		Behavior</i> of [<a href="tr10-22.html#Unicode">Unicode</a>]. Process each syllable 
		separately:<ol type="a">
			<li>If a syllable is canonically equivalent to one of the precomposed 
			Hangul syllables, then just assign the weight as above</li>
			<li>If not, then find the greatest syllable that it is greater than; 
			call that the base syllable. Generate a weight sequence corresponding 
			to the following gap weight, followed by all the jamo weight bytes, 
			followed by the terminator byte.</li>
		</ol>
		</li>
	</ol>
	<p>Each of these methods can correctly represent the ordering of all modern 
	and ancient Hangul syllables, but there are implementation trade-offs between 
	them. These trade-offs can have a significant impact on the acceptability of 
	the implementation, because substantially longer sort keys will cause significant 
	performance degradations and database index bloat.</p>
	<blockquote>
		<p><b>Note:</b> If the repertoire of supported Hangul syllables is limited 
		to modern syllables (those of the form LV or LVT), then all of these become 
		simpler.</p>
	</blockquote>
	<p>The Data method provides for the following order of weights, where the X<sub>b</sub> 
	are all the scripts sorted before Hangul, and the X<sub>a</sub> are all those 
	sorted after. </p>
	<blockquote>
		<table border="1" style="border-collapse: collapse" cellpadding="2" cellspacing="0">
			<tr>
				<td align="center" width="144" style="text-align: center">X<sub>b</sub></td>
				<td align="center" style="text-align: center">L</td>
				<td align="center" width="144" style="text-align: center">X<sub>a</sub></td>
				<td align="center" style="text-align: center">T</td>
				<td align="center" style="text-align: center">V</td>
			</tr>
		</table>
		<p>This ordering gives the right results among the following:</p>
		<table border="1" cellpadding="2" cellspacing="0">
			<tr>
				<th align="left">Chars</th>
				<th align="left" colspan="4">Weights</th>
				<th align="left">Comments</th>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>a</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>Xa</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">L</font>...</th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font color="#FF0000">W</font><sub><font color="#ff0000">Ln</font></sub></th>
				<th align="left">...</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>b</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font color="#ff0000">W<sub>Xb</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">T<sub>1</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>T1</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>T</sub> &gt; all W<sub>X</sub> and W<sub>L</sub></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">V<sub>1</sub></font><font color="#ff0000">V<sub>2</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left"><font color="#008000">W<sub>V1</sub></font></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>V2</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>V</sub> &gt; all W<sub>T</sub></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">L<sub>2</sub></font>V<sub>1</sub></th>
				<th align="left">W<sub>L1</sub><font color="#008000"><sub>L2</sub></font></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left">&nbsp;</th>
				<th align="left">&nbsp;</th>
				<td>Works <b><i>if</i></b> L<sub>1</sub>L<sub>2</sub> is a contraction</td>
			</tr>
		</table>
	</blockquote>
	<p>The disadvantages of the Data method are that the weights for T and V are 
	separated from those of L, which can cause problems for sort key compression, 
	and that a combination of LL that is outside the contraction table will not 
	sort properly. </p>
	<p>The Terminator method would assign the following weights:</p>
	<blockquote>
		<table border="1" style="border-collapse: collapse" cellpadding="2" cellspacing="0">
			<tr>
				<td align="center" style="text-align: center">
				<font face="Arial Unicode MS">Ⓣ</font></td>
				<td align="center" width="144" style="text-align: center">X<sub>b</sub></td>
				<td align="center" style="text-align: center">T</td>
				<td align="center" style="text-align: center">V</td>
				<td align="center" style="text-align: center">L</td>
				<td align="center" width="144" style="text-align: center">X<sub>a</sub></td>
			</tr>
		</table>
		<p>This ordering gives the right results among the following:</p>
		<table border="1" cellpadding="2" cellspacing="0">
			<tr>
				<th align="left">Chars</th>
				<th align="left" colspan="5">Weights</th>
				<th align="left">Comments</th>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>a</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>Xa</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">L<sub>n</sub></font>...</th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left"><font color="#FF0000">W</font><sub><font color="#ff0000">Ln</font></sub></th>
				<th align="left">...</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>b</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left"><font color="#ff0000">W<sub>Xb</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">T<sub>1</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>T1</sub></font></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>T</sub> &gt; all W<sub>X</sub> and
				<font face="Arial Unicode MS">Ⓣ</font></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">V<sub>1</sub></font><font color="#ff0000">V<sub>2</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left"><font color="#008000">W<sub>V1</sub></font></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>V2</sub></font></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>V</sub> &gt; all W<sub>T</sub></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">L<sub>2</sub></font>V<sub>1</sub></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left"><font color="#008000">W<sub>L2</sub></font></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>L</sub> &gt; all W<sub>V</sub></td>
			</tr>
		</table>
	</blockquote>
	<p>The disadvantages of the Terminator method are that an extra weight is added 
	to all Hangul syllables, increasing the length of sort keys by roughly 40%, 
	and the fact that the terminator weight is non-contiguous can disable sort key 
	compression.</p>
	<p>The Interleaving method provides for the following assignment of weights. 
	W<sub>n</sub> represents the weight of a Hangul syllable, and W<sub>n&#39;</sub> 
	is the weight of the gap right after it. The L, V, T weights will only occur 
	after a W, and thus can be considered part of an entire weight.</p>
	<blockquote>
		<table border="1" style="border-collapse: collapse" cellpadding="2" cellspacing="0">
			<tr>
				<td align="center" width="144" style="text-align: center">X<sub>b</sub></td>
				<td align="center" style="text-align: center">W</td>
				<td align="center" width="144" style="text-align: center">X<sub>a</sub></td>
			</tr>
		</table>
		<p><font face="Arial Unicode MS">byte weights: </font></p>
		<table border="1" style="border-collapse: collapse" cellpadding="2" cellspacing="0">
			<tr>
				<td align="center" style="text-align: center">
				<font face="Arial Unicode MS">Ⓣ</font></td>
				<td align="center" style="text-align: center">T</td>
				<td align="center" style="text-align: center">V</td>
				<td align="center" style="text-align: center">L</td>
			</tr>
		</table>
		<p>This ordering gives the right results among the following:</p>
		<table border="1" cellpadding="2" cellspacing="0">
			<tr>
				<th align="left">Chars</th>
				<th align="left" colspan="3">Weights</th>
				<th align="left">Comments</th>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>a</sub></font></th>
				<th align="left">W<sub>n</sub></th>
				<th align="left"><font color="#ff0000">X<sub>a</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">L<sub>n</sub></font>...</th>
				<th align="left">W<sub>n</sub></th>
				<th align="left"><font color="#FF0000">W<sub>k</sub></font></th>
				<th align="left">...</th>
				<td>The L<sub>n</sub> will start another syllable</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>b</sub></font></th>
				<th align="left">W<sub>n</sub></th>
				<th align="left"><font color="#ff0000">X<sub>b</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">T<sub>1</sub></font></th>
				<th align="left">W<sub>m</sub></th>
				<th align="left">&nbsp;</th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>m</sub> &gt; W<sub>n</sub></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">V<sub>1</sub></font><font color="#ff0000">V<sub>2</sub></font></th>
				<th align="left">W<sub>m&#39;L1</sub><font color="#008000"><sub>V1</sub></font><font color="#ff0000"><sub>V2</sub></font><sub><font face="Arial Unicode MS">Ⓣ</font></sub></th>
				<th align="left">&nbsp;</th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>m&#39;</sub>&gt;W<sub>m</sub></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">L<sub>2</sub></font>V<sub>1</sub></th>
				<th align="left">W<sub>m&#39;L1</sub><font color="#008000"><sub>L2</sub></font><sub>V1<font face="Arial Unicode MS">Ⓣ</font></sub></th>
				<th align="left">&nbsp;</th>
				<th align="left">&nbsp;</th>
				<td>Works because the byte weight for <font color="#008000">
				<sub>L2</sub></font> &gt; all <font color="#008000"><sub>V</sub></font></td>
			</tr>
		</table>
	</blockquote>
	<p>The Interleaving method is somewhat more complex than the others, but produces 
	the shortest sort keys for all of the precomposed Hangul syllables, so for normal 
	text it will have the shortest sort keys. If there were a large percentage of 
	ancient Hangul syllables, the sort keys would be longer than other methods.</p>
	<blockquote>
	<p><b>Note:</b> The Unicode Consortium recognizes that one of these solutions 
	should be implemented in the standard UCA algorithm and tables, but is attempting 
	to work out a common approach to the problem with the ISO SC2 OWG-SORT group, which 
	takes considerable time. In the meantime, one of these approaches can be used 
	for correct ordering.</p>
	</blockquote>
	
	<h3>7.2 <a name="Tertiary_Weight_Table">Tertiary Weight Table</a></h3>
	<p>Characters are given tertiary weights according to <i>Table 19</i>. The 
	Decomposition Type is from the Unicode Character Database [<a href="tr10-22.html#UAX44">UAX44</a>]. 
	The Case or Kana Subtype entry refers either to a case
	distinction or to a specific list 
	of characters. The weights are from MIN = 2 to MAX = 1F<sub>16</sub>, excluding 
	7, which is not used for historical reasons. The Samples show some minimal values 
	that are distinguished by the different weights. All values are distinguished. 
The samples have empty cells when there are no (visible) values showing a distinction.</p>

	<p class="caption"><a name="Tertiary_Assignments_Table"></a>Table 19. Tertiary Weight Assignments</p>

	<div align="center">
		<table cellpadding="2">
			<tr>
				<th>Decomposition Type</th>
				<th>Case or Kana Subtype</th>
				<th>Weight</th>
				<th colspan="6" style="text-align: center">Samples</th>
			</tr>
			<tr>
				<td><code>&nbsp;NONE</code></td>
				<td>&nbsp;</td>
				<td><code>0x0002</code></td>
				<td>i</td>
				<td>ب</td>
				<td>)</td>
				<td>mw</td>
				<td>1⁄2</td>
				<td><b><i>X</i></b></td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;wide&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0003</code></td>
				<td>ｉ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;compat&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0004</code></td>
				<td>ⅰ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;font&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0005</code></td>
				<td>ℹ </td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;circle&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0006</code></td>
				<td>ⓘ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td class="unused"><code>!unused!</code></td>
				<td class="unused">&nbsp;</td>
				<td class="unused"><code>0x0007</code></td>
				<td class="unused">&nbsp;</td>
				<td class="unused">&nbsp;</td>
				<td class="unused">&nbsp;</td>
				<td class="unused">&nbsp;</td>
				<td class="unused">&nbsp;</td>
				<td class="unused">&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;NONE</code></td>
				<td>Uppercase</td>
				<td><code>0x0008</code></td>
				<td>I</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>MW</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;wide&gt;</code></td>
				<td>Uppercase</td>
				<td><code>0x0009</code></td>
				<td>Ｉ</td>
				<td>&nbsp;</td>
				<td>）</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;compat&gt;</code></td>
				<td>Uppercase</td>
				<td><code>0x000A</code></td>
				<td>Ⅰ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;font&gt;</code></td>
				<td>Uppercase</td>
				<td><code>0x000B</code></td>
				<td>ℑ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;circle&gt;</code></td>
				<td>Uppercase</td>
				<td><code>0x000C</code></td>
				<td>Ⓘ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;small&gt;</code></td>
				<td>small hiragana (3041, 3043, ...)</td>
				<td><code>0x000D</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>ぁ</td>
			</tr>
			<tr>
				<td><code>&nbsp;NONE</code></td>
				<td>normal hiragana (3042, 3044, ...)</td>
				<td><code>0x000E</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>あ</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;small&gt;</code></td>
				<td>small katakana (30A1, 30A3, ...)</td>
				<td><code>0x000F</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>﹚</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>ァ</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;narrow&gt;</code></td>
				<td>small narrow katakana (FF67..FF6F)</td>
				<td><code>0x0010</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>ｧ</td>
			</tr>
			<tr>
				<td><code>&nbsp;NONE</code></td>
				<td>normal katakana (30A2, 30A4, ...)</td>
				<td><code>0x0011</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>ア</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;narrow&gt;</code></td>
				<td>narrow katakana (FF71..FF9D),<br>
				narrow hangul (FFA0..FFDF)</td>
				<td><code>0x0012</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>ｱ</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;circle&gt;</code></td>
				<td>circled katakana (32D0..32FE)</td>
				<td><code>0x0013</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>㋐</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;super&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0014</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>⁾</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;sub&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0015</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>₎</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;vertical&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0016</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>︶</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;initial&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0017</code></td>
				<td>&nbsp;</td>
				<td>ﺑ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;medial&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0018</code></td>
				<td>&nbsp;</td>
				<td>ﺒ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;final&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0019</code></td>
				<td>&nbsp;</td>
				<td>ﺐ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;isolated&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x001A</code></td>
				<td>&nbsp;</td>
				<td>ﺏ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;noBreak&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x001B</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;square&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x001C</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>㎽</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;square&gt;, &lt;super&gt;, &lt;sub&gt; </code></td>
				<td>Uppercase</td>
				<td><code>0x001D</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>㎿</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;fraction&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x001E</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>½</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;n/a</code></td>
				<td>&nbsp;(MAX value)</td>
				<td><code>0x001F</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
		</table>
		</div>
		
	<p>&nbsp;</p>
	
	<h2><a name="Searching"></a>8 Searching and Matching</h2>
	
	<p>Language-sensitive searching and matching are closely related to collation. 
	Strings that compare as equal at some strength level should be 
	matched when doing language-sensitive matching. For example, at a primary strength, 
	&quot;ß&quot; would match against &quot;ss&quot; according to the UCA, and &quot;aa&quot; would match &quot;å&quot; 
	in a Danish tailoring of the UCA. The main difference from the collation comparison 
	operation is that the ordering is not important. Thus for matching it does not 
	matter that &quot;å&quot; would sort after &quot;z&quot; in a Danish 
	tailoring&#x2014;the only relevant information is that they do not match.</p>
	<p>The basic operation is matching: determining whether string X matches string 
	Y. Other operations are built on this:</p>
	<ul>
		<li>Y contains X when there is some substring of Y that matches X</li>
		<li>A search for a string X in a string Y succeeds if Y contains X.</li>
		<li>Y starts with X when some initial substring of Y matches X</li>
		<li>Y ends with X when some final substring of Y matches X</li>
	</ul>
	<p>The collation settings determine the results of the matching operation (see
	<i>Section 5.1, <a href="tr10-22.html#Parametic_Tailoring">Parametric Tailoring</a></i>). 
	Thus users of searching and matching need to be able to modify parameters such 
	as locale or comparison strength. For example, setting the strength to exclude 
	differences at Level 3 has the effect of ignoring case and compatibility format 
	distinctions between letters when matching. Excluding differences at Level 2 
	has the effect of also ignoring accentual distinctions when matching.</p>
	<p>Conceptually, a string matches some target where a substring of the target 
	has the same sort key, but there are a number of complications:</p>
	<ol>
		<li>The lengths of matching strings may differ: &quot;aa&quot; and &quot;å&quot; 
		would match in Danish.</li>
		<li>Because of ignorables (at different levels), there 
		are different possible positions where a string matches, depending on the 
		attribute settings of the collation. For example, if hyphens are ignorable 
		for a certain collation, then &quot;abc&quot; will match &quot;abc&quot;, &quot;abc-&quot;, &quot;-abc-&quot;, and 
		so on.</li>
		<li>Suppose that the collator has contractions, and that a contraction spans 
		the boundary of the match. Whether it is considered a match may depend 
		on user settings, just as users are given a &quot;Whole Words&quot; option in searching. 
		So in a language where &quot;ch&quot; is a contraction, &quot;bac&quot; would not match in &quot;bach&quot; 
		(given the proper user setting).</li>
		<li>Similarly, combining character sequences may need to be taken into account. 
		Users may not want a search for &quot;abc&quot; to match in &quot;...abç...&quot; 
		(with a cedilla on the c). However, this may also depend on language and 
		user customization.</li>
		<li>The above two conditions can be considered part of a 
		general condition: &quot;Whole Characters Only&quot;; very similar to the common &quot;Whole 
		Words Only&quot; checkbox that is included in most search dialog boxes. 
		(For more information on grapheme clusters, see [<a href="tr10-22.html#UTS18">UTS18</a>].)</li>
		<li>If the matching does not check for &quot;Whole
		Characters Only,&quot; 
		then some other complications may occur. For example, suppose that P is 
		&quot;x^&quot;, and Q is &quot;x ^¸&quot;. Because the 
		cedilla and circumflex can be written in arbitrary order and still be equivalent, 
		one would expect to find a match for P in Q. A canonically-equivalent matching 
		process requires special processing at the boundaries to check for situations 
		like this. (It does not require such special processing within the P or 
		the substring of Q because collation is defined to observe canonical equivalence.)</li>
	</ol>
	<p>The following are used to provide a clear definition of searching and matching 
	that deal with the above complications:</p>
	<p><b><a name="DS1"></a>DS1. </b>Define <i>S[start,end]</i> to be the substring of S that includes 
	the character after the offset <i>start</i> up to the character before offset
	<i>end</i>. For example, if S is &quot;abcd&quot;, then S[1,3] is &quot;bc&quot;. Thus S = S[0,length(S)].</p>
	<p><b><a name="DS1a"></a>DS1a. </b>A boundary condition is a test imposed on an offset within a 
	string. An example includes Whole Word Search, as defined in 
	[<a href="tr10-22.html#UAX29">UAX29</a>].</p>
	<p>The tailoring parameter <i>match-boundaries</i> specifies constraints on 
	matching (see <i>Section 5.1, <a href="tr10-22.html#Parametic_Tailoring">Parametric Tailoring</a></i>). 
	The parameter <i>match-boundaries=whole-character</i> requires that the start 
	and end of a match each be on a grapheme boundary. The value <i>match-boundaries=whole-character</i> 
	further requires that the start and end of a match each be on a word boundary 
	as well. For more information on the specification of these boundaries, see 
	[<a href="tr10-22.html#UAX29">UAX29</a>].</p>
	<p>By using grapheme-complete conditions, contractions and combining sequences 
	are not interrupted. This also avoids the need to present visually discontiguous 
	selections to the user (except for BIDI text).</p>
	<p>Suppose there is a collation C, a pattern string P and a target string Q, 
	and a boundary condition B. C has some particular set of attributes, such as 
	a strength setting, and choice of variable weighting.</p>
	<p><b><a name="DS2"></a>DS2.</b> The pattern string<b> </b>P <i>has a match at Q[s,e] according 
	to collation C</i> if C generates the same sort key for P as for Q[s,e], and 
	the offsets <i>s</i> and <i>e</i> meet the boundary condition B. 
	One can also say P has a match in Q according to C.</p>
	<p><b><a name="DS3"></a>DS3. </b>The pattern string<b> </b>P has a <i>canonical</i> match at Q[s,e] 
	according to collation C if there is some Q&#39; that is canonically equivalent 
	to Q[<i>s,e</i>], and P has a match in Q&#39;.</p>
	<blockquote>
		<p>For example, suppose that P is &quot;Å&quot;, and Q is &quot;...A◌̥◌̊...&quot;. There would 
		not be a match for P in Q, but there would be a canonical match, because 
		P does have a match in &quot;A◌̊◌̥&quot;, which is canonically equivalent to &quot;A◌̥◌̊&quot;. 
		However, it is not commonly necessary to use canonical matches, so this 
		definition is only supplied for completeness.</p>
	</blockquote>
	<p>Each of the following definitions is a qualification of DS2 or DS3:</p>
	<p><b><a name="DS3a"></a>DS3a. </b>The match is <i>grapheme-complete</i> 
	if B requires that the offset be at a grapheme cluster boundary. Note that Whole 
	Word Search as defined in [<a href="tr10-22.html#UAX29">UAX29</a>] is grapheme complete.</p>
	<p><b><a name="DS4"></a>DS4. </b>The match is <i>minimal</i> if there is no match at Q[<i>s+i,e-j</i>] 
	for any <i>i</i> and <i>j such that i ≥ 
	0, j</i> ≥ 0, and <i>i</i> + <i>j</i> &gt; 
	0. In such a case, one can also say that P has a <i>minimal</i> match <i>at</i> Q[<i>s,e</i>].</p>
	<p><b><a name="DS4a"></a>DS4a. </b>The match is <i>medial</i> when it is contained in the maximal 
	match, contains the minimal match, and is extended beyond the minimal match 
	whenever there is a successive binary match between the extra characters in 
	pattern and target.</p>
	<p><b><a name="DS4b"></a>DS4b. </b>The match is <i>maximal</i> if there is no match at Q[<i>s-i,e+j</i>] 
	for any <i>i</i> and <i>j such that i ≥ 
	0, j</i> ≥ 0, and <i>i</i> + <i>j</i> &gt; 
	0. In such a case, one can also say that P has a <i>maximal</i> match <i>at</i> Q[<i>s,e</i>].</p>
	<p><i>Figure 5</i> illustrates the differences between these type of matches, 
	where the collation strength is set to ignore punctuation and case, and <u><span class="marked">format</span></u>
	indicates the match.</p>
	
	<p class="caption"><a name="Matches_Table"></a>Figure 5. Minimal, Medial, and Maximal Matches</p>

	<div align="center">	
	<table cellpadding="2">
		<tr>
			<th style="text-align: right" nowrap>&nbsp;</th>
			<th nowrap>Text</th>
			<th>Description</th>
		</tr>
		<tr>
			<th style="text-align: right" nowrap>Pattern</th>
			<td nowrap>*!abc!*</td>
			<td>Notice that the *! and !* are ignored in matching.</td>
		</tr>
		<tr>
			<th style="text-align: right" nowrap>Target Text</th>
			<td nowrap>def$!Abc%$ghi</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<th style="text-align: right" nowrap>Minimal Match</th>
			<td nowrap>def$!<u><span class="marked">Abc</span></u>%$ghi</td>
			<td>The minimal match is the tightest one, because $! and %$ are ignored 
			in the target.</td>
		</tr>
		<tr>
			<th style="text-align: right" nowrap>Medial Match</th>
			<td nowrap>def$<u><span class="marked">!Abc</span></u>%$ghi</td>
			<td>The medial one includes those characters that are binary equal.</td>
		</tr>
		<tr>
			<th style="text-align: right" nowrap>Maximal Match</th>
			<td nowrap>def<u><span class="marked">$!Abc%$</span></u>ghi</td>
			<td>The maximal match is the loosest one, including the surrounding 
			ignored characters.</td>
		</tr>
	</table>
	</div>
	
	<p>By using minimal, maximal, or medial matches, the issue with ignorables is 
	avoided. Medial matches tend to match user expectations the best.</p>
	<p>When an additional condition is set on the match, the types (minimal, maximal, 
	medial) are based on the matches <i>that meet that condition.</i> Consider 
	the example in <i>Figure 6</i>.</p>

	<p class="caption"><a name="Alternate_Matches_Table"></a>Figure 6. Alternate End Points for Matches</p>

	<div align="center">	
	<table cellpadding="2">
		<tr>
			<th>&nbsp;</th>
			<th>Value</th>
			<th>Notes</th>
		</tr>
		<tr>
			<th>Pattern</th>
			<td>abc</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<th>Strength</th>
			<td><i>primary</i></td>
			<td>thus ignoring combining marks, punctuation</td>
		</tr>
		<tr>
			<th>Text</th>
			<td>abc¸-°d</td>
			<td>two combining marks, cedilla and ring</td>
		</tr>
		<tr>
			<th>Matches</th>
			<td>|abc|¸|-|°|d</td>
			<td>four possible end points, indicated by |</td>
		</tr>
	</table>
	</div>
	
	<p>If, for example, the condition is Whole Grapheme, then the matches are restricted 
	to &quot;abc¸|-°|d&quot;, thus discarding match positions that would not 
	be on a grapheme cluster boundary. In
	this case the minimal match would be &quot;abc¸|-°d&quot;</p>

	<p><b><a name="DS6"></a>DS6.</b> The <i>first forward match</i> for P in Q starting at <i>b</i> 
	is the least offset <i>s</i> greater than or equal to <i>b</i> such that for 
	some <i>e</i>, P matches within Q[s,e].</p>
	
	<p><b><a name="DS7"></a>DS7.</b> The <i>first backward match</i> for P in Q starting at <i>b</i> 
	is the greatest offset <i>s</i> less than or equal to <i>b</i> such that for 
	some <i>e</i>, P matches within Q[s,e].</p>
	<p>In DS6 and DS7, matches can be minimal, medial, or maximal; the only requirement 
	is that the combination in use in DS6 and DS7 be specified. Of course, a possible 
	match can also be rejected on the basis of other conditions, such as being grapheme-complete 
	or applying Whole Word Search, as described in [<a href="tr10-22.html#UAX29">UAX29</a>]).</p>
	<p>The choice of medial or minimal matches for the &quot;starts with&quot; or &quot;ends with&quot; 
	operations only affects the positioning information for the end of the match 
	or start of the match, respectively.</p>
	<p><b>Special Cases.</b> Ideally, the UCA at a secondary level would be compatible 
	with the standard Unicode case folding and removal of compatibility differences, 
	especially for the purpose of matching. For the vast majority of characters, 
	it is compatible, but there are the following exceptions:</p>
	<ol>
		<li>The UCA maintains compatibility with the DIN standard for sorting German 
		by having the German <i>sharp-s</i> (U+00DF (ß) LATIN SMALL LETTER SHARP 
		S) sort as a secondary difference with &quot;SS&quot;, instead of having ß and SS 
		match at the secondary level.</li>
		<li>Compatibility normalization (NFKC) folds stand-alone accents to a combination 
		of space + combining accent. This was not the best approach, but for backwards 
		compatibility cannot be changed in NFKC. UCA takes a better approach to 
		weighting stand-alone accents, but as a result does not weight them exactly 
		the same as their compatibility decompositions.</li>
		<li>Case folding maps <i>iota-subscript</i> (U+0345 (ͅ) COMBINING GREEK 
		YPOGEGRAMMENI) to an iota, due to the special behavior of iota-subscript, 
		while the UCA treats <i>iota-subscript</i> as a regular combining mark (secondary 
		ignorable).</li>
		<li>When compared to their case and compatibility folded values, UCA compares 
		the following as different at a secondary level, whereas other compatibility 
		differences are at a tertiary level.<ul>
			<li>U+017F (ſ) LATIN SMALL LETTER LONG S (and precomposed characters 
			containing it)</li>
			<li>U+1D4C (ᵌ) MODIFIER LETTER SMALL TURNED OPEN E</li>
			<li>U+2D6F (ⵯ) TIFINAGH MODIFIER LETTER LABIALIZATION MARK</li>
		</ul>
		</li>
	</ol>
	<p>In practice, most of these differences are not important for modern text, 
	with one exception: the German ß. Implementations should consider tailoring 
	ß to have a tertiary difference from SS, at least when collation tables are 
	used for matching. Where full compatibility with case and compatibility folding 
	are required, either the text can be preprocessed, or the UCA tables can be 
	tailored to handle the outlying cases.</p>
	
	<h3>8.1 <a name="Collation_Folding">Collation Folding</a></h3>
	
	<p>Matching can be done by using the collation elements, directly, as discussed 
	above. However, because matching does not use any of the ordering information, 
	the same result can be achieved by a folding. That is, two strings would fold 
	to the same string if and only if they would match according to the (tailored) 
	collation. For example, a folding for a Danish collation would map both &quot;Gård&quot; 
	and &quot;gaard&quot; to the same value. A folding for a primary-strength folding would 
	map &quot;Resume&quot; and &quot;résumé&quot; to the same value. That folded value is typically 
	a lowercase string, such as &quot;resume&quot;.</p>
	<p>A comparison between folded strings cannot be used for an ordering of strings, 
	but it can be applied to searching and matching quite effectively. The data 
	for the folding can be smaller, because the ordering information does not need 
	to be included. The folded strings are typically much shorter than a sort key, 
	and are human-readable, unlike the sort key. The processing necessary to produce 
	the folding string can also be faster than that used to create the sort key.</p>
	<p>The following is an example of the mappings used for such a folding using 
	to the [<a href="tr10-22.html#CLDR">CLDR</a>] tailoring of UCA:</p>
	<p><b>Parameters:</b></p>
	<blockquote>
		<p>{locale=da_DK, strength=secondary, alternate=shifted}</p>
	</blockquote>
	<p><b>Mapping:</b></p>
	<blockquote>
		<table border="1" id="table12" class="noborder" cellspacing="0" cellpadding="3">
			<tr>
				<td colspan="4" class="noborder">...</td>
			</tr>
			<tr>
				<td class="noborder">ª</td>
				<td class="noborder">→</td>
				<td class="noborder">a</td>
				<td rowspan="5" class="noborder">Map compatibility (tertiary) equivalents, 
				such as full-width and superscript characters, to representative 
				character(s)</td>
			</tr>
			<tr>
				<td class="noborder">ａ</td>
				<td class="noborder">→</td>
				<td class="noborder">a</td>
			</tr>
			<tr>
				<td class="noborder">A </td>
				<td class="noborder">→</td>
				<td class="noborder">a</td>
			</tr>
			<tr>
				<td class="noborder">Ａ </td>
				<td class="noborder">→</td>
				<td class="noborder">a</td>
			</tr>
			<tr>
				<td class="noborder">ª</td>
				<td class="noborder">→</td>
				<td class="noborder">a</td>
			</tr>
			<tr>
				<td colspan="4" class="noborder">...</td>
			</tr>
			<tr>
				<td class="noborder">å</td>
				<td class="noborder">→</td>
				<td class="noborder">aa</td>
				<td rowspan="2" class="noborder">Map contractions (a + ring above) 
				to equivalent values</td>
			</tr>
			<tr>
				<td class="noborder">Å</td>
				<td class="noborder">→</td>
				<td class="noborder">aa</td>
			</tr>
			<tr>
				<td colspan="4" class="noborder">...</td>
			</tr>
		</table>
	</blockquote>
	<p>Once the table of such mappings is generated, the folding process is a simple 
	longest-first match-and-replace: a string to be folded is first converted to 
	NFD, then at each point in the string, the longest match from the table is replaced 
	by the corresponding result.</p>
	<p>However, ignorable characters need special handling. Characters that are 
	fully ignorable at a given strength level level normally map to the empty string. 
	For example, at <i>strength=quaternary</i>, most controls and format characters 
	map to the empty string; at <i>strength=primary</i>, most combining marks also 
	map to the empty string. In some contexts, however, fully ignorable characters 
	may have an effect on comparison, or characters that are not ignorable at the 
	given strength level may be treated as ignorable.</p>
	<ol>
		<li>Any discontiguous contractions need to be detected in the process of 
		folding and handled according to Rule <a href="tr10-22.html#S2.1">S2.1</a>. For more 
		information about discontiguous contractions, see <i>Section 3.3.2,
		<a href="tr10-22.html#Contractions">Contractions</a>.</i></li>
		<li>An ignorable character may interrupt what would otherwise be a contraction. 
		For example, suppose that &quot;ch&quot; is a contraction sorting after &quot;h&quot;, as in 
		Slovak. In the absence of special tailoring, a CGJ or SHY between the &quot;c&quot; 
		and the &quot;h&quot; prevents the contraction from being formed, and causes &quot;c&lt;CGJ&gt;h&quot; 
		to not compare as equal to &quot;ch&quot;. If the CGJ is simply folded away, they 
		would incorrectly compare as equal. See also <i>Section 5.3,
		<a href="tr10-22.html#Combining_Grapheme_Joiner">Use of Combining Grapheme Joiner</a></i>.</li>
		<li>With the parameter values <i>alternate=shifted</i> or <i>alternate=blanked</i>, 
		any (partially) ignorable characters after variable collation elements have their weights 
		reset to zero at levels 1 to 3, and may thus become fully ignorable. In 
		that context, they would also be mapped to the empty string. For more information, 
		see <i>Section 3.6.2, <a href="tr10-22.html#Variable_Weighting">Variable Weighting</a>.</i></li>
	</ol>
	
	<h2><a name="Data_Files"></a>9 Data Files</h2>
	
	<p>The data files for each version of UCA are located in 
	versioned subdirectories in [<a href="tr10-22.html#Data10">Data10</a>]. The
	main data file with the DUCET data for each version is "allkeys.txt"
	[<a href="tr10-22.html#Allkeys">Allkeys</a>].</p>
	
	<p>Starting with Version 3.1.1 of UCA, the data directory
	also contains a zipped file containing conformance tests. The documentation
	file CollationTest.html describes the format and use of those tests.
	See [<a href="tr10-22.html#Tests10">Tests10</a>]</p>
	
	<p>Starting with Version 6.0.0 of UCA, additional data files are also 
	available in the data directory. For a description of the purpose and format 
	of each file, see the ReadMe.txt file in [<a href="tr10-22.html#Data10">Data10</a>].</p>
	
  <h2>Appendix A: <a name="Deterministic_Sorting">Deterministic Sorting</a></h2>
  
	<p>There is often a good deal of confusion about what is meant by the terms 
	&quot;stable&quot; or &quot;deterministic&quot; when applied to sorting or comparison. This confusion 
	in terms often leads people to make mistakes in their software architecture, 
	or make choices of language-sensitive comparison options that have significant 
	impact in terms of performance and footprint, and yet do not give the results 
	that users expect.</p>
	
	<h3>A.1 <a name="Stable_Sort">Stable Sort</a></h3>
	
	<p>A stable sort is one where two records will retain their order when sorted 
	according to a particular field, even when the two fields have the same contents. 
	Thus those two records come out in the same relative order that they were in 
	before sorting, although their positions relative to other records may change. 
	Importantly, this is a property of the sort algorithm, <i>not</i> the comparison 
	mechanism.</p>
	<p>Two examples of differing sort algorithms are Quicksort and Merge sort.
	Quicksort is not stable while Merge sort is stable. 
	(A Bubble sort, as typically implemented, is also stable.)</p>
	<ul>
		<li>For background on the names and characteristics of different sorting 
		methods, see [<a href="tr10-22.html#SortAlg">SortAlg</a>] </li>
		<li>For a definition of stable sorting, see [<a href="tr10-22.html#Unstable">Unstable</a>]
		</li>
	</ul>
	
	<p>Assume the following records:</p>
	
	<p class="caption"><a name="Original_Records_Table"></a>Original Records</p>
	
	<div align="center">
		<table cellpadding="4">
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td><font color="#00ff00">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
			<tr>
				<td><font color="#00ff00">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
		</table>
	</div>
		
	<p>The results of a Merge sort on the Last_Name field only are:</p>
	
	<p class="caption"><a name="Merge_Results_Table"></a>Merge Sort Results</p>

	<div align="center">
		<table cellpadding="4">
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
			<tr>
				<td><font color="#00ff00">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
			<tr>
				<td><font color="#00ff00">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
		</table>
	</div>
	
	<p>The results of a Quicksort on the Last_Name field only are:</p>
	
	<p class="caption"><a name="Quicksort_Results_Table"></a>Quicksort Results</p>

	<div align="center">
		<table  cellpadding="4">
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
			<tr>
				<td><font color="#ff0000">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
			<tr>
				<td><font color="#ff0000">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
		</table>
	</div>
	
	<p>As is apparent, the Quicksort algorithm is not stable; records 
	1 and 2 are not in the same order they were in before sorting.</p>
	
	<p>A stable sort is often desirable&#x2014;for one thing, it allows records to be successively 
	sorted according to different fields, and to retain the correct lexicographic order. 
	Thus, with a stable sort, one could sort all the records by First_Name, and then sort 
	them again by Last_Name, giving the desired results: that all records would 
	be ordered by Last_Name, and in the case where the Last_Name values are 
	the same, be further subordered by First_Name.</p>
	
	<h3>A.2 <a name="Deterministic_Sort">Deterministic Sort</a></h3>
	
	<p>A <i>deterministic</i> sort is a very different beast. This is a sort algorithm 
	that returns the same results each time. On the face of it, it would seem odd 
	for any sort algorithm to <i>not</i> be deterministic, but there are examples 
	of real-world sort algorithms that are not.</p>
	<p>The key concept is that these sort algorithms <i>are</i> deterministic when 
	two records have unequal fields, but they may return different results at different 
	times when two records have equal fields.</p>
	
	<p>For example, a classic Quicksort algorithm works recursively on ranges of 
	records. For any given range of records, it takes the first element as the
	<i>pivot element</i>. However, that 
	algorithm performs badly with input data that happens to be already sorted (or mostly 
	sorted). A randomized Quicksort, which picks a random element as the pivot, can on average be faster. 
	Because of this random selection, different outputs can result from
	<i>exactly</i> the same input: the algorithm is not deterministic.</p>
	
	<p class="caption"><a name="Enhanced_Quicksort_Results_Table"></a>Enhanced Quicksort Results</p>
	
	<div align="center">
		<table class="noborder" cellpadding="4" border="0">
			<tr>
				<td class="noborder">
				<table cellpadding="4">
					<tr>
						<th>Record</th>
						<th>Last_Name</th>
						<th>First_Name</th>
					</tr>
					<tr>
						<td>3</td>
						<td>Curtner</td>
						<td>Fred</td>
					</tr>
					<tr>
						<td><font color="#ff0000">2</font></td>
						<td>Davis</td>
						<td>John</td>
					</tr>
					<tr>
						<td><font color="#ff0000">1</font></td>
						<td>Davis</td>
						<td>Mark</td>
					</tr>
				</table>
				</td>
				<td class="noborder">
				<p align="center">or</p>
				</td>
				<td class="noborder">
				<table cellpadding="4">
					<tr>
						<th>Record</th>
						<th>Last_Name</th>
						<th>First_Name</th>
					</tr>
					<tr>
						<td>3</td>
						<td>Curtner</td>
						<td>Fred</td>
					</tr>
					<tr>
						<td><font color="#00ff00">1</font></td>
						<td>Davis</td>
						<td>Mark</td>
					</tr>
					<tr>
						<td><font color="#00ff00">2</font></td>
						<td>Davis</td>
						<td>John</td>
					</tr>
				</table>
				</td>
			</tr>
		</table>
	</div>
	
	<p>As another example, multiprocessor sort algorithms can be non-deterministic. 
	The work of sorting different blocks of data is farmed out to different processors 
	and then merged back together. The ordering of records with equal fields might 
	be different according to when different processors finish different tasks.</p>
	<p>Note that a deterministic sort is weaker than a stable sort. A stable sort 
	is always deterministic, but not vice versa. Typically, when people say they 
	want a deterministic sort, they really mean that they want a stable sort.</p>
	
	<h3>A.3 <a name="Deterministic_Comparison">Deterministic Comparison</a></h3>
	
	<p>A <i>deterministic comparison</i> is different than either 
	a stable sort or a deterministic sort; 
	it is a property of a comparison function, not a sort algorithm. This 
	is a comparison where strings that do not have identical binary contents (optionally, 
	after some process of normalization) will compare as unequal. A deterministic 
	comparison is sometimes called a <i>stable</i> (or <i>semi-stable</i>) <i>comparison</i>.</p>
	<p>There are many people who confuse a deterministic comparison with a deterministic 
	(or stable) sort, but this ignores the fundamental difference between a comparison and a sort. 
	A comparison is used by a sort algorithm to determine the relative ordering 
	of two fields, such as strings. Using a deterministic comparison cannot 
	cause a sort to be deterministic, nor to be stable. Whether a sort is deterministic 
	or stable is a property of the sort algorithm, not the comparison function, as the
	prior examples show.</p>
	
	<h4>A.3.1 <a name="Forcing_Deterministic_Comparisons">Forcing Deterministic Comparisons</a></h4>
	
	<p>One can produce a deterministic comparison function from a non-deterministic 
	one, in the following way (in pseudo-code):</p>
	
	<pre>int new_compare (String a, String b) {
  int result = old_compare(a, b);
  if (result == 0) {
    result = binary_compare(a, b);
  }
  return result;
}</pre>

	<p>Programs typically also provide the facility to generate a <i>sort key</i>, 
	which is a sequences of bytes generated from a string in alignment with a comparison 
	function. Two sort keys will binary-compare in the same order as their original 
	strings. The simplest means to create a deterministic sort key that aligns with the above
	<code>new_compare</code> is to append a copy of the original 
	string to the sort key. This will force the comparison to be deterministic.</p>
	
	<pre>byteSequence new_sort_key (String a) {
  return old_sort_key(a) + SEPARATOR + toByteSequence(a);
}</pre>

	<p>Because sort keys and comparisons must be aligned, a sort key generator is 
	deterministic if and only if a comparison is.</p>
	
	<h4>A.3.2 <a name="Best_Practice">Best Practice</a></h4>
	
	<p>A deterministic comparison is generally not best practice. First, 
	it has a certain performance cost in comparison, and a quite substantial impact 
	on sort key size. (For example, ICU language-sensitive sort keys are generally 
	about the size of the original string, so appending a copy of the original string 
	generally doubles the size of the sort key.)&nbsp; A database using these 
	sort keys can have substantially increased disk footprint and memory footprint, 
	and consequently reduced performance.</p>
	<p>More importantly, a deterministic comparison function does not actually achieve 
	the effect people think it will have. Look at the sorted examples above. Whether 
	a deterministic comparison is used or not, there will be <i><b>no</b></i> effect 
	on the Quicksort example, because the two records in question have identical Last_Name fields. 
	It does not make a non-deterministic sort into a deterministic 
	one, nor does it make a non-stable sort into a stable one.</p>
	<p>Thirdly, a deterministic comparison is often not what is wanted, when people 
	look closely at the implications. Look at the example again, and suppose that 
	this time the user is sorting first by last name, then by first name.</p>
	
	<p class="caption"><a name="Original_Records_Table2"></a>Original Records</p>

	<div align="center">
		<table cellpadding="4">
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td><font color="#00ff00">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
			<tr>
				<td><font color="#00ff00">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
		</table>
	</div>
	
	<p>The desired results are the following, which should result whether the sort
	algorithm is stable or not, because it uses both fields.</p>
	
	<p class="caption"><a name="First_Then_Last_Table"></a>First then Last</p>

	<div align="center">
		<table cellpadding="4">
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
			<tr>
				<td><font color="#00ff00">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
			<tr>
				<td><font color="#00ff00">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
		</table>
	</div>
	
	<p>Now suppose that in record 2, the source for the data caused the last name 
	to contain a format control character, such as a ZWJ (used to request ligatures on 
	display). In this case there is no visible distinction in the forms, because the 
	font does not have any ligatures for these sequences of Latin letters. The default UCA collation 
	weighting causes the ZWJ to be—correctly—ignored in comparison, since 
	it should only affect rendering. However, if that comparison is changed to be 
	deterministic (by appending the binary values for the original string), then unexpected results 
	will occur.</p>
	
	<p class="caption"><a name="First_Then_Last_Det_Table"></a>First then Last (Deterministic)</p>

	<div align="center">
		<table cellpadding="4">
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
			<tr>
				<td><font color="#ff0000">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
			<tr>
				<td><font color="#ff0000">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
		</table>
	</div>
	
	<h4>A.3.3 <a name="Forcing_Stable_Sorts">Forcing Stable <i>Sorts</i></a></h4>
	
	<p>Typically, what people really want when they say they want a deterministic 
	comparison is actually a stable sort.</p>
	<p>One can force a non-stable sort algorithm to produce stable results 
	by how one does the comparison. However, this has literally nothing to do with 
	making the comparison deterministic or not. Forcing stable results can be done by appending 
	the <i>current record number</i> to the strings to be compared. (The implementation 
	may not actually append the number; it may use some other mechanism, but the 
	effect would be the same.)</p>
	
	<p>If such a modified comparison is used, for example, it forces 
	Quicksort to get the same results as a Merge sort. In that case, the irrelevant 
	character ZWJ does not affect the outcome. The correct 
	results occur, as illustrated below.</p>
	
	<p class="caption"><a name="First_Then_Last_Stable_Table"></a>First then Last (Forced Stable Results)</p>

	<div align="center">
		<table cellpadding="4">
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
			<tr>
				<td><font color="#00ff00">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
			<tr>
				<td><font color="#00ff00">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
		</table>
	</div>
	
	<p>If anything, this then is what users want when they say they want a deterministic 
	comparison. See also <i>Section 1.6, <a href="tr10-22.html#Interleaved_Levels">Interleaved 
	Levels</a></i>.</p>
	
	<h3>A.4 <a name="Stable_Comparison">Stable and Portable Comparison</a></h3>
	
	<p>There are a few other terms worth mentioning, simply because they are also 
	subject to considerable confusion. Any or all of the following terms may be easily 
	confused with the discussion above.</p>
	<p>A <i>stable comparison</i> is one that does not change over successive software 
	versions. That is, as one uses successive versions of an API, with the same 
	&quot;settings&quot; (such as locale), one gets the same results.</p>
	<p>A <i>stable sort key generator</i> is one that generates the same binary 
	sequence over successive software versions.</p>
	<blockquote>
		<p><b>Warning:</b> If the sort key generator is stable, then the associated 
		comparison will perforce be. However, the reverse is not guaranteed. To 
		take a trivial example, suppose the new version of the software always adds 
		an 0xFF byte at the front of every sort key. The results of any comparison 
		of any two new keys would be identical to the results of the comparison 
		of any two corresponding old keys. However, the bytes have changed, and 
		the comparison of old and new keys would give different results. Thus one 
		can have a stable comparison, yet an associated non-stable sort key generator.</p>
	</blockquote>
	<p>A <i>portable comparison</i> is where corresponding APIs for comparison produce 
	the same results across different platforms. That is, if one uses the same &quot;settings&quot; 
	(such as locale), one gets the same results.</p>
	<p>A <i>portable sort key generator </i>is where corresponding sort key APIs 
	produce exactly the same sequence of bytes across different platforms.</p>
	<blockquote>
		<p><b>Warning:</b> As above, a comparison may be portable without the associated 
		sort key generator being portable.</p>
	</blockquote>
	<p>Ideally, all products would have the same string comparison and sort key 
	generation for, say Swedish, and thus be portable. For historical reasons, this 
	is not the case. Even if the main letters sort the same, there will be differences 
	in the handling of other letters, or of symbols, punctuation, and other characters. 
	There are some libraries that offer portable comparison, such as 
	[<a href="tr10-22.html#ICUCollator">ICUCollator</a>], 
	but in general the results of comparison or sort key generation may vary significantly 
	between different platforms.</p>
	<p>In a closed system, or in simple scenarios, portability may not matter. Where 
	someone has a given set of data to present to a user, and just wants the output 
	to be reasonably appropriate for Swedish, the exact order on the screen 
	may not matter.</p>
	<p>In other circumstances, differences can lead to data corruption. For example, suppose 
	that two implementations do a database SELECT for records between a pair of 
	strings. If the collation is different in the least way, they can get different 
	data results. Financial data might be different, for example, if a city is included 
	in one SELECT on one platform and excluded from the same SELECT on another platform.</p>
	
	<h2><a name="Acknowledgements">Acknowledgements</a></h2>
	
	<p>Mark Davis authored most of the original text of this document.
	Mark Davis and Ken Whistler together have added to and continue to maintain the text.</p>
	
	<p>Thanks to Bernard Desgraupes, Richard Gillam, Kent Karlsson, York Karsunke, Michael Kay, 
	Åke Persson, Roozbeh Pournader, Markus Scherer, Javier Sola, Otto Stolz, Ienup Sung, Yoshito Umaoka, Andrea Vine, and 
	Vladimir Weinstein for their feedback on previous versions of this document, 
	to Jianping Yang and Claire Ho for their contributions on matching, and to Cathy 
	Wissink for her many contributions to the text. Julie Allen
	helped in copyediting of the text.</p>
	
<h2><a name="References">References</a></h2>
	<table class="noborder" cellpadding="8">
		<tr>
			<td width="1" class="noborder">[<a name="Allkeys">Allkeys</a>]</td>
			<td class="noborder">Default Unicode Collation Element Table (DUCET)<br>
			<i>For the latest version, see:</i><br>
			<a href="http://www.unicode.org/Public/UCA/latest/allkeys.txt">http://www.unicode.org/Public/UCA/latest/allkeys.txt</a><br>
			<i>For the 6.0.0 version, see:</i><br>
			<a href="http://www.unicode.org/Public/UCA/6.0.0/allkeys.txt">http://www.unicode.org/Public/UCA/6.0.0/allkeys.txt</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="CanStd">CanStd</a>]</td>
			<td class="noborder">CAN/CSA Z243.4.1. For availability 
			see <a href="http://www.shopcsa.ca/">http://www.shopcsa.ca/</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="CLDR">CLDR</a>]</td>
			<td class="noborder">Common Locale Data Repository<br>
			<a href="http://unicode.org/cldr/">http://unicode.org/cldr/</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Data10">Data10</a>]</td>
			<td class="noborder">For all UCA implementation and test data<br>
			<i>For the latest version, see:</i><br>
			<a href="http://www.unicode.org/Public/UCA/latest/">http://www.unicode.org/Public/UCA/latest/</a><br>
			<i>For the 6.0.0 version, see:</i><br>
			<a href="http://www.unicode.org/Public/UCA/6.0.0/">http://www.unicode.org/Public/UCA/6.0.0/</a><br>
			<i>For ftp access, see:</i><br>
			<a href="ftp://www.unicode.org/Public/">ftp://www.unicode.org/Public/UCA/</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="FAQ">FAQ</a>]</td>
			<td class="noborder">Unicode Frequently Asked Questions<br>
			<a href="http://www.unicode.org/faq/">http://www.unicode.org/faq/<br>
			</a><i>For answers to common questions on technical issues.</i></td>
		</tr>
		<tr>
			<td valign="top" width="1" class="noborder">[<a name="Feedback">Feedback</a>]</td>
			<td valign="top" class="noborder">Reporting Errors and Requesting Information 
			Online<i><br>
			</i><a href="http://www.unicode.org/reporting.html">http://www.unicode.org/reporting.html</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Glossary">Glossary</a>]</td>
			<td class="noborder">Unicode Glossary<a href="http://www.unicode.org/glossary/"><br>
			http://www.unicode.org/glossary/<br>
			</a><i>For explanations of terminology used in this and other documents.</i></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="ICUCollator">ICUCollator</a>]</td>
			<td class="noborder">ICU User Guide: Collation Introduction<br>
			<a href="http://userguide.icu-project.org/collation">http://userguide.icu-project.org/collation</a>
			</td>
		</tr>
		<tr>
			<td class="noborder" valign="top" width="1">[<a name="ISO14651">ISO14651</a>]</td>
			<td class="noborder" valign="top">International Organization for Standardization.
			<i>Information Technology&#x2014;International String ordering and comparison&#x2014;Method 
			for comparing character strings and description of the common template 
			tailorable ordering.&nbsp; </i>(ISO/IEC 14651:2001). For availability 
			see <a href="http://www.iso.org">http://www.iso.org</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="JavaCollator">JavaCollator</a>]</td>
			<td class="noborder">
			<a href="http://java.sun.com/javase/6/docs/api/java/text/Collator.html">
			http://java.sun.com/javase/6/docs/api/java/text/Collator.html</a>,<br>
			<a href="http://java.sun.com/javase/6/docs/api/java/text/RuleBasedCollator.html">
			http://java.sun.com/javase/6/docs/api/java/text/RuleBasedCollator.html</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Reports">Reports</a>]</td>
			<td class="noborder">Unicode Technical Reports<br>
			<a href="../index.html">http://www.unicode.org/reports/<br>
			</a><i>For information on the status and development process for technical 
			reports, and for a list of technical reports.</i></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Sample">Sample</a>]</td>
			<td class="noborder">
			<a href="Sample/index.html">http://www.unicode.org/reports/tr10/Sample/</a></td>
		</tr>
		<tr>
			<td class="noborder">[<a name="SortAlg">SortAlg</a>]</td>
			<td class="noborder">For background on the names and characteristics 
			of different sorting methods, see<br>
			<a href="http://en.wikipedia.org/wiki/Sorting_algorithm">http://en.wikipedia.org/wiki/Sorting_algorithm</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Tests10">Tests10</a>]</td>
			<td class="noborder">Conformance Test and Documentation<br>
			<i>For the latest version, see:</i><br>
			<a href="http://www.unicode.org/Public/UCA/latest/CollationTest.html">
			http://www.unicode.org/Public/UCA/latest/CollationTest.html</a><br>
			<a href="http://www.unicode.org/Public/UCA/latest/CollationTest.zip">
			http://www.unicode.org/Public/UCA/latest/CollationTest.zip</a><br>
			<i>For the 6.0.0 version, see:</i><br>
			<a href="http://www.unicode.org/Public/UCA/6.0.0/CollationTest.html">
			http://www.unicode.org/Public/UCA/6.0.0/CollationTest.html</a><br>
			<a href="http://www.unicode.org/Public/UCA/6.0.0/CollationTest.zip">
			http://www.unicode.org/Public/UCA/6.0.0/CollationTest.zip</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="UAX15">UAX15</a>]</td>
			<td class="noborder">UAX #15: Unicode Normalization Forms<br>
			<a href="../tr15.1">http://www.unicode.org/reports/tr15/</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="UAX29">UAX29</a>]</td>
			<td class="noborder">UAX #29: Unicode Text Segmentation<br>
			<a href="../tr29.1">http://www.unicode.org/reports/tr29/</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="UAX44">UAX44</a>]</td>
			<td class="noborder">UAX #44: Unicode Character Database<br>
			<a href="../tr44/index.html">
			http://www.unicode.org/reports/tr44/</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Unicode">Unicode</a>]</td>
			<td class="noborder">The Unicode Consortium. The Unicode Standard, Version 6.0.0 
			(Mountain View, CA: The Unicode Consortium, 2011. ISBN 978-1-936213-01-6)<br>
			<a href="http://www.unicode.org/versions/Unicode6.0.0/">http://www.unicode.org/versions/Unicode6.0.0/</a><br>
			</td>
		</tr>
		<tr>
			<td class="noborder">[<a name="Unstable">Unstable</a>]</td>
			<td class="noborder">For a definition of stable sorting, see<br>
			<a href="http://planetmath.org/encyclopedia/UnstableSortingAlgorithm.html">
			http://planetmath.org/encyclopedia/UnstableSortingAlgorithm.html</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="UTN5">UTN5</a>]</td>
			<td class="noborder">UTN #5: Canonical Equivalence in Applications<br>
			<a href="../../notes/tn5.1">http://www.unicode.org/notes/tn5/</a>
			</td>
		</tr>
		<tr>
		  <td width="1" class="noborder">[<a name="UTS18">UTS18</a>]</td>
			<td class="noborder">UTS #18: Unicode Regular Expressions<br>
			<a href="../tr18.1">http://www.unicode.org/reports/tr18/</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="UTS35">UTS35</a>]</td>
			<td class="noborder">UTS #35: Unicode Locale Data Markup Language (LDML)<br>
			<a href="../tr35/index.html">http://www.unicode.org/reports/tr35/</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Versions">Versions</a>]</td>
			<td class="noborder">Versions of the Unicode Standard<br>
			<a href="http://www.unicode.org/versions/">http://www.unicode.org/versions/<br>
			</a><i>For details on the precise contents of each version of the Unicode 
			Standard, and how to cite them.</i></td>
		</tr>
	</table>
	<p>&nbsp; </p>
	<h2><a name="Migration">Migration Issues</a></h2>
	<p>This section summarizes important migration issues which may impact implementations
	of the Unicode Collation Algorithm when they are updated to a new version.</p>
	<h3>UCA 6.0.0 from UCA 5.2.0 (or earlier)</h3>
		<ul>
		<li>Ill-formed code unit sequences are no longer required to be mapped to
		[.0000.0000.0000.] when not treated as an error; instead, implementations are strongly
		encouraged not to give them ignorable primary weights, for security reasons.</li>
		<li>Noncharacter code points are also no longer required to be mapped to
		[.0000.0000.0000.], but are given implicit weights instead.</li>
		<li>The addition of a new range of CJK unified ideographs (Extension D) means that 
		some implementations may need to change hard-coded ranges for ideographs.</li>
		</ul>
	<h3>UCA 5.2.0 from UCA 5.1.0 (or earlier)</h3>
		<ul>
		<li>The clarification of implicit weight BASE values in
		<i>Section 7.1.3, <a href="tr10-22.html#Implicit_Weights">Implicit Weights</a></i> means that
		any implementation which weighted unassigned code points in a CJK unified ideograph block
		as if they were CJK unified ideographs will need to change.</li>
		<li>The addition of a new range of CJK unified ideographs (Extension C) means that 
		some implementations may need to change hard-coded ranges for ideographs.</li>
		</ul>
	<h2><a name="Modifications">Modifications</a></h2>
	<p>The following summarizes modifications from the previous revisions of this 
	document.</p>
	<h3>Revision 22 [KW]</h3>
		<ul>
			<li>Updated for Unicode 6.0.0.</li>
			<li>Updated text of Summary at top of document.</li>
			<li>Added Migration Issues section after References.</li>
			<li>Reorganized and renumbered several sections for better text flow.</li>
			<li>Provided numbers and anchors for tables, and updated table and caption
			    formats to match current Technical Report style. Added captions
			    for tables or figures that did not have them. Removed unneeded
			    color backgrounds from tables.</li>
			<li>Updated several obsolete links in the References section.</li>
			<li>Reorganized the References section and updated style of references.</li>
			<li>Added <i>Section 9 <a href="tr10-22.html#Data_Files">Data Files</a></i>.</li>
			<li>Significant editorial corrections throughout.</li>
			<li>Completely rewrote the discussion of "illegal" and "legal" code points
			    to bring it up to date with the Unicode Standard. See
			    <i>Section 7.1.1 <a href="tr10-22.html#Handling_Illformed">Handling Ill-Formed Code
			    Unit Sequences</a></i>.</li>
			<li>Split <i>Section 7.1.5 <a href="tr10-22.html#Hangul_Collation">Hangul Collation</a></i>
			    from the discussion of trailing weights.</li>
			<li>Corrected order of first names in Sequential column of the <a href="tr10-22.html#Interleaved_Levels">Interleaved Levels Table</a>
			    and added explanation of the option used for variable collation elements
			    in the table.</li>
			<li>Updated the <a href="tr10-22.html#Tailoring_Example">Tailoring Example</a> to use
			    the ICU syntax instead of Java. [MD]</li>
		</ul>

	<p>Revision 21 being a proposed update, only changes between revisions 22 and 20 are noted here.</p>

	<h3>Revision 20</h3>
		<ul>
			<li>Updated for Unicode 5.2.0.
			<li>In <i>Section 7.1.3 <a href="tr10-22.html#Implicit_Weights">Implicit Weights</a></i>, clarified the calculation of implicit weights.</li>
			<li>Made it clear that the BASE value does not include unassigned code points.</li>
			<li>Clarified why some sample cells are empty in the first table.</li>
			<li>General: updated references to UAX/UTS's</li>
			<li>Removed reference to UTR #30</li>
			<li>Better aligned the options with the 3 values for variableChoice.</li>
			<li>Clarified the computation of the fourth level in <i>Section 3.2.1, <a href="tr10-22.html#File_Format">File Format</a></i>. [KW]</li>
			<li>Changed bit layout in <i>Section 6.10.1 <a href="tr10-22.html#Collation_Element_Format">Collation Element Format</a></i> for a real collation element,
			    to account for the fact that the DUCET secondary values number
			    more than 255, so no longer fit in 8 bits. [KW]</li>
			<li>Made small editorial clarifications regarding variable weighting in <i>Section 3.2.2, <a href="tr10-22.html#Variable_Weighting">Variable Weighting</a></i>. [KW]</li>
			<li>Updated reference to SC22 WG20 to SC2 OWG-SORT in <i>Section 7.1.4.1</i>. [KW]</li>
			<li>Made a minor wording clarification in <i>Section 7.3 <a href="tr10-22.html#Compatibility_Decompositions">Compatibility Decompositions</a></i>. [KW]</li>
			<li>Small editorial updates through for formatting consistency. [KW]</li>
			<li>Updated Modifications section to current conventions for handling
			    proposed update drafts. [KW]</li>
		</ul>
	<p>Revision 19 being a proposed update, only changes between revisions 20 and 18 are noted here.</p>
	<h3>Revision 18</h3>
	<ul>
		<li>Updated for Unicode 5.1.0.
		<li>Disallowed skipping 2.1.1 through 2.1.3 (<i>Section 4.2,
			<a href="tr10-22.html#Step_2">Produce Array</a></i>).</li>
		<li>Clarified use of contractions in the DUCET in <i>Section 3.2,
		<a href="tr10-22.html#Default_Unicode_Collation_Element_Table">Default Unicode Collation 
			Element Table</a></i> and <i>Section 3.1.1.2, <a href="tr10-22.html#Contractions">Contractions</a></i>.</li>
		<li>Added information about the use of parameterization (<i>Section 5.1,
			<a href="tr10-22.html#Parametic_Tailoring">Parametric Tailoring</a></i>) and a new 
			conformance clause <a href="tr10-22.html#C6">C6</a>.</li>
		<li>In <i>Section 8, <a href="tr10-22.html#Searching">Searching and Matching</a></i>,
			added new introduction and explained special cases; clarified 
		language in definitions.</li>
		<li>Added <i>Section 8.1, <a href="tr10-22.html#Collation_Folding">Collation Folding</a></i>.</li>
		<li>Fixed a number of reported typos.</li>
	</ul>
	<p>Revision 17 being a proposed update, only changes between revisions 18 and 16 are noted here.</p>
	<h3>Revision 16</h3>
	<ul>
		<li>Updated for Unicode 5.0.0.
		<li>Replaced &quot;combining mark&quot; by &quot;non-starter&quot; where necessary.</li>
		<li>Updated reference to Unicode 5.0 with the ISBN number.</li>
		<li>Added UTN#9 text in informative appendix as <i>
		<a href="tr10-22.html#Deterministic_Sorting">Appendix A: Deterministic_Sorting</a></i>.</li>
	</ul>
	<p>Revision 15 being a proposed update, only changes between revisions 16 and 14 are noted here.</p>
	<h3>Revision 14</h3>
	<ul>
		<li>Updated for Unicode 4.1.0.
		<li>Expanded use of 0x1D in <i>Section 
		7.3.1, <a href="tr10-22.html#Tertiary_Weight_Table">Tertiary Weight Table</a></i>.</li>
		<li>Removed DS5, added DS1a, DS2a, explanations of interactions with other 
		conditions, such as Whole Word or Whole Grapheme.</li>
		<li>Added conformance clause C5 for searching and matching.</li>
		<li>Many minor edits.</li>
		<li>Removed S1.3, so that fully ignorable characters will interrupt contractions 
		(that do not explicitly contain them).</li>
		<li>Added related <i>Section 3.1.6, 
		<a href="tr10-22.html#Combining_Grapheme_Joiner">Combining Grapheme Joiner</a></i>.</li>
		<li>Removed S1.2 for Thai, and a paragraph in 1.3.</li>
		<li>Added more detail about Hangul to <i>Section 
		7.1.4, <a href="tr10-22.html#Trailing_Weights">Trailing Weights</a></i>, including a description of the Interleaving 
		method.</li>
		<li>Fixed dangling reference to base standard in <a href="tr10-22.html#C4">C4</a>.</li>
		<li>Added definitions and clarifications to <i>Section 
		8, <a href="tr10-22.html#Searching">Searching and Matching</a></i>.</li>
		<li>Added more information on user expectations to <i>
		Section 1, <a href="tr10-22.html#Introduction">Introduction</a></i>.</li>
	</ul>
	<p>Data tables for 4.1.0 contain the following changes:</p>
	<ol>
		<li>The additions of weights for all the new Unicode 4.1.0 characters.</li>
		<li>The change of weights for characters Æ, Ǽ, Ǣ; Đ, Ð; Ħ; Ł, Ŀ; and Ø, 
		Ǿ (and their lowercase and accented forms) to have secondary (accent) differences 
		from AE; D; H; L; and O, respectively. This is to provide a much better 
		default for languages in which those characters are not tailored. See also 
		the section on user expectations.</li>
		<li>Change in weights for U+0600 ARABIC NUMBER SIGN and U+2062 INVISIBLE 
		TIMES and like characters (U+0600..U+0603, U+06DD, U+2061..U+2063) to be 
		not completely ignorable, because their effect on the interpretation of 
		the text can be substantial.</li>
		<li>The addition of about 150 contractions for Thai. This is synchronized 
		with the removal of S1.2. The result produces the same results for well-formed 
		Thai data, while substantially reducing the complexity of implementations 
		in searching and matching. Other changes for Thai include:<ol type="a">
			<li>After U+0E44 ไ THAI CHARACTER SARA AI MAIMALAI<br>
			Insertion of the character U+0E45 ๅ THAI CHARACTER LAKKHANGYAO</li>
			<li>Before U+0E47&nbsp; ็ THAI CHARACTER MAITAIKHU<br>
			Insertion of the character U+0E4E ๎ THAI CHARACTER YAMAKKAN</li>
			<li>After U+0E4B ๋ THAI CHARACTER MAI CHATTAWA<br>
			Insertion of the character U+0E4C ์ THAI CHARACTER THANTHAKHAT<br>
			Then the character U+0E4D ํ THAI CHARACTER NIKHAHIT</li>
		</ol>
		</li>
		<li>Changed the ordering of U+03FA GREEK CAPITAL LETTER SAN and U+03FB GREEK 
		SMALL LETTER SAN.</li>
	</ol>
	<p>Revisions 12 and 13 being proposed updates, only changes between revisions 14 and 11 are noted here.</p>
	<h3>Revision 11</h3>
	<ul>
		<li>Changed the version to synchronize with versions of the Unicode Standard, 
		so that the repertoire of characters is the same. This affects the header 
		and <a href="tr10-22.html#C4">C4</a>. This revision is synchronized
		with Unicode 4.0.0.</li>
		<li>Location of data files changed to
		<a href="http://www.unicode.org/Public/UCA/">http://www.unicode.org/Public/UCA/</a></li>
		<li>Added new <a href="tr10-22.html#Introduction">Introduction</a>. This covers concepts 
		in <i>Section 5.17</i>, 
		"Sorting and Searching", in  
		 <i>The Unicode Standard,
		Version 3.0</i>, but is completely reworked. The Scope section 
		has been recast and is now at the end of the introduction.</li>
		<li>In <i>Section 6.9, <a href="tr10-22.html#Tailoring_Example">Tailoring Example: Java</a></i>, added 
		informative reference to LDML; moved informative reference to ICU.</li>
		<li>Added explanation of different ways that the Hangul problem can be solved 
		in <i>Section 7.1.4, <a href="tr10-22.html#Trailing_Weights">Trailing Weights</a></i>.</li>
		<li>Copied sentence from Scope up to Summary, for more visibility.</li>
	</ul>
	<p>Revision 10 being a proposed update, only changes between revisions 11 and 9 are noted here.</p>
	<h3>Revision 9</h3>
	<ul>
		<li>Added <a href="tr10-22.html#C4">C4</a>.</li>
		<li>Added more conditions in <i>Section 3.3, <a href="tr10-22.html#Well-Formed">Well-Formed Collation 
		Element Tables</a></i>.</li>
		<li>Added S1.3.</li>
		<li>Added treatment of ignorables after variables in
		<i>Section 3.2.2, <a href="tr10-22.html#Variable_Weighting">Variable Weighting</a></i>.</li>
		<li>Added <i>Section 3.4, <a href="tr10-22.html#Stability">Stability</a></i>.</li>
		<li>Modified and reorganized <i>Section 7, <a href="tr10-22.html#Weight_Derivation">Weight Derivation</a></i>. 
		In particular, CJK characters and unassigned characters are given different 
		weights. Added MAX to <i>Section 7.3</i>.</li>
		<li>Added references.</li>
		<li>Minor editing.</li>
		<li>Clarified noncharacter code points in 
		<i>Section 7.1.1, Illegal code points</i>.</li>
		<li>Modified S1.2 and <i>Section 3.1.3, <a href="tr10-22.html#Rearrangement">Rearrangement</a></i> to 
		use the Logical_Order_Exception property, and removed <i>rearrange</i> from 
		the file syntax in <i>Section 3.2.1, <a href="tr10-22.html#File_Format">File Format</a></i>, and from
		<i>Section 5, <a href="tr10-22.html#Tailoring">Tailoring</a></i>.</li>
		<li>Incorporated Cathy Wissink&#39;s notes on linguistic applicability.</li>
		<li>Updated links for [<a href="tr10-22.html#Tests10">Test</a>].</li>
	</ul>
	<hr width="50%">
	<p class="copyright"><font size="-1">Copyright © 1998-2010 Unicode, Inc. All 
	Rights Reserved. The Unicode Consortium makes no expressed or implied warranty 
	of any kind, and assumes no liability for errors or omissions. No liability 
	is assumed for incidental and consequential damages in connection with or arising 
	out of the use of the information or programs contained or accompanying this 
	technical report. The Unicode
	<a href="http://www.unicode.org/copyright.html">Terms of Use</a> apply.</font>
	</p>
	<p class="copyright"><font size="-1">Unicode and the Unicode logo are trademarks 
	of Unicode, Inc., and are registered in some jurisdictions.</font></p>
</div>

</body>

</html>
