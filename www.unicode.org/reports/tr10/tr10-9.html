<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>UTR #10: Unicode Collation Algorithm</title>
<link rel="stylesheet" href="../../unicode/reports/reports.css" type="text/css">
</head>

<body bgcolor="#ffffff">

<table class="header">
  <tr>
    <td class="icon"><a href="http://www.unicode.org"><img align="middle" alt="[Unicode]" border="0" src="../../webscripts/logo60s2.gif" width="34" height="33"></a>&nbsp;&nbsp;<a class="bar" href="http://www.unicode.org/reports">Technical 
      Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>
</table>
<div class="body">
  <h2 align="center">Unicode Technical Standard #10</h2>
  <h1>Unicode Collation Algorithm</h1>
  <table class="wide" cellspacing="2" cellpadding="2" border="1" width="100%">
    <tr>
      <td width="20%">Version</td>
      <td><a href="tr10-9.html#TrackingNumber9">9</a></td>
    </tr>
    <tr>
      <td>Authors</td>
      <td>Mark Davis (<a href="mailto:mark.davis@us.ibm.com">mark.davis@us.ibm.com</a>), 
        Ken Whistler (<a href="mailto:ken@unicode.org">ken@unicode.org</a>)</td>
    </tr>
    <tr>
      <td>Date</td>
      <td>2002-07-16</td>
    </tr>
    <tr>
      <td>This Version</td>
      <td><a href="tr10-9.html">http://www.unicode.org/reports/tr10/tr10-9.html</a></td>
    </tr>
    <tr>
      <td>Previous Version</td>
      <td><a href="tr10-8.html">http://www.unicode.org/reports/tr10/tr10-8.html</a></td>
    </tr>
    <tr>
      <td>Latest Version</td>
      <td><a href="index.html">http://www.unicode.org/reports/tr10/</a></td>
    </tr>
    <tr>
      <td>Base Unicode Version</td>
      <td><a href="http://www.unicode.org/unicode/standard/versions/enumeratedversions.html#Unicode_3_1_1_With_Corrigendum">Unicode 
        3.1 with Corrigendum 3</a></td>
    </tr>
  </table>
  &nbsp;
  <h3><i>Summary</i></h3>
  <p><i>This report provides the specification of the Unicode Collation 
  Algorithm, which provides a specification for how to compare two Unicode 
  strings while remaining conformant to the requirements of The Unicode 
  Standard, Version 3.0.</i></p>
  <h3><i>Status</i></h3>
  <p><i>This document has been reviewed by Unicode members and other interested 
  parties, and has been approved by the Unicode Technical Committee as a <b>Unicode 
  Technical Standard</b>. It is a stable document and may be used as reference 
  material or cited as a normative reference from another document.</i></p>
  <blockquote>
    <p><i><b>A Unicode Technical Standard (UTS)</b> is an independent 
    specification. Conformance to the Unicode Standard does not imply 
    conformance to any UTS. Each UTS specifies a base version of the Unicode 
    Standard. Conformance to the UTS requires conformance to that version or 
    higher.</i></p>
  </blockquote>
  <p><i>A list of current Unicode Technical Reports is found on [<a href="tr10-9.html#Reports">Reports</a>]. 
  For more information about versions of the Unicode Standard, see [<a href="tr10-9.html#Versions">Versions</a>]. 
  Please mail corrigenda and other comments to the author(s).</i></p>
  <h3><i>Contents</i></h3>
  <ul>
    <li><a href="tr10-9.html#Scope">1 Scope</a>
      <ul>
        <li><a href="tr10-9.html#Goals">1.1 Goals</a></li>
        <li><a href="tr10-9.html#Non-Goals">1.2 Non-Goals</a></li>
        <li><a href="tr10-9.html#Summary">1.3 Summary</a></li>
      </ul>
    </li>
    <li><a href="tr10-9.html#Conformance">2 Conformance</a></li>
    <li><a href="tr10-9.html#Data_Table_Format">3 Collation Element Table</a>
      <ul>
        <li><a href="tr10-9.html#Linguistic_Features">3.1 Linguistic Features</a>
          <ul>
            <li><a href="tr10-9.html#Multiple_Mappings">3.1.1 Multiple Mappings</a>
              <ul>
                <li><a href="tr10-9.html#Expansions">3.1.1.1 Expansions</a></li>
                <li><a href="tr10-9.html#Contractions">3.1.1.2 Contractions</a></li>
                <li><a href="tr10-9.html#Other_Multiple_Mappings">3.1.1.3 Other Multiple 
                  Mappings</a></li>
              </ul>
            </li>
            <li><a href="tr10-9.html#French_Accents">3.1.2 French Accents</a></li>
            <li><a href="tr10-9.html#Rearrangement">3.1.3 Rearrangement</a></li>
            <li><a href="tr10-9.html#Default_Values">3.1.4 Default Values</a></li>
            <li><a href="tr10-9.html#Collation_Graphemes">3.1.5 Collation Graphemes</a></li>
          </ul>
        </li>
        <li><a href="tr10-9.html#Default_Unicode_Collation_Element_Table">3.2 Default 
          Unicode Collation Element Table</a>
          <ul>
            <li><a href="tr10-9.html#File_Format">3.2.1 File Format</a></li>
            <li><a href="tr10-9.html#Variable_Weighting">3.2.2 Variable Weighting</a></li>
          </ul>
        </li>
        <li><a href="tr10-9.html#Well-Formed">3.3 Well-Formed Collation Element Tables</a></li>
        <li><a href="tr10-9.html#Stability">3.4 Stability</a></li>
      </ul>
    </li>
    <li><a href="tr10-9.html#Main_Algorithm">4 Main Algorithm</a>
      <ul>
        <li><a href="tr10-9.html#Step_1">4.1 Step 1: Normalize</a></li>
        <li><a href="tr10-9.html#Step_2">4.2 Step 2: Produce Array</a></li>
        <li><a href="tr10-9.html#Step_3">4.3 Step 3: Form Sort Key</a></li>
        <li><a href="tr10-9.html#Step_4">4.4 Step 4: Compare</a></li>
      </ul>
    </li>
    <li><a href="tr10-9.html#Tailoring">5 Tailoring</a>
      <ul>
        <li><a href="tr10-9.html#Preprocessing">5.1 Preprocessing</a></li>
      </ul>
    </li>
    <li><a href="tr10-9.html#Implementation_Notes">6 Implementation Notes</a>
      <ul>
        <li>
          <p align="left"><a href="tr10-9.html#Reducing_Sort_Key_Lengths">6.1 Reducing Sort 
          Key Lengths</a>
          <ul>
            <li>
              <p align="left"><a href="tr10-9.html#Eliminating_level_separators">6.1.1 
              Eliminating level separators</a></li>
            <li>
              <p align="left"><a href="tr10-9.html#L2/L3_in_8_bits">6.1.2 L2/L3 in 8 bits</a></li>
            <li>
              <p align="left"><a href="tr10-9.html#Machine_Words">6.1.3 Machine Words</a></li>
            <li>
              <p align="left"><a href="tr10-9.html#Run-length_Compression">6.1.4 Run-length 
              Compression</a></li>
          </ul>
        </li>
        <li>
          <p align="left"><a href="tr10-9.html#Large_Weight_Values">6.2 Large Weight Values</a></li>
        <li>
          <p align="left"><a href="tr10-9.html#Reducing_Table_Sizes">6.3 Reducing Table 
          Sizes</a>
          <ul>
            <li>
              <p align="left"><a href="tr10-9.html#Contiguous_weight_ranges">6.3.1 
              Contiguous Weight Ranges</a></li>
            <li>
              <p align="left"><a href="tr10-9.html#Escape_hatch">6.3.2 Escape Hatch</a></li>
            <li>
              <p align="left"><a href="tr10-9.html#Leveraging_Unicode_tables">6.3.3 
              Leveraging Unicode tables</a></li>
            <li>
              <p align="left"><a href="tr10-9.html#Reducing_the_Repertoire">6.3.4 Reducing 
              the Repertoire</a></li>
            <li>
              <p align="left"><a href="tr10-9.html#Memory_Table_Size">6.3.5 Memory Table 
              Size</a></li>
          </ul>
        </li>
        <li>
          <p align="left"><a href="tr10-9.html#Avoiding_Zero_Bytes">6.4 Avoiding Zero Bytes</a></li>
        <li>
          <p align="left"><a href="tr10-9.html#Avoiding_Normalization">6.5 Avoiding 
          Normalization</a></li>
        <li>
          <p align="left"><a href="tr10-9.html#Case_Comparisons">6.6 Case Comparisons</a></li>
        <li>
          <p align="left"><a href="tr10-9.html#Incremental_Comparison">6.7 Incremental 
          Comparison</a></li>
        <li>
          <p align="left"><a href="tr10-9.html#Catching_Mismatches">6.8 Catching Mismatches</a></li>
        <li>
          <p align="left"><a href="tr10-9.html#Comparison_to_Java">6.9 Tailoring Example: 
          Java</a></li>
        <li>
          <p align="left"><a href="tr10-9.html#Flat_File_Example">6.10 Flat File Example</a>
          <ul>
            <li>
              <p align="left"><a href="tr10-9.html#Collation_Element_Format">6.11.1 
              Collation Element Format</a></li>
            <li>
              <p align="left"><a href="tr10-9.html#Sample_Code">6.11.2 Sample Code</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="tr10-9.html#Weight_Derivation">7 Weight Derivation</a>
      <ul>
        <li><a href="tr10-9.html#Derived_Collation_Elements">7.1 Derived Collation Elements</a>
          <ul>
            <li><a href="tr10-9.html#Illegal_Code_Points">7.1.1 Illegal code points</a></li>
            <li><a href="tr10-9.html#Legal_Code_Points">7.1.2 Legal code points</a></li>
            <li><a href="tr10-9.html#Implicit_Weights">7.1.3 Implicit Weights</a></li>
            <li><a href="tr10-9.html#Trailing_Weights">7.1.4 Trailing Weights</a></li>
          </ul>
        </li>
        <li><a href="tr10-9.html#Canonical_Decompositions">7.2 Canonical Decompositions</a></li>
        <li><a href="tr10-9.html#Compatibility_Decompositions">7.3 </a><a href="tr10-9.html#Compatibility_Decompositions">Compatibility 
          Decompositions</a>
          <ul>
            <li><a href="tr10-9.html#Tertiary_Weight_Table">7.3.1 Tertiary Weight Table</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <p align="left"><a href="tr10-9.html#Searching">8 Searching and Matching</a></li>
    <li><a href="tr10-9.html#Acknowledgements">Acknowledgements</a></li>
    <li><a href="tr10-9.html#References">References</a></li>
    <li><a href="tr10-9.html#Modifications">Modifications</a></li>
  </ul>
  <h2><a name="Scope"></a>1 Scope</h2>
  <p>The Unicode Collation Algorithm (UCA) provides a specification for how to 
  compare two Unicode strings while remaining conformant to the requirements of <i>The 
  Unicode Standard, Version 3.0 </i>. The UCA also supplies the Default Unicode 
  Collation Element Table as the data specifying the default collation order.</p>
  <p>Readers should be familiar with <i><a href="http://www.unicode.org/uni2book/ch05.pdf">Section 
  5.17 Sorting and Searching</a></i> of the Unicode Standard before proceeding 
  with the rest of this document, since that section introduces the basic 
  concepts involved in collation.</p>
  <h4>1.1 <a name="Goals">Goals</a></h4>
  <p>The algorithm is designed to satisfy the following goals:</p>
  <ol>
    <li>A complete, unambiguous, specified ordering for all characters in 
      Unicode.
    <li>A complete resolution of the handling of canonical and compatibility 
      equivalences as relates to the default ordering.
    <li>A complete specification of the meaning and assignment of collation 
      levels, including whether a character is ignorable by default in 
      collation.
    <li>A complete specification of the rules for using the level weights to 
      determine the default collation order of strings of arbitrary length.
    <li>Allowance for override mechanisms (<i>tailoring</i>) for creating 
      language-specific orderings. Tailoring can be provided by any well-defined 
      syntax that takes the default ordering and produces another well-formed 
      ordering.
    <li>An algorithm that can be efficiently implemented, both in terms of 
      performance and in terms of memory requirements.
  </ol>
  <p>Given the standard ordering and the tailoring for any particular language, 
  any two companies or individuals — with their own proprietary 
  implementations — can take any arbitrary Unicode input and produce exactly 
  the same sorted output. In addition, when given a tailoring specifying French 
  accents this algorithm passes the Canadian and ISO 14651 benchmarks ([<a href="tr10-9.html#CanStd">CanStd</a>], 
  [<a href="tr10-9.html#SoStd">SoStd</a>]).</p>
  <blockquote>
    <p><b>Note: </b>The Default Unicode Collation Element Table is currently 
    limited to the Unicode 3.0 repertoire. However, the algorithm is well 
    defined over <i>all</i> Unicode code points. See <a href="tr10-9.html#Legal_Code_Points">§7.1.2 
    Legal code points</a>.</p>
    <p><b>Note: </b>When the table is updated to the Unicode 3.1 repertoire the 
    ordering of a few Unicode 3.0 characters will change for consistency with <a href="../tr15.1">UAX 
    #15: Unicode Normalization Forms</a>.</p>
  </blockquote>
  <h4>1.2 <a name="Non-Goals">Non-Goals</a></h4>
  <p>The Default Unicode Collation Element Table explicitly does not provide for 
  the following features:</p>
  <ol>
    <li><i>reversibility: </i>from a Collation Element you are not guaranteed 
      that you can recover the original character.
    <li><i>numeric formatting:</i> numbers composed of a string of digits or 
      other numerics will not necessarily sort in <i>numerical order.</i>
    <li><i>API:</i> no particular API is specified or required for the 
      algorithm.
    <li><i>title sorting:</i> for example, removing articles such as <i>a</i> 
      and <i>the </i>during bibliographic sorting is not provided.
    <li><i>Stability of binary sort key values between versions:</i> (However, 
      this should be addressed in a future version of this document.)</li>
    <li><i>linguistic applicability:</i> to meet most user expectations, a 
      linguistic tailoring is needed. For more information, see <a href="tr10-9.html#Tailoring">§5 
      Tailoring</a>.</li>
  </ol>
  <h4>1.3 <a name="Summary">Summary</a></h4>
  <p>Briefly stated, the Unicode Collation Algorithm takes an input Unicode 
  string and a Collation Element Table, containing mapping data for characters. 
  It produces a sort key, which is an array of unsigned 16-bit integers. Two or 
  more sort keys so produced can then be binary-compared to give the correct 
  comparison between the strings for which they were generated.</p>
  <p>The Unicode Collation Algorithm assumes multiple-level key weighting, along 
  the lines widely implemented in IBM technology, and as described in the 
  Canadian sorting standard [<a href="tr10-9.html#CanStd">CanStd</a>] and the proposed 
  International String Ordering standard [<a href="tr10-9.html#SoStd">SoStd</a>].</p>
  <p>By default, the algorithm makes use of three fully-customizable levels. For 
  the Latin script, these levels correspond roughly to:</p>
  <ol>
    <li>alphabetic ordering
    <li>diacritic ordering
    <li>case ordering.
  </ol>
  <p>A final level for tie-breaking (semi-stability) may be used for 
  tie-breaking between strings not otherwise distinguished.</p>
  <p>This design allows implementations to produce culturally acceptable 
  collation, while putting the least burden on implementations in terms of 
  memory requirements and performance. In particular, Collation Element Tables 
  only require storage of 32 bits of collation data per significant character.</p>
  <p>However, implementations of the Unicode Collation Algorithm are not limited 
  to supporting only 3 levels. They are free to support a fully customizable 4th 
  level (or more levels), as long as they can produce the same results as the 
  basic algorithm, given the right Collation Element Tables. For example, an 
  application which uses the algorithm, but which must treat some collection of 
  special characters as ignorable at the first 3 levels <i>and</i> must have 
  those specials collate in non-Unicode order (as, for example to emulate an 
  existing EBCDIC-based collation), may choose to have a fully customizable 4th 
  level. The downside of this choice is that such an application will require 
  more storage, both for the Collation Element Table and in constructed sort 
  keys.</p>
  <p>The Collation Element Table may be tailored to produce particular 
  culturally required orderings for different languages or locales. As in the 
  algorithm itself, the tailoring can provide full customization for three (or 
  more) levels.</p>
  <h2><a name="Conformance"></a>2 Conformance</h2>
  <p>There are many different ways to compare strings, and the Unicode Standard 
  does not restrict the ways in which implementations can do this. However, any 
  Unicode-conformant implementation that purports to implement the Unicode 
  Collation Algorithm must do so as described in this document.</p>
  <blockquote>
    <p><i><b>Note: </b>A conformance test for the UCA is available in [<a href="tr10-9.html#Test">Test</a>].</i></p>
  </blockquote>
  <p>The algorithm is a <i>logical</i> specification, designed to be 
  straightforward to describe. Actual implementations of the algorithm are free 
  to change any part of the algorithm so long as any two strings compared by the 
  implementation are ordered the same as they would be by the algorithm. They 
  are also free to use a different format for the data in the Collation Element 
  Table. The sort key is also a <i>logical</i> intermediate object: so long as 
  an implementation produces the same results in comparison of strings, the sort 
  keys can differ in format from what is specified here. (See <a href="tr10-9.html#Implementation_Notes">§6 
  Implementation Notes</a>.)</p>
  <p>The requirements for conformance on implementations of the Unicode 
  Collation Algorithm are as follows:</p>
  <table class="noborder" cellpadding="8">
    <tr>
      <td class="noborder"><b><a name="C1&nbsp;">C1</a>&nbsp;</b></td>
      <td class="noborder">
        <p><i>Given a well-formed Unicode Collation Element Table, a conformant 
        implementation shall replicate the same comparisons of strings as those 
        produced by <a href="tr10-9.html#Main_Algorithm">§4 Main Algorithm</a>.</i></p>
        <p>In particular, a conformant implementation must be able to compare 
        any two canonical equivalent strings as being equal, for all Unicode 
        characters supported by that implementation.</p>
        <p>If a conformant implementation compares strings in a legacy character 
        set, it must provide the same results as if those strings had been 
        transcoded to Unicode.</p>
      </td>
    </tr>
    <tr>
      <td width="1%" class="noborder"><b><a name="C2&nbsp;">C2</a>&nbsp;</b></td>
      <td class="noborder">
        <p><i>A conformant implementation shall support at least three levels of 
        collation.</i></p>
        <p>A conformant implementation is only required to implement three 
        levels. However, it may implement four (or more) levels if desired.</p>
      </td>
    </tr>
    <tr>
      <td width="1%" class="noborder"><b><a name="C3&nbsp;">C3</a>&nbsp;</b></td>
      <td class="noborder">
        <p><i>A conformant implementation that supports backward levels, 
        variable weighting, semi-stability or rearrangement shall do so in 
        accordance with this specification.</i></p>
        <p>A conformant implementation is not required to support these 
        features; however, if it does so, it must interpret them properly. 
        Unless they are functioning in a very restricted domain, it is strongly 
        recommended that implementations support a backwards secondary level, 
        since this is required for French.</p>
      </td>
    </tr>
    <tr>
      <td width="1%" class="noborder"><b><a name="C4">C4</a></b></td>
      <td class="noborder"><i>A conformant implementation must specify the 
        version number of this Unicode Technical Standard and the version number 
        of the Unicode Standard.</i>
        <p>The precise values of the collation elements for the characters may 
        change over time as new characters are added to the Unicode Standard. 
        Because canonical equivalence depends on the version of the Unicode 
        Standard, that version must also be specified.</p>
      </td>
    </tr>
  </table>
  <h2><a name="Data_Table_Format"></a>3 Collation Element Table</h2>
  <p>A Collation Element Table contains a mapping from one (or more) characters 
  to one (or more) <i>collation elements</i>, where a collation element is an 
  ordered list of three 16-bit weights. (All code points not explicitly 
  mentioned in the mapping are given an implicit weight: see <a href="tr10-9.html#Weight_Derivation">§7 
  Weight Derivation</a>).</p>
  <blockquote>
    <p><b>Note: </b>Implementations can produce the same result without using 
    16-bit weights — see <a href="tr10-9.html#Implementation_Notes">§6 Implementation 
    Notes</a>.</p>
  </blockquote>
  <p>The first weight is called the <i>Level 1</i> weight (or <i>primary</i> 
  weight), the second is called the <i>Level 2</i> weight (<i>secondary</i> 
  weight), the third is called the <i>Level 3</i> weight (<i>tertiary</i> 
  weight), the fourth is called the <i>Level 4</i> weight (<i>quaternary</i> 
  weight), and so on. For a collation element X, these can be abbreviated as X<sub>1</sub>, 
  X<sub>2</sub>, X<sub>3</sub>, X<sub>4</sub>, etc. Given two collation elements 
  X and Y, we will use the following notation:</p>
  <div align="center">
    <center>
    <table class="syntax" cellspacing="0" cellpadding="2">
      <caption><b>Equals Notation</b></caption>
      <tr>
        <th align="LEFT">Notation</th>
        <th align="LEFT">Reading</th>
        <th align="LEFT">Meaning</th>
      </tr>
      <tr>
        <td>X =<sub>1</sub> Y</td>
        <td align="left"><i>X is primary equal to Y</i></td>
        <td align="left">X<sub>1</sub> = Y<sub>1</sub></td>
      </tr>
      <tr>
        <td>X =<sub>2</sub> Y</td>
        <td align="left"><i>X is secondary equal to Y</i></td>
        <td align="left">X<sub>2</sub> = Y<sub>2</sub> and X =<sub>1</sub> Y</td>
      </tr>
      <tr>
        <td>X =<sub>3</sub> Y</td>
        <td align="left"><i>X is tertiary equal to Y</i></td>
        <td align="left">X<sub>3</sub> = Y<sub>3</sub> and X =<sub>2</sub> Y</td>
      </tr>
      <tr>
        <td>X =<sub>4</sub> Y</td>
        <td align="left"><i>X is quaternary equal to Y</i></td>
        <td align="left">X<sub>4</sub> = Y<sub>4</sub> and X =<sub>3</sub> Y</td>
      </tr>
    </table>
    </center>
  </div>
  <br>
  <div align="center">
    <center>
    <table class="syntax" cellspacing="0" cellpadding="2">
      <caption><b>Less Than Notation</b></caption>
      <tr>
        <th align="LEFT">Notation</th>
        <th align="LEFT">Reading</th>
        <th align="LEFT">Meaning</th>
      </tr>
      <tr>
        <td>X &lt;<sub>1</sub> Y</td>
        <td><i>X is primary less than Y</i></td>
        <td>X<sub>1</sub> &lt; Y<sub>1</sub></td>
      </tr>
      <tr>
        <td>X &lt;<sub>2</sub> Y</td>
        <td><i>X is secondary less than Y</i></td>
        <td>X &lt;<sub>1</sub> Y or (X =<sub>1</sub> Y and X<sub>2</sub> &lt; Y<sub>2</sub>)</td>
      </tr>
      <tr>
        <td>X &lt;<sub>3</sub> Y</td>
        <td><i>X is tertiary less than Y</i></td>
        <td>X &lt;<sub>2</sub> Y or (X =<sub>2</sub> Y and X<sub>3</sub> &lt; Y<sub>3</sub>)</td>
      </tr>
      <tr>
        <td>X &lt;<sub>4</sub> Y</td>
        <td><i>X is quaternary less than Y</i></td>
        <td>X &lt;<sub>3</sub> Y or (X =<sub>3</sub> Y and X<sub>4</sub> &lt; Y<sub>4</sub>)</td>
      </tr>
    </table>
    </center>
  </div>
  <p>Other operations are given their customary definitions in terms of these. 
  That is:
  <ul>
    <li>X <font size="3">≤</font><sub>n</sub> Y if and only if X &lt;<sub>n</sub> 
      Y or X =<sub>n</sub> Y</li>
    <li>X &gt;<sub>n</sub> Y if and only if Y &lt;<sub>n</sub> X</li>
    <li>X <font size="3">≥</font><sub>n</sub> Y if and only if Y <font size="3">≤</font><sub>n</sub> 
      X</li>
  </ul>
  <table class="noBorder" align="right" width="33%" cellpadding="8">
    <tr>
      <td class="syntax">
        <p><b>Note: </b>Where only plain text ASCII characters are available the 
        following fallback notation can be used:</p>
        <div align="center">
          <center>
          <table>
            <tr>
              <th>Notation</th>
              <th>Fallback</th>
            </tr>
            <tr>
              <td>X &lt;<sub>n</sub> Y</td>
              <td>X &lt;[n] Y</td>
            </tr>
            <tr>
              <td>X<sub>n</sub></td>
              <td>X[n]</td>
            </tr>
            <tr>
              <td>X <font size="3">≤</font><sub>n</sub> Y</td>
              <td>X &lt;=[n] Y</td>
            </tr>
            <tr>
              <td>A <font size="3">≡</font> B</td>
              <td>A <font size="3">=[a]</font> B</td>
            </tr>
          </table>
          </center>
        </div>
      </td>
    </tr>
  </table>
  <p>The collation algorithm results in a similar ordering among characters and 
  strings, so that for two strings A and B we can write A &lt;<sub>2</sub> B, 
  meaning that A is less than B and there is a primary or secondary difference 
  between them. If A &lt;<sub>2</sub> B but A=<sub>1</sub> B, we say that there 
  is <i>only</i> a secondary difference between them. If two strings are 
  equivalent (equal at all levels) according to a given Collation Table, we 
  write A <font size="3">≡</font> B. If they are bit-for-bit identical, we 
  write A <font size="3">=</font> B.</p>
  <p>If a weight is 0000, then that collation element is <i>ignorable</i> at 
  that level: the weight at that level is not taken into account in sorting. A 
  Level N ignorable is a collation element that is ignorable at level N but not 
  at level N+1. Thus:</p>
  <ul>
    <li>A <i>Level 1 ignorable (or primary ignorable)</i> is a collation element 
      that is ignorable at Level 1, but not at Level 2;</li>
    <li>a <i>Level 2 ignorable (or secondary ignorable)</i> is ignorable at 
      Levels 1 and 2, but not Level 3;</li>
    <li>a <i>Level 3 ignorable (or tertiary ignorable) </i>is ignorable at 
      Levels 1, 2, and 3 but not Level 4;</li>
  </ul>
  <p>In addition:</p>
  <ul>
    <li>A collation element that is not ignorable at any level is called a <i>non-ignorable</i>.</li>
    <li>A collation element with zeros at every level is called <i>completely 
      ignorable.</i></li>
  </ul>
  <p>For a given Collation Element Table, <i>MIN<sub>n</sub></i> is the least 
  weight in any collation element at level <i>n</i>, and <i>MAX<sub>n</sub></i> 
  is the maximum weight in any collation element at level <i>n</i>.</p>
  <p>The following are sample collation elements that are used in the examples 
  illustrating the algorithm. Unless otherwise noted, all weights are in 
  hexadecimal format.</p>
  <table class="wide">
    <caption>Sample Table</caption>
    <tr>
      <th align="LEFT" width="15%">
        <p align="LEFT">Character</th>
      <th align="LEFT" width="30%">
        <p align="LEFT">Collation Element</th>
      <th align="LEFT">
        <p align="LEFT">Name</th>
    </tr>
    <tr>
      <td><code>0300 &quot;`&quot;</code></td>
      <td><code>[0000.0021.0002]</code></td>
      <td><code>COMBINING GRAVE ACCENT</code></td>
    </tr>
    <tr>
      <td><code>0061 &quot;a&quot;</code></td>
      <td><code>[06D9.0020.0002]</code></td>
      <td><code>LATIN SMALL LETTER A</code></td>
    </tr>
    <tr>
      <td><code>0062 &quot;b&quot;</code></td>
      <td><code>[06EE.0020.0002]</code></td>
      <td><code>LATIN SMALL LETTER B</code></td>
    </tr>
    <tr>
      <td><code>0063 &quot;c&quot;</code></td>
      <td><code>[0706.0020.0002]</code></td>
      <td><code>LATIN SMALL LETTER C</code></td>
    </tr>
    <tr>
      <td><code>0043 &quot;C&quot;</code></td>
      <td><code>[0706.0020.0008]</code></td>
      <td><code>LATIN CAPITAL LETTER C</code></td>
    </tr>
    <tr>
      <td><code>0064 &quot;d&quot;</code></td>
      <td><code>[0712.0020.0002]</code></td>
      <td><code>LATIN SMALL LETTER D</code></td>
    </tr>
  </table>
  <blockquote>
    <p><i><b>Note: </b>Weights in all examples are illustrative, and may not 
    match what is in the latest Default Unicode Collation Element Table.</i></p>
  </blockquote>
  <h3>3.1 <a name="Linguistic_Features">Linguistic Features</a></h3>
  <p>Linguistic requirements of collation are covered in more detail in <i>The 
  Unicode Standard, Version 3.0, <a href="http://www.unicode.org/uni2book/ch05.pdf">Section 
  5.17 Sorting and Searching</a></i>.</p>
  <h4>3.1.1 <a name="Multiple_Mappings">Multiple Mappings</a></h4>
  <p>The mapping from characters to collation elements may not be a simple 
  mapping from one character to one collation element: in general, it may map 
  from one to many, from many to one, or from many to many. For example:</p>
  <h5>3.1.1.1 <a name="Expansions">Expansions</a></h5>
  <p>The Latin letter <i>æ</i> is treated as an independent letter by default. 
  Collations such as English, which may require treating it as equivalent to an <i>&lt;a 
  e&gt;</i> sequence, can tailor the letter to map to a sequence of more than 
  one collation elements, such as in the following example:</p>
  <p>&nbsp;
  <table class="wide">
    <tr>
      <th align="LEFT" width="15%">
        <p align="LEFT">Character</th>
      <th align="LEFT" width="30%">
        <p align="LEFT">Collation Element</th>
      <th align="LEFT">
        <p align="LEFT">Name</th>
    </tr>
    <tr>
      <td><code>00E6</code></td>
      <td><code>[06D9.0020.0002], [073A.0020.0002]</code></td>
      <td><code>LATIN SMALL LETTER AE; &quot;æ&quot;</code></td>
    </tr>
  </table>
  <p>In this example, the collation element <tt>[06D9.0020.0002]</tt> gives the 
  weight values for <i>a</i>, and the collation element <tt>[073A.0020.0002]</tt> 
  gives the weight values for <i>e</i>.</p>
  <h5>3.1.1.2 <a name="Contractions">Contractions</a></h5>
  <p>Similarly, where <i>ch</i> is treated as a single letter as in traditional 
  Spanish, it is represented as a mapping from two characters to a single 
  Collation Element, such as in the following example</p>
  <table class="wide">
    <tr>
      <th align="LEFT" width="15%">
        <p align="LEFT">Character</th>
      <th align="LEFT" width="30%">
        <p align="LEFT">Collation Element</th>
      <th align="LEFT">
        <p align="LEFT">Name</th>
    </tr>
    <tr>
      <td><code>0063<br>
        0068</code></td>
      <td><code>[0707.0020.0002]</code></td>
      <td><code>LATIN SMALL LETTER C,<br>
        LATIN SMALL LETTER H; &quot;ch&quot;</code></td>
    </tr>
  </table>
  <p>In this example, the collation element <tt>[0707.0020.0002]</tt> has a 
  primary value one greater than the primary value for the letter <i>c</i> by 
  itself, so that the sequence <i>ch</i> will collate after <i>c</i> and before <i>d</i>. 
  The above example shows the result of a tailoring of collation elements to 
  weight sequences of letters as a single unit.</p>
  <p>Any character (such as <i>soft hyphen</i>) that is not completely ignorable 
  between two characters of a contraction will cause them to sort as separate 
  characters.</p>
  <h5>3.1.1.3 <a name="Other_Multiple_Mappings">Other Multiple Mappings</a></h5>
  <p>Certain characters may both expand and contract: see <i>Section 5.17 
  Sorting and Searching.</i></p>
  <h4><a name="French_Accents"></a>3.1.2 French Accents</h4>
  <p>In some languages (notably French), accents are sorted from the back of the 
  string to the front of the string. This behavior is not marked in the Default 
  Unicode Collation Element Table, but may occur in tailored tables. In such a 
  case, the collation elements for the accents and their base characters are 
  marked as being <i>backwards</i> at Level 2.</p>
  <h4><a name="Rearrangement"></a>3.1.3 Rearrangement</h4>
  <p>Certain characters are not coded in logical order, such as the Thai vowels 
  เ through ไ and the Lao vowels ເ through ໄ (this list is indicated by 
  the <a href="http://www.unicode.org/Public/UNIDATA/PropList.html">Logical_Order_Exception</a> 
  property). For collation, they are rearranged by swapping with the following 
  character before further processing, since logically they belong afterwards. 
  For example, here is a string processed by rearrangement:</p>
  <table class="wide">
    <tr>
      <td width="15%">input string:</td>
      <td><tt>0E01 <b>0E40</b> 0E02 0E03</tt></td>
    </tr>
    <tr>
      <td>normalized string:</td>
      <td><tt>0E01 0E02 <b>0E40</b> 0E03</tt></td>
    </tr>
  </table>
  <br>
  <h4><a name="Default_Values"></a>3.1.4 Default Values</h4>
  <p>Both in the Default Unicode Collation Element Table and in typical 
  tailorings, most unaccented letters differ in the primary weights, but have 
  secondary weights (such as <i>a<sub>1</sub></i>) equal to <i>MIN<sub>2</sub></i>. 
  The primary ignorables will have secondary weights greater than <i>MIN<sub>2</sub></i>. 
  Characters that are compatibility or case variants will have equal primary and 
  secondary weights (e.g. <i>a<sub>1</sub> = A<sub>1</sub></i> and <i>a<sub>2</sub> 
  = A<sub>2</sub></i>), but have different tertiary weights (e.g. <i>a<sub>3</sub> 
  &lt; A<sub>3</sub></i>). The unmarked characters will have tertiary weights 
  (such as <i>a<sub>3</sub></i>) equal to <i>MIN<sub>3</sub>.</i></p>
  <p>However, a well-formed Unicode Collation Element Table <i>does not</i> 
  guarantee that the meaning of a secondary or tertiary weight is uniform across 
  tables. For example, a <i>capital A</i> and <i>katakana ta</i> could both have 
  a tertiary weight of 3.</p>
  <h4>3.1.5 <a name="Collation_Graphemes">Collation Graphemes</a></h4>
  <p>A collation ordering determines a <i>collation grapheme cluster</i> (also 
  known as a collation grapheme or collation character), which is a sequence of 
  characters that is treated as a primary unit by the ordering. For example, <i>ch</i> 
  is a collation grapheme for a traditional Spanish ordering. These are 
  generally contractions, but may include additional ignorable characters. To 
  determine the boundaries for a collation grapheme starting at a given 
  position, use the following process.</p>
  <ol>
    <li>Set <code>oldPosition</code> to be equal to <code>position</code>.</li>
    <li>If <code>position</code> is at the end of the string, return it.</li>
    <li>Fetch the next collation element(s) mapped to by the character(s) at <code>position</code>.</li>
    <li>If the collation element(s) contain a non-ignorable and <code>position</code> 
      is not equal to <code>oldPosition</code>, return <code>position</code>.</li>
    <li>Otherwise set <code>position</code> to be the end of the characters 
      mapped.</li>
    <li>Loop back to step 2.</li>
  </ol>
  <p>For information on the use of collation graphemes, see <a href="../tr18.1">UTR 
  #18: Unicode Regular Expression Guidelines</a>.</p>
  <h3>3.2 <a name="Default_Unicode_Collation_Element_Table">Default Unicode 
  Collation Element Table</a></h3>
  <p>The Default Unicode Collation Element Table is provided in [<a href="tr10-9.html#AllKeys">AllKeys</a>]. 
  This table provides a mapping from characters to collation elements for all 
  the explicitly weighted characters. The mapping lists characters in the order 
  that they would be weighted. Any code points that are not explicitly mentioned 
  in this table are given a derived collation element, as described in <a href="tr10-9.html#Weight_Derivation">§7 
  Weight Derivation</a>. There are three types of mappings:</p>
  <ul>
    <li><b>Normal. </b>One Unicode character maps to one collation element.</li>
    <li><b>Expansions.</b> One Unicode character maps to a sequence of collation 
      elements.</li>
    <li><b>Contractions.</b> A sequence of Unicode characters maps to a sequence 
      of (one or more) collation elements.
      <ul>
        <li>These are provided for those instances where a canonical 
          decomposable character had to be given a distinct primary weight in 
          the main weight table, which implied that the canonically equivalent 
          combining character sequences should also be given the same weights. 
          These currently include Indic two-part vowels and with some Cyrillic 
          accented characters, to match the expected collating behavior for 
          those scripts.</li>
      </ul>
    </li>
  </ul>
  <p>This table is constructed to be consistent with the Unicode Canonical 
  Equivalence algorithm, and to respect the Unicode character properties. It is 
  not, however, merely algorithmically derivable from those data, since the 
  assignment of levels does take into account characteristics of particular 
  scripts. For example, in general the combining marks are Level 1 ignorables; 
  however, the Indic combining vowels are given non-zero Level 1 weights, since 
  they are as significant in sorting as the consonants.</p>
  <p>Any character may have variant forms or applied accents which affect 
  collation. Thus, for <tt>FULL STOP</tt> there are three compatibility 
  variants, a fullwidth form, a compatibility form, and a small form. These get 
  different tertiary weights, accordingly. For more information on how the table 
  was constructed, see <a href="tr10-9.html#Weight_Derivation">§7 Weight Derivation</a>.</p>
  <p>The following table shows the layout of the collation elements in the 
  Default Unicode Collation Element Table, ordered by primary weight:</p>
  <center>
  <table class="example">
    <caption>DUCET Layout</caption>
    <tr>
      <th align="center">Values</th>
      <th align="center">Range</th>
      <th align="center">Types of Characters</th>
    </tr>
    <tr>
      <td>X<sub>1</sub>,&nbsp;X<sub>2</sub>,&nbsp;X<sub>3</sub> = 0</td>
      <td>tertiary ignorables</td>
      <td>- Control Codes<br>
        - Format Characters<br>
        - Hebrew Points<br>
        - Tibetan Signs<br>
        ...</td>
    </tr>
    <tr>
      <td>X<sub>1</sub>,&nbsp;X<sub>2</sub> = 0;<br>
        X<sub>3</sub> ≠ 0</td>
      <td>secondary ignorables</td>
      <td><i>None in DUCET; could be in tailorings</i></td>
    </tr>
    <tr>
      <td>X<sub>1</sub> = 0;<br>
        X<sub>2</sub>,&nbsp;X<sub>3</sub> ≠ 0</td>
      <td>primary ignorable</td>
      <td>- Most non-spacing marks</td>
    </tr>
    <tr>
      <td rowspan="4">X<sub>1</sub>,&nbsp;X<sub>2</sub>,&nbsp;X<sub>3</sub>&nbsp;≠&nbsp;0</td>
      <td><a href="tr10-9.html#Variable_Weighting">variable</a></td>
      <td>- Whitespace,<br>
        - Punctuation,<br>
        - Symbols</td>
    </tr>
    <tr>
      <td>regular</td>
      <td>- Small number of exceptional symbols (e.g. U+02D0 (ː) <i>triangular 
        colon</i>)<br>
        - Numbers<br>
        - Latin<br>
        - Greek<br>
        ...</td>
    </tr>
    <tr>
      <td><a href="tr10-9.html#Implicit_Weights">implicit</a></td>
      <td>- CJK &amp; CJK compatibility (those not decomposed)<br>
        - CJK Extension A &amp; B<br>
        - Unassigned and others given implicit weights</td>
    </tr>
    <tr>
      <td><a href="tr10-9.html#Trailing_Weights">trailing</a></td>
      <td><i>None in DUCET; could be in tailorings</i></td>
    </tr>
  </table>
  </center>
  <p>For most languages, some degree of tailoring is required to match user 
  expectations. For more information, see <a href="tr10-9.html#Tailoring">§5 Tailoring</a>.</p>
  <h4>3.2.1 <a name="File_Format">File Format</a></h4>
  <p>Each of the files consists of a version line followed by an optional 
  variable-weight line, optional rearrangement lines, optional backwards lines, 
  and a series of entries, all separated by newlines. A '#' and any following 
  characters on a line are comments. Whitespace between literals is ignored. The 
  following is an extended BNF description of the format, where &quot;<i>x</i>+&quot; 
  indicates one or more <i>x</i>'s, &quot;<i>x</i>*&quot; indicates zero or more 
  <i>x</i>'s, &quot;<i>x?</i>&quot; indicates zero or one <i>x</i>, and 
  &lt;char&gt; is a hexadecimal Unicode code value.</p>
  <pre>&lt;collationElementTable&gt; := &lt;version&gt; 
                           &lt;variable&gt;?
                           &lt;backwards&gt;*
                           &lt;entry&gt;+</pre>
  <p>The version line is of the form:</p>
  <pre>@&lt;version&gt; := &lt;major&gt;.&lt;minor&gt;.&lt;variant&gt; &lt;eol&gt;</pre>
  <p>The variable-weight line has three possible values that may change the 
  weights of collation elements in processing (see <a href="tr10-9.html#3.2.2_Variable_Collation_Elements">§3.2.2 
  Variable Collation Elements</a>). The default is <code>shifted</code>.</p>
  <pre>&lt;variable&gt;       := '@variable ' &lt;variableChoice&gt; &lt;eol&gt;
&lt;variableChoice&gt; := 'blanked' | 'non-ignorable' | 'shifted'</pre>
  <p>A backwards line lists a level that is to be processed in reverse order. A 
  forwards line does the reverse. The default is for lines to be forwards.</p>
  <pre>&lt;backwards&gt; := ('@backwards ' | '@forwards ') &lt;levelNumber&gt; &lt;eol&gt;</pre>
  <p>Each entry is a mapping from character(s) to collation element(s), and is 
  of the following form:</p>
  <pre>&lt;entry&gt;       := &lt;charList&gt; ';' &lt;collElement&gt;+ &lt;eol&gt;
&lt;collElement&gt; := &quot;[&quot; &lt;alt&gt; &lt;char&gt; &quot;.&quot; &lt;char&gt; &quot;.&quot; &lt;char&gt; (&quot;.&quot; &lt;char&gt;)* &quot;]&quot;
&lt;alt&gt;         := &quot;*&quot; | &quot;.&quot;</pre>
  <p>In the Default Unicode Collation Element Table, the comment may contain 
  informative tags.</p>
  <p>Here are some selected entries taken from a particular version of the data 
  file. (It may not match the actual values in the current data file.)</p>
  <pre>0020 ; [*0209.0020.0002.0020] % SPACE
02DA ; [*0209.002B.0002.02DA] % RING ABOVE; COMPATSEQ
0041 ; [.06D9.0020.0008.0041] % LATIN CAPITAL LETTER A
3373 ; [.06D9.0020.0017.0041] [.08C0.0020.0017.0055] % SQUARE AU; COMPATSEQ
00C5 ; [.06D9.002B.0008.00C5] % LATIN CAPITAL LETTER A WITH RING ABOVE; CANONSEQ
212B ; [.06D9.002B.0008.212B] % ANGSTROM SIGN; CANONSEQ
0042 ; [.06EE.0020.0008.0042] % LATIN CAPITAL LETTER B
0043 ; [.0706.0020.0008.0043] % LATIN CAPITAL LETTER C
0106 ; [.0706.0022.0008.0106] % LATIN CAPITAL LETTER C WITH ACUTE; CANONSEQ
0044 ; [.0712.0020.0008.0044] % LATIN CAPITAL LETTER D</pre>
  <p>The entries in each file are ordered by collation element, not by 
  character, using a SHIFED comparison. This makes it easy to see the order in 
  which characters would be collated. Although this document describes collation 
  elements as three levels, the file contains a fourth level (as in <tt>[.0712.0020.0008.<b>0044</b>]</tt>) 
  which is computable. For more information, see <a href="tr10-9.html#Stability">§3.4 
  Stability</a>.</p>
  <p>Implementations can also add more customizable levels, as discussed above 
  under conformance. For example, an implementation might want to be capable not 
  only of handling the standard Unicode Collation, but also capable of emulating 
  an EBCDIC multi-level ordering (having a fourth-level EBCDIC binary order).&nbsp;</p>
  <h4><a name="3.2.2_Variable_Collation_Elements"></a>3.2.2      <a name="Variable_Weighting">Variable Weighting</a></h4>
  <p>Collation elements that are marked with an asterisk in a Unicode Collation 
  Element Table are known as <i>variable collation elements.</i></p>
  <table class="wide">
    <tr>
      <th align="LEFT" width="15%">
        <p align="LEFT">Character</th>
      <th align="LEFT" width="30%">
        <p align="LEFT">Collation Element</th>
      <th align="LEFT">
        <p align="LEFT">Name</th>
    </tr>
    <tr>
      <td><tt>0020 &quot; &quot;</tt></td>
      <td><tt>[*0209.0020.0002]</tt></td>
      <td>SPACE</td>
    </tr>
  </table>
  <p>Based on the setting of the variable weighting tag, collation elements can 
  be either treated as ignorables or not. When they are treated as ignorables, 
  then any sequence of ignorable characters that immediately follows the 
  variable collation element are also affected.</p>
  <p>There are four possible options for variable weighted characters, with the 
  default being <i><b>Shifted</b>:</i></p>
  <ul>
    <li><b>Blanked:</b> Variable collation elements and any subsequent 
      ignorables are reset so that their weights at levels one through three are 
      zero. For example,
      <ul>
        <li><i>SPACE</i> would have the value <tt>[.0000.0000.0000]</tt>
        <li>A combining grave accent after a space would have the value <tt>[.0000.0000.0000]</tt></li>
        <li><i>Capital A</i> would be unchanged, with the value <tt>[.06D9.0020.0008]</tt>
        <li>A combining grave accent after a <i>Capital A </i>would be unchanged</li>
      </ul>
    <li><b>Non-ignorable: </b>Variable collation elements are not reset to 
      ignorable, and get the weights explicitly mentioned in the file.
      <ul>
        <li><i>SPACE </i>would have the value <tt>[.0209.0020.0002]</tt>
        <li><i>Capital A</i> would be unchanged, with the value <tt>[.06D9.0020.0008]</tt>
        <li>Ignorables are unchanged.</li>
      </ul>
    <li><b>Shifted:</b> Variable collation elements are set to ignorable at 
      levels one through three. In addition, a new final-level weight is 
      appended, whose value depends on the type:<br>
      &nbsp;
      <div align="center">
        <center>
        <table class="values">
          <tr>
            <th width="33%">Type</th>
            <th width="33%">L4</th>
            <th width="34%">Examples</th>
          </tr>
          <tr>
            <td><i>Completely Ignorable</i></td>
            <td>0000</td>
            <td><i>NULL</i><tt><br>
              [.0000.0000.0000.0000]&nbsp;</tt></td>
          </tr>
          <tr>
            <td><i>Ignorable (L1, L2)<br>
              after Variable</i></td>
            <td>0000</td>
            <td><i>COMBINING GRAVE</i><tt><br>
              [.0000.0000.0000.0000]</tt></td>
          </tr>
          <tr>
            <td><i>Variable</i></td>
            <td>old L1</td>
            <td><i>SPACE</i><tt><br>
              [.0000.0000.0000.0209]</tt></td>
          </tr>
          <tr>
            <td><i>None of the above</i></td>
            <td>FFFF</td>
            <td><i>Capital A<br>
              </i><tt>[.06D9.0020.0008.FFFF]</tt></td>
          </tr>
        </table>
        </center>
      </div>
      <p>Any subsequent ignorables are reset so that their weights at levels one 
      through four are zero.</p>
      <ul>
        <li>A combining grave accent after a space would have the value <tt>[.0000.0000.0000.0000]</tt>.</li>
        <li>
          <p>A combining grave accent after a <i>Capital A </i>would be 
          unchanged.</p>
        </li>
      </ul>
    <li><b>Shift-Trimmed:</b> the same as <b>Shifted</b>, except that all 
      trailing FFFFs are trimmed from the sort key. This option is designed to 
      emulate POSIX behavior.</li>
  </ul>
  <blockquote>
    <p><b>Note: </b>The <i>shifted</i> option provides for improved orderings 
    when the variable collation elements are ignorable, while still using only 
    requiring three fields to be stored in memory for each collation element. It 
    does result in somewhat longer sort keys, although they can be compressed 
    (see <a href="tr10-9.html#Reducing_Sort_Key_Lengths">§6.1 Reducing Sort Key Lengths</a> 
    and <a href="tr10-9.html#Reducing_Table_Sizes">§6.3 Reducing Table Sizes)</a>.</p>
  </blockquote>
  <p align="left">The following gives an example of the differences between 
  orderings using the different options for variable collation elements. In this 
  example, sample strings differ by the third character: a letter, <i>space,</i> 
  '-'&nbsp;<i>hyphen-minus (002D)</i>, or '-'&nbsp;<i>hyphen (2010);</i> 
  followed by an uppercase/lowercase distinction. In the first column below, the 
  words with <i>hyphen-minus</i> and <i>hyphen</i> are separated by <i>deluge,</i> 
  since an <i>l</i> comes between them in Unicode code order. In the second 
  column, they are grouped together but before all letters in the third 
  position. This is because they are no longer ignorable, and have primary 
  values that differ from the letters. In the third column, the <i>hyphen-minus</i> 
  and <i>hyphen</i> are grouped together, and their differences are less 
  significant than between the deluge. In this case, it is because they are 
  ignorable, but their fourth level differences are according to the original 
  primary order, which is more intuitive than Unicode order.</p>
  <div align="center">
    <center>
    <table class="example">
      <tr>
        <th>
          <p align="left">Blanked</p>
        </th>
        <th>
          <p align="left">Non-<br>
          ignorable</p>
        </th>
        <th>
          <p align="left">Shift</p>
        </th>
        <th>
          <p align="left">Shift-<br>
          Trimmed</p>
        </th>
      </tr>
      <tr>
        <td align="left">
          <p align="left">death<br>
          <font color="#0000FF">de luge<br>
          de-luge</font><br>
          deluge<br>
          <font color="#0000FF">de-luge<br>
          de Luge<br>
          de-Luge</font><br>
          deLuge<br>
          <font color="#0000FF">de-Luge</font><br>
          demark</p>
        </td>
        <td align="left">
          <p align="left"><font color="#0000FF">de luge<br>
          de Luge<br>
          de-luge<br>
          de-Luge<br>
          de-luge<br>
          de-Luge</font><br>
          death<br>
          deluge<br>
          deLuge<br>
          demark</p>
        </td>
        <td align="left">
          <p align="left">death<br>
          <font color="#0000FF">de luge<br>
          de-luge<br>
          de-luge</font><br>
          deluge<br>
          <font color="#0000FF">de Luge<br>
          de-Luge<br>
          de-Luge<br>
          deLuge</font><br>
          demark</p>
        </td>
        <td align="left">
          <p align="left">death<br>
          deluge<br>
          <font color="#0000FF">de luge<br>
          de-luge<br>
          de-luge</font><br>
          deLuge<br>
          <font color="#0000FF">de Luge<br>
          de-Luge<br>
          de-Luge</font><br>
          demark</p>
        </td>
      </tr>
    </table>
    </center>
  </div>
  <p>Primaries for variable collation elements are not <i>interleaved</i> with 
  other primary weights. This allows for more compact storage of memory tables. 
  Rather than using a bit per collation element to determine whether the 
  collation element is variable, the implementation only needs to store the 
  maximum primary value for all the variable elements. All collation elements 
  with primary weights from 1 to that maximum are variables; all other collation 
  elements are not.</p>
  <h3>3.3 <a name="Well-Formed">Well-Formed Collation Element Tables</a></h3>
  <p>A well-formed Collation Element Table meets the following conditions:</p>
  <blockquote>
    <ol>
      <li><a name="ill-formed_definition"></a>Except in special cases detailed 
        in <a href="tr10-9.html#Large_Weight_Values">§6.2 Large Weight Values</a>, no 
        collation element can have a zero weight at Level N and a non-zero 
        weight at Level N-1.
        <ul>
          <li>For example, the secondary can only be ignorable if the primary 
            is.</li>
          <li>The reason for this will be explained under Step 4 of the main 
            algorithm.</li>
        </ul>
      </li>
      <li>All Level N weights in Level N-1 ignorables must be strictly less than 
        all weights in Level N-2 ignorables.
        <ul>
          <li>For example, secondaries in non-ignorables must be strictly less 
            than those in primary ignorables:
            <ul>
              <li>Given collation elements [C, D, E] and [0, A, B], where C ≠ 
                0 and A ≠ 0</li>
              <li>Then D <i>must be</i> less than A.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>No variable collation element has an ignorable primary.</li>
      <li>For all variable collation elements U, V, if there is a collation 
        element W such that U<sub>1</sub> <font size="3">≤</font> W<sub>1</sub> 
        and W<sub>1</sub> <font size="3">≤</font> V<sub>1</sub>, then W is 
        also variable.
        <ul>
          <li>This provision prevents interleaving, mentioned above.</li>
        </ul>
      </li>
    </ol>
  </blockquote>
  <h3>3.4 <a name="Stability">Stability</a></h3>
  <p>One very common confusion in terms of collation centers around the notion 
  of <i>stability</i> in sorting.<br>
  <br>
  A <i>stable sort</i> is one where two records with a field that compares as 
  equal will retain their order if sorted according to that field. This is a 
  property of the sorting algorithm, <i>not</i> the comparison mechanism. For 
  example, a bubble sort is stable, while a quick sort is not. This is a useful 
  property, but cannot be accomplished by modifications to the comparison 
  mechanism or tailorings.<br>
  <br>
  A <i>semi-stable collation</i> is different. It is a collation where strings 
  that are not canonical equivalents will not be judged to be equal. This is a 
  property of comparison, <i>not</i> the sorting algorithm. In general this is <i>not</i> 
  a particularly useful property; its implementation also typically requires 
  extra processing in string comparison or an extra level in sort keys, thus may 
  degrade performance to little purpose. However, if a semi-stable collation is 
  required, the specified mechanism is to append the NFD form of the original 
  string after the sort key, in step 3.10 below.</p>
  <p>The fourth-level weights in the Default Collation Element Table can be used 
  to provide an approximation of a semi-stable collation.</p>
  <p>Neither one of the above refers to the stability of the Default Collation 
  Element Table itself. For any particular version of the UCA, the contents of 
  that table will remain unchanged. The contents may, however, change <i>between</i> 
  successive versions of the UCA, as new characters are added, or as more 
  information is obtained about existing characters.</p>
  <p>Implementers should be aware that using different versions of the UCA, as 
  well as different versions of the Unicode Standard, could result in different 
  collation results of their data. There are numerous ways collation data could 
  vary across versions, for example:</p>
  <ol>
    <li>Code points that were unassigned in a previous version of the Unicode 
      Standard are now assigned in the current version, and as such, will have a 
      sorting semantic appropriate to the repertoire to which they belong. For 
      example, the code points U+103D0..U+103DF were undefined in Unicode 3.1. 
      Since they were assigned characters in Unicode 3.2, their sorting 
      semantics and respective sorting weights will change.</li>
    <li>Certain semantics of the Unicode standard could change between versions, 
      such that code points are treated in a manner different than previous 
      versions of the standard (for example, normalization errata).</li>
    <li>More information is gathered about a particular script, and in order to 
      provide a more linguistically accurate sort, the weight of a code point 
      may need to be adjusted.</li>
  </ol>
  <p>Any of these reasons could necessitate a change between versions with 
  regards to sort weights for code points, and as such, it is important that the 
  implementers specify the version of the UCA as well as the version of the 
  Unicode standard under which their data is sorted.</p>
  <h2><a name="Main_Algorithm"></a>4 Main Algorithm</h2>
  <p>The main algorithm has four steps. First is to normalize each input string, 
  second is to produce an array of collation elements for each string, and third 
  is to produce a sort key for each string from the collation elements. Two sort 
  keys can then be compared with a binary comparison; the result is the ordering 
  for the original strings.</p>
  <h3><a name="Step_1"></a>4.1 Normalize each input string</h3>
  <p><b>Step 1. </b>Produce a normalized form of each input string, applying <a href="tr10-9.html#S1.1">S1.1</a>, 
  <a href="tr10-9.html#S1.2">S1.2</a>, and <a href="tr10-9.html#S1.3">S1.3</a>.</p>
  <p><b><a name="S1.1">S1.1</a> </b>Use the Unicode canonical algorithm to 
  decompose characters according to the canonical mappings. That is, put the 
  string into Normalization Form D (see <a href="../tr15.1">UTR 
  #15: Unicode Normalization Forms</a>).</p>
  <ul>
    <li>Conformant implementations may skip this step in certain circumstances: 
      see <a href="tr10-9.html#Weight_Derivation">§7 Weight Derivation</a> for more 
      information.</li>
  </ul>
  <b><a name="S1.2">S1.2</a> </b>If any character has the <a href="http://www.unicode.org/Public/UNIDATA/PropList.html">Logical_Order_Exception</a> 
  property (see <a href="tr10-9.html#Rearrangement">§3.1.3 Rearrangement</a>), swap it and 
  the succeeding character (if there is one). In practice, rearranging 
  characters should never appear adjacent to one another. If for some reason 
  they do, then successive pairs in the sequence will be swapped.
  <ul>
    <li>For example, “เข” (...\u0E40\u0E02...) is rearranged to “ขเ” 
      (...\u0E02\u0E40...)</li>
  </ul>
  <p><b><a name="S1.3">S1.3</a> </b>If any character is marked as ignorable at 
  all levels, remove it from the string.</p>
  <blockquote>
    <p>For example, if a Control-A (U+0001) has a collation element 
    [0000.0000.0000], then it will be removed.</p>
  </blockquote>
  <table class="wide">
    <caption style="text-align:left"><i>Example:</i></caption>
    <tr>
      <td width="15%">
        <p align="left">input string:</p>
      </td>
      <td>
        <p align="left">cáb&lt;control-A&gt;</p>
      </td>
    </tr>
    <tr>
      <td>
        <p align="left">normalized string:</p>
      </td>
      <td>
        <p align="left">ca´b</p>
      </td>
    </tr>
  </table>
  &nbsp;<br>
  <h3><a name="Step_2"></a>4.2 Produce an array of collation elements for each 
  string</h3>
  <p><b>Step 2. </b>The collation element array is built by sequencing through 
  the normalized form as follows:</p>
  <blockquote>
    <p><b>Note: </b>A combining mark in a string is called <i>blocked</i> if 
    there is another combining mark of the same canonical combining class or 
    zero between it and the last character of canonical combining class 0.</p>
  </blockquote>
  <b><a name="S2.1">S2.1</a> </b>Find the longest initial substring S at each 
  point that has a match in the table.
  <blockquote>
    <p><b><a name="S2.1.1">S2.1.1</a> </b>If there are any combining marks 
    following S, process each combining mark C.</p>
    <p><b><a name="S2.1.2">S2.1.2</a> </b>If C is not blocked, find if S + C has 
    a match in the table.</p>
    <p><b><a name="S2.1.3">S2.1.3</a> </b>If there is a match, replace S by S + 
    C, and remove C.</p>
  </blockquote>
  <p><b><a name="S2.2">S2.2</a></b> Fetch the corresponding collation element(s) 
  from the table if there is a match. If there is no match, synthesize a weight 
  as described in <a href="tr10-9.html#Implicit_Weights">§7.1 Derived Collation Elements</a></p>
  <p><b><a name="S2.3">S2.3</a> </b>Process collation elements according to the 
  variable-weight setting, as described in <a href="tr10-9.html#3.2.2_Variable_Collation_Elements">§3.2.2 
  Variable Weighting</a>.</p>
  <p><b><a name="S2.4">S2.4</a></b> Append the collation element(s) to the 
  collation element array.</p>
  <p><b><a name="S2.5">S2.5</a> </b>Proceed to the next point in the string 
  (past S).</p>
  <p><b><a name="S2.6">S2.6</a> </b>Loop until the end of the string is reached.</p>
  <p><i>Conformant implementations may skip steps 2.1.1 through 2.1.3 if their 
  repertoire of supported character sequences does not require this level of 
  processing.</i></p>
  <blockquote>
    <p><b>Note: </b>The reason for considering the extra combining marks C is 
    that otherwise irrelevant characters could interfere with matches in the 
    table. For example, suppose that the contraction <i>&lt;a, combining_ring&gt;</i> 
    (=&nbsp;<i>å</i>) is ordered after <i>z</i>. If a string consists of the 
    three characters <i>&lt;a, combining_ring, combining_cedilla&gt;</i>, then 
    the normalized form is <i>&lt;a, combining_cedilla, combining_ring&gt;</i>, 
    which separates the <i>a</i> from the <i>combining_ring</i>. If we didn't 
    have the step of considering the extra combining marks, this string would 
    compare incorrectly as after <i>a</i> and not after <i>z</i>.</p>
    <p>If the desired ordering treats <i>&lt;a, combining_cedilla&gt;</i> as a 
    contraction which should take precedence over <i>&lt;a, combining_ring&gt;,</i> 
    then an additional mapping for the combination <i>&lt;a, combining_ring, 
    combining_cedilla&gt;</i> can be introduced to produce this effect.</p>
    <p><b>Note: </b><font color="#000000">For conformance to Unicode canonical 
    equivalence, only unblocked combining marks are matched. For example, <i>&lt;a, 
    combining_macron, combining_ring&gt;</i> would compare as after <i>a-macron</i>, 
    and not after <i>z</i>. As in the previous note, additional mappings can be 
    added to customize behavior.</font></p>
  </blockquote>
  <table class="wide">
    <caption style="text-align:left"><i>Example:</i></caption>
    <tr>
      <td width="15%"><font color="#000000">normalized string:</font></td>
      <td><font color="#000000">ca</font>´<font color="#000000">b</font></td>
    </tr>
    <tr>
      <td><font color="#000000">collation element array:</font></td>
      <td><tt><font color="#000000" size="-1">[0706.0020.0002], 
        [06D9.0020.0002], [0000.0021.0002], [06EE.0020.0002]</font></tt></td>
    </tr>
  </table>
  &nbsp;<br>
  <h3><a name="Step_3"></a>4.3 Form a sort key for each string</h3>
  <p><b>Step 3. </b>The sort key is formed by successively appending weights 
  from the collation element array. The weights are appended from each level in 
  turn, from 1 to 3. (Backwards weights are inserted in reverse order.)</p>
  <p>An implementation may allow the <i>maximum level</i> to be set to a smaller 
  level than the available levels in the collation element array. For example, 
  if the maximum level is set to 2, then level 3 and higher weights are not 
  appended to the sort key. Thus any differences at levels 3 and higher will be 
  ignored, leveling any such differences in string comparison.</p>
  <p>Here is a more detailed statement of the algorithm:</p>
  <b><a name="S3.1">S3.1</a> </b>For each weight level L in the collation 
  element array from 1 to the maximum level,
  <blockquote>
    <p><b><a name="S3.2">S3.2</a> </b>If L is not 1, append a <i>level 
    separator*</i></p>
    <p><b><a name="S3.3">S3.3</a> </b>If the collation element table is forwards 
    at level L,</p>
    <blockquote>
      <p><b><a name="S3.4">S3.4</a> </b>For each collation element CE in the 
      array</p>
      <blockquote>
        <p><b><a name="S3.5">S3.5</a> </b>Append CE<sub>L</sub> to the sort key 
        if CE<sub>L</sub> is non-zero.</p>
      </blockquote>
    </blockquote>
    <p><b><a name="S3.6">S3.6</a> </b>Else the collation table is backwards at 
    level L, so</p>
    <blockquote>
      <p><b><a name="S3.7">S3.7</a> </b>Form a list of all the non-zero CE<sub>L</sub> 
      values.</p>
      <p><b><a name="S3.8">S3.8</a> </b>Reverse that list</p>
      <p><b><a name="S3.9">S3.9</a> </b>Append the CE<sub>L</sub> values from 
      that list to the sort key.</p>
    </blockquote>
  </blockquote>
  <blockquote>
    <p><b>* </b>The level separator is zero (0000), which is guaranteed to be 
    lower than any weight in the resulting sort key. This guarantees that when 
    two strings of unequal length are compared, where the shorter string is a 
    prefix of the longer string, the longer string is always sorted after the 
    shorter (in the absence of special features like contractions). For example:</p>
  </blockquote>
  <p align="center">&quot;abc&quot; &lt; &quot;abcX&quot; where &quot;X&quot; 
  can be any character(s)</p>
  <p><b><a name="S3.10">S3.10</a></b> If a semi-stable sort is required, then 
  after all the level weights have been added, append a copy of the NFD version 
  of the original string.</p>
  <blockquote>
    <table class="wide">
      <caption style="text-align:left"><i>Example:</i></caption>
      <tr>
        <td width="15%">collation element array:</td>
        <td><tt>[0706.0020.0002], [06D9.0020.0002], [0000.0021.0002], 
          [06EE.0020.0002]</tt></td>
      </tr>
      <tr>
        <td>sort key:</td>
        <td><tt>0706 06D9 06EE 0000 0020 0020 0021 0020 0000 0002 0002 0002 0002</tt></td>
      </tr>
    </table>
  </blockquote>
  &nbsp;&nbsp;
  <h3><a name="Step_4"></a>4.4 Compare the sort keys</h3>
  <p><b>Step 4. </b>Compare the sort keys for each of the input strings, using a 
  binary comparison. This means that:</p>
  <ul>
    <li>Level 3 differences are ignored if there are any Level 1 or 2 
      differences
    <li>Level 2 differences are ignored if there are any Level 1 differences
    <li>Level 1 differences are never ignored.
  </ul>
  <blockquote>
    <table class="wide">
      <caption style="text-align:left"><i>Example:</i></caption>
      <tr>
        <th align="LEFT">
          <p align="LEFT">String</th>
        <th align="LEFT">
          <p align="LEFT">Sort Key</th>
      </tr>
      <tr>
        <td><font color="#000000">cab</font></td>
        <td><tt><u><b><font color="#ff9c05">0706</font></b></u> 06D9 06EE 0000 
          0020 0020 <u><b><font color="#00ba00">0020</font></b></u> 0000 <u><b><font color="#0099ff">0002</font></b></u> 
          0002 0002</tt></td>
      </tr>
      <tr>
        <td>Cab</td>
        <td><tt><u><b><font color="#ff9c05">0706</font></b></u> 06D9 06EE 0000 
          0020 0020 <u><b><font color="#00ba00">0020</font></b></u> 0000 <u><b><font color="#0099ff">0008</font></b></u> 
          0002 0002</tt></td>
      </tr>
      <tr>
        <td>cáb</td>
        <td><tt><u><b><font color="#ff9c05">0706</font></b></u> 06D9 06EE 0000 
          0020 0020 <u><b><font color="#00ba00">0021</font></b></u> 0020 0000 
          0002 0002 0002 0002</tt></td>
      </tr>
      <tr>
        <td>dab</td>
        <td><tt><u><b><font color="#ff9c05">0712</font></b></u> 06D9 06EE 0000 
          0020 0020 0020 0000 0002 0002 0002</tt></td>
      </tr>
    </table>
  </blockquote>
  <p>In this example, &quot;cab&quot; &lt;<sub>3</sub> &quot;Cab&quot; &lt;<sub>2</sub> 
  &quot;cáb&quot; &lt;<sub>1</sub> &quot;dab&quot;. The differences that 
  produce the ordering are shown by the <u><b>bold underlined</b></u> items:</p>
  <ul>
    <li>For the first two strings, the first difference is in <b><tt><font color="#0099ff">0002</font></tt></b> 
      vs. <b><tt><font color="#0099ff">0008</font></tt></b> (Level&nbsp;3)
    <li>For the middle two strings the first difference is in <b><tt><font color="#00ba00">0020</font></tt></b> 
      vs. <b><tt><font color="#00ba00">0021</font></tt></b> (Level&nbsp;2)
    <li>For the last two strings, the first difference is in <b><tt><font color="#ff9c05">0706</font></tt></b> 
      vs. <b><tt><font color="#ff9c05">0712</font></tt></b> (Level&nbsp;1).
  </ul>
  <blockquote>
    <p><b>Note: </b><a name="ill-formed_reason"></a>At this point we can explain 
    the reason for disallowing <a href="tr10-9.html#ill-formed_definition">ill-formed 
    weights</a>. If ill-formed weights were allowed, the ordering of elements 
    can be incorrectly reflected in the sort key. For example, suppose the 
    secondary weights of the Latin characters were zero (ignorable) and that (as 
    normal) the primary weights of case-variants are equal: that is, <i>a<sub>1</sub> 
    = A<sub>1</sub>.</i> Then the following incorrect keys would be generated:</p>
    <ol>
      <li><i>&quot;áe&quot; = &lt;a, acute, e&gt; =&gt; [a<sub>1</sub> e<sub>1</sub> 
        0000 acute<sub>2</sub> 0000 <u><b>a<sub>3</sub></b></u> acute<sub>3</sub> 
        e<sub>3</sub>...]</i>
      <li><i>&quot;Aé&quot; = &lt;A, e, acute&gt; =&gt; [a<sub>1</sub> e<sub>1</sub> 
        0000 acute<sub>2</sub> 0000 <u><b>A<sub>3</sub></b></u> acute<sub>3</sub> 
        e<sub>3</sub>...]</i>
    </ol>
    <p>Since the secondary weights for <i>a, A, </i>and<i> e</i> are lost in 
    forming the sort key, the relative order of the acute is also lost, 
    resulting in an incorrect ordering based solely on the case of <i>A</i> vs <i>a</i>. 
    With well-formed weights, this does not happen, and you get the following 
    correct ordering:</p>
    <ol>
      <li><i>&quot;Aé&quot; = &lt;A, e, acute&gt; =&gt; [a<sub>1</sub> e<sub>1</sub> 
        0000 a<sub>2</sub> <u><b>e<sub>2</sub></b></u> acute<sub>2</sub> 0000 a<sub>3</sub> 
        acute<sub>3</sub> e<sub>3</sub>...]</i>
      <li><i>&quot;áe&quot; = &lt;a, acute, e&gt; =&gt; [a<sub>1</sub> e<sub>1</sub> 
        0000 a<sub>2</sub> <u><b>acute<sub>2</sub></b></u> e<sub>2</sub> 0000 A<sub>3</sub> 
        acute<sub>3</sub> e<sub>3</sub>...]</i>
    </ol>
    <p>However, there are circumstances--typically in expansions--where 
    higher-level weights in collation elements can be zeroed (resulting in 
    ill-formed collation elements) without consequence (see <a href="tr10-9.html#Large_Weight_Values">§6.2 
    Large Weight Values</a>). Implementations are free to do this as long as 
    they produce the same result as with well-formed tables.</p>
  </blockquote>
  <h2 align="left"><a name="Tailoring"></a>5 Tailoring</h2>
  <p align="left">Tailoring is any well-defined syntax that takes the Default 
  Unicode Collation Element Table and produces another well-formed Unicode 
  Collation Element Table. This syntax can provide linguistically-accurate 
  collation, if desired. Such syntax will usually allow for the following 
  capabilities:</p>
  <ol>
    <li>
      <p align="left">Reordering any character (or contraction) with respect to 
      others in the standard ordering. Such a reordering can represent a Level 1 
      difference, Level 2 difference, Level 3 difference, or identity (in levels 
      1 to 3). Since such reordering includes sequences, arbitrary multiple 
      mappings can be specified.
    <li>
      <p align="left">Setting the secondary level to be backwards (French) or 
      forwards (normal).
    <li>
      <p align="left">Set variable weighting options.
    <li>
      <p align="left">Customizing the exact list of variable collation elements.
  </ol>
  <p align="left">For examples of tailoring syntax, see <a href="tr10-9.html#Comparison_to_Java">§6.9 
  Tailoring Example: Java</a>.</p>
  <h3 align="left"><a name="Preprocessing"></a>5.1 Preprocessing</h3>
  <p align="left">In addition to tailoring, some implementation may choose to 
  preprocess the text for special purposes. Once such preprocessing is done, the 
  standard algorithm can be applied.</p>
  <p align="left">Examples include:</p>
  <ul>
    <li>
      <p align="left">mapping &quot;McBeth&quot; to &quot;MacBeth&quot;
    <li>
      <p align="left">mapping &quot;St.&quot; to &quot;Street&quot; or 
      &quot;Saint&quot;, depending on the context
    <li>
      <p align="left">padding digits with zeros to approximate numeric order
    <li>
      <p align="left">dropping articles, such as <i>a</i> or <i>the</i>
    <li>
      <p align="left">using extra information, such as pronunciation data for 
      Han characters
  </ul>
  <p align="left">Such preprocessing is outside of the scope of this document.</p>
  <h2 align="left"><a name="Implementation_Notes"></a>6 Implementation Notes</h2>
  <p align="left">As noted above for efficiency, implementations may vary from 
  this logical algorithm so long as they produce the same result. The following 
  items discuss various techniques that can be used for reducing sort key 
  length, reducing table sizes, customizing for additional environments, 
  searching, and other topics.</p>
  <h3 align="left"><a name="Reducing_Sort_Key_Lengths"></a>6.1 Reducing Sort Key 
  Lengths</h3>
  <p align="left">The following discuss methods of reducing sort key lengths. If 
  these methods are applied to all of the sort keys produced by an 
  implementation, they can result in significantly shorter and more efficient 
  sort keys while retaining the same ordering.</p>
  <h4>6.1.1 <a name="Eliminating_level_separators">Eliminating level separators</a></h4>
  <p>Level separators are not needed between two levels in the sort key, if the 
  weights are properly chosen. For example, if all L3 weights are less than all 
  L2 weights, then no level separator is needed between them. If there is a 
  fourth level, then the separator before it needs to be retained.</p>
  <p>For example, here is a sort key with these level separators removed.</p>
  <table class="wide">
    <tr>
      <th align="LEFT">
        <p align="LEFT">String</th>
      <th align="LEFT">
        <p align="LEFT">Sort Key</th>
    </tr>
    <tr>
      <td width="15%">càb (0)</td>
      <td><tt>0706 06D9 06EE <b>0000</b> 0020 0020 0021 0020 <b>0000</b> 0002 
        0002 0002 0002</tt></td>
    </tr>
    <tr>
      <td>càb (1)</td>
      <td><tt>0706 06D9 06EE 0020 0020 0021 0020 0002 0002 0002 0002</tt></td>
    </tr>
  </table>
  <p>While this technique is relatively easy to implement, it can interfere with 
  other compression methods.</p>
  <h4>6.1.2 <a name="L2/L3_in_8_bits">L2/L3 in 8 bits</a></h4>
  <p>The L2 and L3 weights commonly are small values. Where that condition 
  occurs for all possible values, they can then be represented as single 8-bit 
  quantities.</p>
  <p>Here is the above example with both these changes (and grouping by bytes). 
  Note that the separator has to remain after the primary weight when combining 
  these techniques. If any separators are retained (such as before the fourth 
  level), they need to have the same width as the previous level.</p>
  <table class="wide">
    <tr>
      <th align="LEFT">
        <p align="LEFT">String</th>
      <th align="LEFT">
        <p align="LEFT">Sort Key</th>
    </tr>
    <tr>
      <td width="15%">càb (0)</td>
      <td><tt>07 06 06 D9 06 EE <b>00 00</b> 00 20 00 20 00 21 00 20 00 00 00 02 
        00 02 00 02 00 02</tt></td>
    </tr>
    <tr>
      <td>càb (1,2)</td>
      <td><tt>07 06 06 D9 06 EE <b>00 00</b> 20 20 21 20 02 02 02 02</tt></td>
    </tr>
  </table>
  <h4><br>
  6.1.3 <a name="Machine_Words">Machine Words</a></h4>
  <p>The sort key can be represented as an array of different quantities 
  depending on the machine architecture. For example, comparisons as arrays of 
  32-bit quantities may be much faster on some machines. If this is done, the 
  original is to be padded with trailing (not leading) zeros as necessary.</p>
  <table class="wide">
    <tr>
      <th align="LEFT">
        <p align="LEFT">String</th>
      <th align="LEFT">
        <p align="LEFT">Sort Key</th>
    </tr>
    <tr>
      <td width="15%">càb (1,2)</td>
      <td><tt>07 06 06 D9 06 EE 00 00 20 20 21 20 02 02 02 02</tt></td>
    </tr>
    <tr>
      <td>càb (1,2,3)</td>
      <td><tt>070606D9 06EE0000 20202120 02020202</tt></td>
    </tr>
  </table>
  &nbsp;
  <h4>6.1.4 <a name="Run-length_Compression">Run-length Compression</a></h4>
  <p>Generally sort keys don't differ much in the secondary or tertiary weights, 
  so you tend to end up with keys with a lot of repetition. This also occurs 
  with quaternary weights generated with the shifted parameter. By the structure 
  of the collation element tables, there are also many weights that are never 
  assigned at a given level in the sort key. You can take advantage of these 
  regularities in these sequences to compact the length — while retaining the 
  same sort sequence — by using the following technique. (There are other 
  techniques that can also be used.)</p>
  <p>This is a logical statement of the process: the actual implementation can 
  be much faster and performed as the sort key is being generated.</p>
  <ul>
    <li>For each level <b><i>n, </i></b>find the most common value COMMON 
      produced at that level by the collation element table for typical strings. 
      For example, for the Default Unicode Collation Element Table, this is:
      <ul>
        <li>0020 for the secondaries (corresponding to unaccented characters)
        <li>0002 for tertiaries (corresponding to lowercase or unmarked letters)
        <li>FFFF for quaternaries (corresponding to non-ignorables with the 
          shifted parameter)
      </ul>
    <li>Reassign the weights in the collation element table at level <b><i>n</i></b> 
      to create a gap of size GAP above COMMON. Typically for secondaries or 
      tertiaries this is done after the values have been reduced to a byte range 
      by the above methods. Here is a mapping that moves weights up or down to 
      create a gap in a byte range.<br>
      <tt>w -&gt; w + 01 - MIN, for MIN &lt;= w &lt; COMMON<br>
      w -&gt; w + FF - MAX, for COMMON &lt; w &lt;= MAX</tt>
    <li>At this point, weights go from 1 to MINTOP, and from MAXBOTTOM to MAX. 
      You'll use these new unassigned values to run-length encode sequences of 
      COMMON weights.
    <li>When generating a sort key, look for maximal sequences of <b>m</b> 
      COMMON values in a row. Let W be the weight right after the sequence.
      <ul>
        <li>If W &lt; COMMON (or there is no W), replace the sequence by a 
          synthetic low weight equal to (MINTOP&nbsp;+&nbsp;m).
        <li>If W &gt; COMMON, replace the sequence by a synthetic high weight 
          equal to (MAXBOTTOM&nbsp;-&nbsp;m).
      </ul>
      <p>In the following example, the low weights are 01, 02; the high weights 
      are FE, FF; and the common weight is 77.
  </ul>
  <p align="center"><i>Examples</i></p>
  <div align="center">
    <center>
    <table class="example">
      <tr>
        <th align="LEFT" width="50%">
          <p align="center">Original Weights</th>
        <th align="LEFT" width="50%">
          <p align="center">Compressed Weights</th>
      </tr>
      <tr>
        <td width="50%">
          <pre>01
02
77 01
77 02
77 77 01
77 77 02
77 77 77 01
77 77 77 02
...
77 77 77 FE
77 77 77 FF
77 77 FE
77 77 FF
77 FE
77 FF
FE
FF</pre>
        </td>
        <td width="50%">
          <pre>01
02
03 01
03 02
04 01
04 02
05 01
05 02
...
FB FE
FB FF
FC FE
FC FF
FD FE
FD FF
FE
FF</pre>
        </td>
      </tr>
    </table>
    </center>
  </div>
  <ul>
    <li>The last step is a bit too simple, since we have to keep the synthetic 
      weights from colliding with other values with long strings of COMMON 
      weights. This is done by using a sequence of synthetic weights, absorbing 
      as much length into each one as possible: define a value BOUND between 
      MINTOP and MAXBOTTOM (the exact value can be chosen based on the expected 
      frequency of synthetic low weights vs. high weights for the particular 
      collation element table).
      <ul>
        <li>If a synthetic low weight would not be less than BOUND, use a 
          sequence of low weights of the form (BOUND-1)..(BOUND-1)(MINTOP&nbsp;+&nbsp;remainder) 
          to express the length of the sequence.
        <li>Similarly, if a synthetic high weight would be less than BOUND, use 
          a sequence of high weights of the form (BOUND)..(BOUND)(MAXBOTTOM&nbsp;-&nbsp;remainder).
      </ul>
  </ul>
  <p>The result of this process are keys that are never greater than the 
  original, are generally much shorter, and result in the same comparisons.</p>
  <h3><a name="Large_Weight_Values"></a>6.2 Large Weight Values</h3>
  <p><a name="ill-formed_example"></a>If a collation sequence requires more than 
  65,535 weight values (or 65,024 values where zero bytes are avoided), this can 
  still be accommodated by using multiple collation elements for a single 
  character. For example, suppose that 50,000 UTF-16 supplementary characters 
  are assigned in a particular implementation, and that these are to be sorted 
  after X. Simply assign them all dual collation elements of the form</p>
  <blockquote>
    <code>[(X<sub>1</sub>+1).0000.0000], [yyyy.zzzz.wwww]</code>
  </blockquote>
  <p>They will then sort properly with respect to each other and to the rest of 
  the characters. (The first collation element is one of the instances where 
  ill-formed collation elements are allowed. Since the second collation element 
  is well-formed and the first element will only occur in combination, ordering 
  is preserved.)</p>
  <h3><a name="Reducing_Table_Sizes"></a>6.3 Reducing Table Sizes</h3>
  <p>The data tables required for full Unicode sorting can be quite sizable. 
  This section discusses ways to significantly reduce the table size in memory. 
  These have very important implications for implementations.</p>
  <h4>6.3.1 <a name="Contiguous_weight_ranges">Contiguous Weight Ranges</a></h4>
  <p>The Default Unicode Collation Element Table has secondary weights that are 
  greater than 00FF. This is the result of the derivation described in <a href="tr10-9.html#Weight_Derivation">§7 
  Weight Derivation</a>. However, these values can be compacted to a range of 
  values that don't exceed 00FF. Whenever collation elements have different 
  primary weights, the ordering of their secondary weights is immaterial. Thus 
  all of the secondaries that share a single primary can be renumbered to a 
  contiguous range without affecting the resulting order. Composite characters 
  still need to be handled correctly if normalization is avoided as discussed in 
  <a href="tr10-9.html#Weight_Derivation">§7 Weight Derivation</a>.</p>
  <p>For example, for the primary value 0820 (for the letter O), there are 31 
  distinct secondary values ranging from 0020 to 012D. These can be renumbered 
  to the contiguous range from 0020 to 003F, which is less than 00FF.</p>
  <h4>6.3.2 <a name="Escape_hatch">Escape Hatch</a></h4>
  <p>Although the secondary and tertiary weights for the Default Unicode 
  Collation Element Table can both fit within one byte, of course, any 
  particular tailored table could conceivably end up with secondary or tertiary 
  weights that exceed what can be contained in a single byte. However, the same 
  technique used for large weight values can also be used for implementations 
  that do not want to handle more than 00FF values for a particular weight.</p>
  <p>For example, the Java collation implementation only stores 8-bit quantities 
  in level 2 and level 3. However, characters can be given L2 or L3 weights with 
  greater values by using a series of two collation elements. For example, with 
  characters requiring 2000 weights at L2, then 248 characters can be given 
  single keys, while 1792 are given 2 collation keys of the form 
  [yyyy.00zz.00ww] [0000.00nn.0000]. (The 248 can be chosen to be the higher 
  frequency characters!)</p>
  <h4>6.3.3 <a name="Leveraging_Unicode_tables">Leveraging Unicode Tables</a></h4>
  <p>Since all canonically decomposable characters are decomposed in Step 1.1, 
  no collation elements need to be supplied for them. This includes a very large 
  number of characters, not only a large number of Latin and Greek characters, 
  but also the very large number of Hangul Syllables.</p>
  <p>Since most compatibility decomposable characters in the default table can 
  be algorithmically generated from the decomposition, no collation elements 
  need to be stored for those decomposable characters: the collation elements 
  can be generated on the fly with only a few exceptions entered in the table. 
  The collation elements for the Han characters (unless tailored) are 
  algorithmically derived; no collation elements need to be stored for them 
  either. For more information, see <a href="tr10-9.html#Weight_Derivation">§7 Weight 
  Derivation</a>.</p>
  <p>This means that only a fraction of the total number of Unicode characters 
  needs to have an explicit collation element associated with them. This can cut 
  down the memory storage considerably.</p>
  <h4>6.3.4 <a name="Reducing_the_Repertoire">Reducing the Repertoire</a></h4>
  <p>If characters are not fully supported by an implementation, then their code 
  points can be treated as if they were unassigned. This allows them to be 
  algorithmically constructed from code point values instead of including them 
  in a table. This can significantly reduce the size of the required tables. See 
  <a href="tr10-9.html#Implicit_Weights">§7.1 Derived Collation Elements</a> for more 
  information.</p>
  <h4>6.3.5 <a name="Memory_Table_Size">Memory Table Size</a></h4>
  <p>Applying the above techniques, an implementation can thus safely pack all 
  of the data for a collation element into a single 32-bit quantity: 16 for the 
  primary, 8 for the secondary and 8 for the tertiary. Then applying techniques 
  such as the Two-Stage table approach described in Section 5.7 of The Unicode 
  Standard, Version 2.0, the mapping table from characters to collation elements 
  can both fast and small. For an example of how this can be done, see <a href="tr10-9.html#Flat_File_Example">§6.11 
  Flat File Example</a>.</p>
  <h3><a name="Avoiding_Zero_Bytes"></a>6.4 Avoiding Zero Bytes</h3>
  <p>If the resulting sort key is to be a C-string, then zero bytes must be 
  avoided. This can be done by:</p>
  <ul>
    <li>using the value 0101<sub>16</sub> for the level separator instead of 
      0000.
    <li>preprocessing the weight values to avoid zero bytes, such as remapping 
      as follows:
      <ul>
        <li>x =&gt; 0101<sub>16</sub> + (x / 255)*256 + (x % 255)
      </ul>
    <li>Where the values are limited to 8-bit quantities (as discussed above), 
      zero bytes are even more easily avoided by just using 01 as the level 
      separator (where one is necessary), and mapping weights by
      <ul>
        <li>x =&gt; 01 + x.
      </ul>
  </ul>
  <h3><a name="Avoiding_Normalization"></a>6.5 Avoiding Normalization</h3>
  <p><a name="noCombining"></a>Implementations that do not handle separate 
  combining marks can map decomposable characters (such as &quot;à&quot;) to 
  single collation elements with different Level 2 weights for the different 
  accents. For more information, see <a href="tr10-9.html#Weight_Derivation">§7 Weight 
  Derivation</a>. However, this does required including the mappings for these 
  characters in the collation table, which will increase the size substantially 
  unless the collation elements for the Hangul Syllables are computed 
  algorithmically.</p>
  <h3><a name="Case_Comparisons"></a>6.6 Case Comparisons</h3>
  <p>In some languages, it is common to sort lowercase before uppercase; in 
  other languages this is reversed. Often this is more dependent on the 
  individual concerned, and is not standard across a single language. It is 
  strongly recommended that implementations provide parameterization that allow 
  uppercase to be sorted before lowercase, and provide information as to the 
  standard (if any) for particular countries. This can easily be done to the 
  Default Unicode Collation Element Table before tailoring by remapping the L3 
  weights (see <a href="tr10-9.html#Weight_Derivation">§7 Weight Derivation</a>). It can be 
  done after tailoring by finding the case pairs and swapping the collation 
  elements.</p>
  <h3><a name="Incremental_Comparison"></a>6.7 Incremental Comparison</h3>
  <p>Implementations do not actually have to produce full sort keys. Collation 
  elements can be incrementally generated as needed from two strings, and 
  compared with an algorithm that produces the same results as sort keys would 
  have. The choice of which algorithm to use depends on the number of 
  comparisons between the same strings.</p>
  <ul>
    <li>Generally incremental comparison is <i>more</i> efficient than producing 
      full sort keys if strings are only to be compared once and if they are 
      generally dissimilar, since differences are caught in the first few 
      characters without having to process the entire string.
    <li>Generally incremental comparison is <i>less</i> efficient than producing 
      full sort keys if items are to be compared multiple times.
  </ul>
  <p>However, it is very tricky to produce an incremental comparison that 
  produces correct results. For example, some implementations have not even been 
  transitive! Be sure to test any code for incremental comparison thoroughly.</p>
  <h3><a name="Catching_Mismatches"></a>6.8 Catching Mismatches</h3>
  <p>Sort keys from two different tailored collations cannot be compared, since 
  the weights may end up being rearranged arbitrarily. To catch this case, 
  implementations can produce a hash value from the collation data, and prepend 
  it to the sort key. Except in extremely rare circumstances, this will 
  distinguish the sort keys. The implementation then has the opportunity to 
  signal an error.</p>
  <h3><a name="Comparison_to_Java"></a>6.9 Tailoring Example: Java</h3>
  <p>Java 2 implements a number of the tailoring features described in this 
  document. The following summarizes these features (for more information, see 
  Collator on [<a href="tr10-9.html#JavaCollator">JavaCollator</a>]; for more powerful 
  features, see [<a href="tr10-9.html#ICUCollator">ICUCollator</a>]).</p>
  1. Java doesn't use a default table in the Unicode Collation Element format: 
  instead it always uses a tailoring syntax. Here is a description of the 
  entries:
  <p>&nbsp;
  <table class="syntax">
    <tr>
      <th>Syntax</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>&nbsp;&amp; y &lt; x</td>
      <td>Make x primary-greater than y</td>
    </tr>
    <tr>
      <td>&nbsp;&amp; y ; x</td>
      <td>Make x secondary-greater than y</td>
    </tr>
    <tr>
      <td>&nbsp;&amp; y , x</td>
      <td>Make x tertiary-greater than y</td>
    </tr>
    <tr>
      <td>&nbsp;&amp; y = x</td>
      <td>Make x equal to y</td>
    </tr>
  </table>
  <br>
  Either x or y can be more than one character, to handle contractions and 
  expansions. NULL is completely ignorable, so by using the above operations, 
  various levels of ignorable characters can be specified.
  <p>2. Entries can be abbreviated in a number of ways:
  <ul>
    <li>They do not need to be separated by newlines.</li>
    <li>Characters can be specified directly, instead of using their hexadecimal 
      Unicode values.</li>
    <li>Wherever you have rules of the form &quot;x &lt; y &amp; y &lt; z&quot;, 
      you can omit &quot;&amp; y&quot;, leaving just &quot;x &lt; y &lt; 
      z&quot;.</li>
  </ul>
  <p>These can be done successively, so the following are equivalent in 
  ordering.</p>
  <table class="example">
    <tr>
      <th align="LEFT">
        <p align="LEFT">Java</th>
      <th align="LEFT">
        <p align="LEFT">Unicode Collation Element Table</th>
    </tr>
    <tr>
      <td>&nbsp;a, A ; à, À &lt; b, B</td>
      <td>
        <pre>0061 ; [.0001.0001.0001] % a
0040 ; [.0001.0001.0002] % A
00E0 ; [.0001.0002.0001] % à
00C0 ; [.0001.0002.0002] % à
0042 ; [.0002.0001.0001] % b
0062 ; [.0002.0001.0002] % B</pre>
      </td>
    </tr>
  </table>
  <br>
  <h3>6.10 <a name="Flat_File_Example">Flat File Example</a></h3>
  <p>The following is a sample flat-file binary layout and sample code for 
  collation data. It is included only for illustration. The table is used to 
  generate collation elements from characters, either going forwards or 
  backwards, and detect the start of a contraction. The backwards generation is 
  for searching backwards or Boyer-Moore-style searching; the contraction 
  detection is for random access.</p>
  <p>In the file representation, ints are 32 bit values, shorts are 16, bytes 
  are 8 bits. Negatives (not that we have any) are two's-complement. For 
  alignment, the ends of all arrays are padded out to multiples of 32 bits. The 
  signature determines endianness. The locale uses an ASCII representation for 
  the Java locale: a 2 byte ISO language code, optionally followed by '_' and 2 
  byte ISO country code, followed optionally by a series of variant tags 
  separated by '_'; any unused bytes are zero.</p>
  <table>
    <tr>
      <th><font size="2">Data</font></th>
      <th colspan="2"><font size="2">Comment</font></th>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int signature;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Constant <code>0x636F6C74</code>, 
        used also for big-endian detection</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int tableVersion;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Version of the table 
        format</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int dataVersion;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Version of the table data</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">byte[32] locale;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Target locale (if any)</font></td>
    </tr>
    <tr>
      <td><font size="2">int flags;</font></td>
      <td colspan="2"><font size="2"><code>Bit01</code> = 1 if French secondary<br>
        Others are reserved</font></td>
    </tr>
    <tr>
      <td><font size="2">int limitVariable;</font></td>
      <td colspan="2"><font size="2">Every ce below this value that has a 
        non-zero primary is variable. Since variables are not interleaved, this 
        does not need to be stored on a per-character basis.</font></td>
    </tr>
    <tr>
      <td><font size="2">int maxCharsPerCE;</font></td>
      <td colspan="2"><font size="2">Maximum number of characters that are part 
        of a contraction</font></td>
    </tr>
    <tr>
      <td><font size="2">int maxCEsPerChar;</font></td>
      <td colspan="2"><font size="2">Maximum number of collation elements that 
        are generated by an expansion</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int indexOffset;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to index table</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int&nbsp;collationElementsOffset;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to main data table</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int expansionsOffset;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to expansion table</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int&nbsp;contractionMatchOffset;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to contraction 
        match table</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int&nbsp;contractionResultOffset;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to contraction 
        values table</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int nonInitialsOffset;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to non-initials 
        table. These are used for random access.</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int[10] reserved;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Reserved</font></td>
    </tr>
    <tr>
      <td><font size="2">int indexLength;</font></td>
      <td colspan="2"><font size="2">Length of following table</font></td>
    </tr>
    <tr>
      <td><font size="2">int[] index;</font></td>
      <td colspan="2"><font size="2">Index for high-byte (trie) table. Contains 
        offsets into Collation Elements. Data is accessed by:<br>
        <code>ce = collationElements[index[char&gt;&gt;8]+char&amp;0xFF]</code></font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int collationElementsLength;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Length of following table</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int[] collationElements;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Each element is either a 
        real collation element, an expansionsOffset, or an contractionsOffset. 
        See below for more information.</font></td>
    </tr>
    <tr>
      <td><font size="2">int expansionsLength;</font></td>
      <td colspan="2"><font size="2">Length of following table</font></td>
    </tr>
    <tr>
      <td><font size="2">int[] expansions;</font></td>
      <td colspan="2"><font size="2">The expansionOffsets in the 
        collationElements table point into sublists in this table. Each list is 
        terminated by FFFFFFFF.</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int&nbsp;contractionMatchesLength;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Length of following table</font></td>
    </tr>
    <tr>
      <td rowspan="4" bgcolor="#FFFFCC"><font size="2">short[] 
        contractionMatches;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">The contractionOffsets in 
        the collationElements table point into sublists in this table. Each 
        sublist is of the following format:</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">short&nbsp;backwardsOffset;</font></td>
      <td bgcolor="#FFFFCC"><font size="2">In case we are going backwards, 
        offset to true contractions table.</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">short length;</font></td>
      <td bgcolor="#FFFFCC"><font size="2">Number of chars in list to search</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">short[] charsToMatch;</font></td>
      <td bgcolor="#FFFFCC"><font size="2">characters in sorted order.</font></td>
    </tr>
    <tr>
      <td><font size="2">int contractionCEsLength;</font></td>
      <td colspan="2"><font size="2">Length of following table</font></td>
    </tr>
    <tr>
      <td><font size="2">int[] contractionCEs;</font></td>
      <td colspan="2"><font size="2">List of CEs. Each corresponds to a position 
        in the contractionChars table. The one corresponding to the length in a 
        sublist is the <i>bail-out;</i> what to do if a match is not found.</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">int nonInitialsLength;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">Length of following table</font></td>
    </tr>
    <tr>
      <td bgcolor="#FFFFCC"><font size="2">short[] nonInitials;</font></td>
      <td colspan="2" bgcolor="#FFFFCC"><font size="2">List of characters (in 
        sorted order) that can be non-initials in contractions. That is, if 
        &quot;ch&quot; is a contraction, then &quot;h&quot; is in this list. If 
        &quot;abcd&quot; is a contraction, then &quot;b&quot;, &quot;c&quot;, 
        and &quot;d&quot; are in the list.</font></td>
    </tr>
  </table>
  <br>
  <h4>6.11.1 <a name="Collation_Element_Format">Collation Element Format</a></h4>
  <ul>
    <li>'real' collationElement
      <ul>
        <li>16 bits primary (FFE0..FFFF not allowed)</li>
        <li>8 bits secondary</li>
        <li>8 bits tertiary</li>
      </ul>
    </li>
    <li>expansionsOffset
      <ul>
        <li>12 bits = FFF</li>
        <li>20 bits = offset (allows for 1,048,576 items)</li>
      </ul>
    </li>
    <li>contractionsOffset
      <ul>
        <li>12 bits = FFE</li>
        <li>20 bits = offset (allows for 1,048,576 items)</li>
      </ul>
    </li>
  </ul>
  <p>An alternative structure would be to have the offsets be not indexes into 
  the arrays, but byte offsets from the start of the table. That would limit the 
  size of the table, but use fewer machine instructions.</p>
  <h3>6.11.2 <a name="Sample_Code">Sample Code</a></h3>
  <p>The following is a pseudo code using this table for the required 
  operations. Although using Java syntax in general, the code example uses 
  arrays so as to be more familiar to users of C and C++. <i>The code is 
  presented for illustration only; it is not a complete statement of the 
  algorithm.&nbsp;</i></p>
  <pre>char[] input;   // input buffer (i)
int inputPos;   // position in input buffer (io)
int[] output;   // output buffer (o)
int outputPos;  // position in output buffer (io)
boolean forwards;   // 0 for forwards, 1 for backwards (i)
    
<span class="codeComment">/**
* Reads characters from input, writes collation elements in output
*/
</span>void getCollationElements() {
    char c = input[inputPos++];
    int ce = collationElements[index[c&gt;&gt;8] + c&amp;0xFF];
    processCE(ce);
}
    
<span class="codeComment">/**
* Normally just returns ce. However, special forms indicate that
* the ce is actually an expansion, or that we have to search
* to see if the character was part of a contraction.
* Expansions use 
*/
</span>void processCE(int ce) {
    if (ce &lt; 0xFFF00000) {
        output[outputPos++] = ce;
    } else if (ce &gt;= 0xFFE00000) {
        copyExpansions(ce &amp; 0x7FFFFF);
    } else {
        searchContractions(ce &amp; 0x7FFFFF);
    }
}
    
<span class="codeComment">/**
* Search through a contraction sublist to see if there is a match.
* Since the list is sorted, we can exit if our value is too high.&lt;p&gt;
* Since we have a length, we could implement this as a
* binary search, although we don't right now.&lt;p&gt;
* If we do find a match, we need to recurse. That's how &quot;abc&quot; would
* be handled.&lt;p&gt;
* If we fail, we return the non-matching case. That can be an expansion
* itself (it would never be a contraction).
*/
</span>void searchContractions(int offset) {
    if (forwards) inputPos++;
    else offset += input[inputPos++];
    short goal = (short)input[inputPos++];
    int limit = offset + contractionMatches[offset];
    for (int i = offset; i &lt; limit; ++i) {
        short cc = contractionMatches[i];
        if (cc &gt; goal) { <span class="codeComment">// definitely failed</span>
            processCE(contractionCEs[offset]);
            break;
        } else if (cc == goal) { // found match
            processCE(contractionCEs[i]);
            break;
        }
    }
}
    
<span class="codeComment">/**
* Copy the expansion collation elements up to the terminator.
* Don't use 00000000 as a terminator, since that may be a valid CE.
* These elements don't recurse.
*/
</span>void copyExpansions (int offset) {
    int ce = expansions[offset++];
    while (ce != 0xFFFFFFFF) {
        output[outputPos++] = ce;
        ce = expansions[offset++];
    }
}
    
<span class="codeComment">/**
* For random access, gets the start of a collation element.
* Any non-initial characters are in a sorted list, so
* we just check that list.&lt;p&gt;
* Since we have a length, we could implement this as a
* binary search, although we don't right now.
*/
</span>int getCollationElementStart(char[] buffer, int offset) {
    int i;
    main:
    for (i = offset; i &gt; 0; --i) {
        char c = buffer[i];
        for (int j = 0; j &lt; nonInitialsLength; ++j) {
            char n = nonInitials[j];
            if (c == n) continue main;
            if (c &gt; n) break main;
        }
        break;
    }
    return i;
}</pre>
  <h2><a name="Weight_Derivation"></a>7 Weight Derivation</h2>
  <p>This section describes the generation of the Unicode Default Unicode 
  Collation Element Table, and the assignment of weights to code points that are 
  not explicitly mentioned in a Collation Element Table. This uses information 
  from the Unicode Character Database on <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">UnicodeData.txt</a> 
  (and documented in <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.html">UnicodeData.html</a>).</p>
  <h3>7.1 <a name="Derived_Collation_Elements">Derived Collation Elements</a></h3>
  <p>CJK Ideographs and Hangul Syllables are not explicitly mentioned in the 
  default table. CJK ideographs are mapped to collation elements that are 
  derived from their Unicode code point value as described in <a href="tr10-9.html#Implicit_Weights">7.1.3 
  Implicit Weights</a>.</p>
  <p>The collation algorithm requires that Hangul Syllables be decomposed. 
  However, if the table is tailored so that the primary weights for Hangul Jamo 
  (and all related characters) are adjusted, then the Hangul Syllables can be 
  left as single code points and treated in the same way as CJK ideographs. That 
  will provide a collation which is approximately the same as UCA, and may be 
  sufficient in environments where individual jamo are not expected.</p>
  <p>The adjustment is to move each initial jamo (and related characters) to 
  have a primary weight corresponding to the first syllables starting with that 
  jamo, and make all non-initial jamo (and related characters) be ignorable at a 
  primary level.</p>
  <h4><a name="Illegal_Code_Points">7.1.1 Illegal code points</a></h4>
  <p>Certain code points are illegal in a data stream. These include 
  non-characters (code points with the <a href="http://www.unicode.org/Public/UNIDATA/PropList.html">Noncharacter_Code_Point</a> 
  property in the Unicode Character Database), unpaired surrogates (code points 
  with the <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.html">General_Category</a> 
  property Cs), and out-of-range values (&lt; 0 or &gt; 10FFFF). Implementations 
  may also choose to treat these as error conditions and respond appropriately, 
  such as by throwing an exception.</p>
  <p>If they are not treated as an error condition, they must be mapped to 
  [.0000.0000.0000.], and thus ignored.</p>
  <h4><a name="Legal_Code_Points">7.1.2 Legal code points</a></h4>
  <p>Any other legal code point that is not explicitly mentioned in the table is 
  mapped a sequence of two collation elements as described in <a href="tr10-9.html#Implicit_Weights">7.1.3 
  Implicit Weights</a>.</p>
  <h4><a name="Implicit_Weights">7.1.3 Implicit Weights</a></h4>
  <p>A character is mapped to an implicit weight in the following way. The 
  result of this process consists of collation elements that are sorted in code 
  point order, that do not collide with any explicit values in the table, and 
  that can be placed anywhere (e.g. at BASE) with respect to the explicit 
  collation element mappings (by default, they go after all explicit collation 
  elements).</p>
  <p>To derive the collation elements, the code point CP is separated into two 
  parts, chosen for the correct numerical properties. First, separate off the 
  top 6 bits of the code point. Since code points can go from 0 to 10FFFF, this 
  will have values from 0 to 21<sub>16</sub> (= 33<sub>10</sub>). Add this to 
  the special value BASE.</p>
  <blockquote>
    <pre>AAAA = BASE + (CP &gt;&gt; 15);</pre>
  </blockquote>
  <p>Now take the bottom 15 bits of the code point. Turn the top bit on, so that 
  the value is non-zero.</p>
  <blockquote>
    <pre>BBBB = (CP &amp; 0x7FFF) | 0x8000;</pre>
  </blockquote>
  <p>The mapping given to CP is then given by:</p>
  <blockquote>
    <pre>CP =&gt; [.AAAA.0020.0002.][.BBBB.0000.0000.]</pre>
  </blockquote>
  <p>If a fourth or higher weights are used, then the same pattern is used: they 
  are set to a non-zero value, etc. in the first collation element and zero in 
  the second. (Since all distinct code points have different <b>AAAA/BBBB</b> 
  combination, the exact values.)</p>
  <p>The value for BASE depends on the type of character:</p>
  <table cellpadding="4">
    <tr>
      <td class="syntax">FB40</td>
      <td class="syntax">CJK Ideograph</td>
    </tr>
    <tr>
      <td class="syntax">FB80</td>
      <td class="syntax">CJK Ideograph Extension A/B</td>
    </tr>
    <tr>
      <td class="syntax">FBC0</td>
      <td class="syntax">Any other code point</td>
    </tr>
  </table>
  <p>These results make AAAA (in each case) larger than any explicit primary 
  weight; thus the implicit weights will not collide with explicit weights. It 
  is not generally necessary to tailor these values to be within the range of 
  explicit weights. However if this is done, the explicit primary weights must 
  be shifted so that none are between each of the BASE values and BASE +&nbsp;34.</p>
  <h4>7.1.4 <a name="Trailing_Weights">Trailing Weights</a></h4>
  <p>The range of primary weights from FC00 to FFFF are available for use as 
  trailing weights. These are for characters that are given primary weights, but 
  grouped as a unit together with a previous character, such as U+1160 HANGUL 
  JUNGSEONG FILLER&nbsp; through U+11F9 HANGUL JONGSEONG YEORINHIEUH. By 
  tailoring these characters in this range, the units are ordered independent of 
  subsequent characters with higher weights. Otherwise problems may occur, such 
  as in the following example.</p>
  <div align="center">
    <center>
    <table class="noborder" cellpadding="4">
      <tr>
        <th width="50%" align="center" class="noborder"><b>Case 1</b></th>
        <th width="50%" align="center" class="noborder"><b>Case 2</b></th>
      </tr>
      <tr>
        <td width="50%" class="noborder">
          <div align="center">
            <center>
            <table cellspacing="0" cellpadding="4" border="1" class="example">
              <tbody>
                <tr>
                  <th><font size="3">1</font></th>
                  <td><font size="3">{G}{A}</font></td>
                </tr>
                <tr>
                  <th><font size="3">2</font></th>
                  <td><font size="3">{G}{A}{K}</font></td>
                </tr>
              </tbody>
            </table>
            </center>
          </div>
        </td>
        <td width="50%" class="noborder">
          <div align="center">
            <center>
            <table cellspacing="0" cellpadding="4" border="1" class="example">
              <tbody>
                <tr>
                  <th><font size="3">2</font></th>
                  <td><font size="3">{G}{A}{K}</font><font size="3">囗</font></td>
                </tr>
                <tr>
                  <th><font size="3">1</font></th>
                  <td><font size="3">{G}{A}</font><font size="3">囗</font></td>
                </tr>
              </tbody>
            </table>
            </center>
          </div>
        </td>
      </tr>
    </table>
    </center>
  </div>
  <p>In this example, the symbols {G}, {A}, and {K} represent letters in a 
  script where syllables (or other sequences of characters) are sorted as units. 
  By proper choice of weights for the individual letters, the syllables can be 
  ordered correctly. But the weights of the following letters may cause 
  syllables of different lengths to change order. Thus <font size="3">{G}{A}{K}</font> 
  comes after GA in Case 1. But in Case 2, it comes <i>before</i>. That is, the 
  order of these two syllables would be reversed when each is followed by a CJK 
  character: in this case, U+56D7 (<font size="3">囗)</font>.</p>
  <h3>7.2 <a name="Canonical_Decompositions">Canonical Decompositions</a></h3>
  <p>Characters with canonical decompositions do not require mappings to 
  collation elements, because Step 1.1 maps them to collation elements based 
  upon their decompositions. However, they may be given mappings to collation 
  elements anyway. The weights in those collation elements must be computed in 
  such a way they will sort in the same relative location as if the characters 
  were decomposed using Normalization Form D. By including these mappings, this 
  allows an implementation handling a restricted repertoire of supported 
  characters to compare strings correctly without performing the normalization 
  in Step 1.1 of the algorithm.</p>
  <p>A combining character sequence is called <i>impeding</i> if it contains any 
  conjoining Jamo, or if it contains an L1-ignorable combining mark and there is 
  some character that canonically decomposes to a sequence containing the same 
  base character. For example, the sequence &lt;a, cedilla&gt; is an impediment, 
  since <i>cedilla</i> is an L1-ignorable character, and there is some 
  character, e.g. <i>a-grave</i>, that decomposes to a sequence containing the 
  same base letter <i>a</i>. Note that although strings in Normalization Form C 
  generally don't contain impeding sequences, there is nothing prohibiting them 
  from containing them.</p>
  <blockquote>
    <p><i><b>Note: </b>Conformant implementations that do not support impeding 
    character sequences as part of their repertoire can avoid performing 
    Normalization Form D processing as part of collation.</i></p>
  </blockquote>
  <h3>7.3 <a name="Compatibility_Decompositions">Compatibility Decompositions</a></h3>
  <p>As remarked above, most characters with compatibility decompositions can 
  have collation elements computed at runtime to save space, duplicating the 
  work that was done to compute the Default Unicode Collation Element Table. 
  This can be an important savings in memory space. The process works as 
  follows.</p>
  <p><b>1. </b>Derive the decomposition. e.g.</p>
  <blockquote>
    <pre>2475 PARENTHESIZED DIGIT TWO =&gt; 0028, 0032, 0029</pre>
  </blockquote>
  <p><b>2. </b>Get the CE for each character in the decomposition.</p>
  <blockquote>
    <pre>0028 [*023D.0020.0002] % LEFT PARENTHESIS
0032 [.06C8.0020.0002] % DIGIT TWO
0029 [*023E.0020.0002] % RIGHT PARENTHESIS</pre>
  </blockquote>
  <p><b>3. </b>Set the first two L3 values to be lookup(L3), where the lookup 
  uses the table in <a href="tr10-9.html#Tertiary_Weight_Table">§7.3.1 Tertiary Weight 
  Table</a>. Set the remaining L3 values to MAX (which in the default table is 
  001F):</p>
  <blockquote>
    <pre>0028 [*023D.0020.0004] % LEFT PARENTHESIS
0032 [.06C8.0020.001F] % DIGIT TWO
0029 [*023E.0020.001F] % RIGHT PARENTHESIS</pre>
  </blockquote>
  <p><b>4.</b> Concatenate the result to produce the sequence of collation 
  elements that the character maps to.</p>
  <blockquote>
    <pre>2475 [*023D.0020.0004] [.06C8.0020.0004] [*023E.0020.0004] </pre>
  </blockquote>
  <p>Some characters cannot be computed in this way. They must be filtered out 
  of the default table and given specific values. An example is:</p>
  <blockquote>
    <pre>017F [.085D.00FD.0004.017F] % LATIN SMALL LETTER LONG S; COMPAT</pre>
  </blockquote>
  <h4 align="left"><b><a name="Tertiary_Weight_Table"></a>7.3.1 Tertiary Weight 
  Table</b></h4>
  <p align="left">Characters are given tertiary weights according to the 
  following table. The Decomposition Type is from the Unicode Character 
  Database. The Condition is either based on the General Category or on a 
  specific list of characters. The weights are from MIN = 2 to MAX = 1F<sub>16</sub>, 
  excluding 7, which is not used for historical reasons. The Samples show some 
  minimal values that are distinguished by the different weights. All values are 
  distinguished from MIN except for the katakana/hiragana values.</p>
  <div align="center">
    <center>
    <table cellspacing="0" border="1" class="values" cellpadding="2">
      <tbody>
        <tr>
          <th style="BACKGROUND-COLOR: #00ffff">Type</th>
          <th style="BACKGROUND-COLOR: #00ffff">Condition</th>
          <th style="BACKGROUND-COLOR: #00ffff">Weight</th>
          <th style="BACKGROUND-COLOR: #00ffff" colspan="6">Samples</th>
        </tr>
        <tr>
          <td><code>&nbsp;NONE</code></td>
          <td>&nbsp;</td>
          <td><code>0x0002</code></td>
          <td>i</td>
          <td>ب</td>
          <td>)</td>
          <td>mw</td>
          <td>1⁄2</td>
          <td><b><i>X</i></b></td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;wide&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x0003</code></td>
          <td>ｉ</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;compat&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x0004</code></td>
          <td>ⅰ</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;font&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x0005</code></td>
          <td>ℹ&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;circle&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x0006</code></td>
          <td>ⓘ</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td bgcolor="#cccccc"><code>!unused!</code></td>
          <td bgcolor="#cccccc">&nbsp;</td>
          <td bgcolor="#cccccc"><code>0x0007</code></td>
          <td bgcolor="#cccccc">&nbsp;</td>
          <td bgcolor="#cccccc">&nbsp;</td>
          <td bgcolor="#cccccc">&nbsp;</td>
          <td bgcolor="#cccccc">&nbsp;</td>
          <td bgcolor="#cccccc">&nbsp;</td>
          <td bgcolor="#cccccc">&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;NONE</code></td>
          <td>Uppercase</td>
          <td><code>0x0008</code></td>
          <td>I</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>MW</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;wide&gt;</code></td>
          <td>Uppercase</td>
          <td><code>0x0009</code></td>
          <td>Ｉ</td>
          <td>&nbsp;</td>
          <td>）</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;compat&gt;</code></td>
          <td>Uppercase</td>
          <td><code>0x000A</code></td>
          <td>Ⅰ</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;font&gt;</code></td>
          <td>Uppercase</td>
          <td><code>0x000B</code></td>
          <td>ℑ</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;circle&gt;</code></td>
          <td>Uppercase</td>
          <td><code>0x000C</code></td>
          <td>Ⓘ</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;small&gt;</code></td>
          <td>small hiragana (3041,&nbsp;3043,...</td>
          <td><code>0x000D</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>ぁ</td>
        </tr>
        <tr>
          <td><code>&nbsp;NONE</code></td>
          <td>normal hiragana (3042,&nbsp;3044, ...)</td>
          <td><code>0x000E</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>あ</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;small&gt;</code></td>
          <td>small katakana (30A1,&nbsp;30A3,...)</td>
          <td><code>0x000F</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>﹚</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>ァ</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;narrow&gt;</code></td>
          <td>small narrow katakana (FF67..FF6F)</td>
          <td><code>0x0010</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>ｧ</td>
        </tr>
        <tr>
          <td><code>&nbsp;NONE</code></td>
          <td>normal katakana (30A2,&nbsp;30A4, ...)</td>
          <td><code>0x0011</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>ア</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;narrow&gt;</code></td>
          <td>narrow katakana (FF71..FF9D),<br>
            narrow hangul (FFA0..FFDF)</td>
          <td><code>0x0012</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>ｱ</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;circle&gt;</code></td>
          <td>circled katakana (32D0..32FE)</td>
          <td><code>0x0013</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>㋐</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;super&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x0014</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>⁾</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;sub&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x0015</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>₎</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;vertical&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x0016</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>︶</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;initial&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x0017</code></td>
          <td>&nbsp;</td>
          <td>ﺑ</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;medial&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x0018</code></td>
          <td>&nbsp;</td>
          <td>ﺒ</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;final&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x0019</code></td>
          <td>&nbsp;</td>
          <td>ﺐ</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;isolated&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x001A</code></td>
          <td>&nbsp;</td>
          <td>ﺏ</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;noBreak&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x001B</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;square&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x001C</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>㎽</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;square&gt;</code></td>
          <td>Uppercase</td>
          <td><code>0x001D</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>㎿</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;&lt;fraction&gt;</code></td>
          <td>&nbsp;</td>
          <td><code>0x001E</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>½</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td><code>&nbsp;</code><code>n/a</code></td>
          <td>&nbsp;(MAX value)</td>
          <td><code>0x001F</code></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
      </tbody>
    </table>
    </center>
  </div>
  <br>
  <h2><a name="Searching"></a>8 Searching and Matching (Informative)</h2>
  <p>The collation elements can also be used for matching string and for 
  searching for strings, so that a proper native-language match is produced. For 
  example, &quot;ß&quot; will properly match against &quot;ss&quot;. Users of 
  search algorithms should be allowed to modify the comparison strength, thus 
  excluding differences at less significant levels. This is especially useful 
  for searching, but can also apply to comparison.</p>
  <p>Excluding differences at Level 3 has the effect of ignoring case and 
  compatibility format distinctions between letters when searching. Excluding 
  differences at Level 2 has the effect of ignoring accentual distinctions when 
  searching.</p>
  <p>Conceptually, a string matches some target where a substring of the target 
  has the same sort key. But there are a number of complications:</p>
  <ol>
    <li>The lengths of matching strings may differ: &quot;aa&quot; and &quot;<font size="3">å&quot; 
      would match in Danish.</font></li>
    <li><font size="3">Because of ignorables (at different levels), </font>the 
      position where a string matches may be indefinite, depending on the 
      attribute settings of the collation. For example, if hyphens are ignorable 
      for a certain collation, then &quot;abc&quot; will match &quot;abc&quot;, 
      &quot;abc-&quot;, &quot;-abc-&quot;, etc.</li>
    <li>Suppose that the collator has contractions, and that a contraction spans 
      the boundary of the match. Whether or not it is considered a match may 
      depend on user settings, just as users are given a &quot;Whole Words&quot; 
      option in searching. So in a language where &quot;ch&quot; is a 
      contraction, &quot;bac&quot; would not match in &quot;bach&quot; (given 
      the proper user setting).</li>
    <li>Similarly, combining character sequences may need to be taken into 
      account. Users may not want a search for &quot;abc&quot; to match in 
      &quot;...ab<font size="3">ç...&quot;. However, this may also depend on 
      language and user customization.</font></li>
    <li><font size="3">The above two conditions can be considered part of a 
      general condition: &quot;Whole Grapheme Clusters Only&quot;; though 
      probably expressed in user interfaces with more natural wording as 
      &quot;Whole Characters Only&quot;. This is very similar to the common 
      &quot;Whole Words Only&quot; checkbox that is included in most search 
      dialog boxes. </font>(For more information on grapheme clusters, see <a href="../tr18.1">UTR 
      #18: Unicode Regular Expression Guidelines</a>)</li>
    <li>Certain Thai and Lao vowels are swapped with the preceding character. 
      For example, the text string “เข” (...\u0E40\u0E02...) is modified 
      internally in collation to “ขเ” (...\u0E02\u0E40...). This may 
      mean that a string logically matches a discontiguous section of another 
      string. If, however, the vowels are considered to be part of a grapheme 
      cluster, then this situation is handled by the <font size="3">&quot;whole 
      grapheme clusters only&quot; option.</font></li>
    <li>If the matching is does not check for <font size="3">&quot;Whole 
      Grapheme Clusters Only&quot;</font>, then some other complications may 
      occur. For example, suppose that P is &quot;x<font size="3">^&quot;, and Q 
      is &quot;</font>x ^<font size="3">¸&quot;. Because the cedilla and 
      circumflex can be written in arbitrary order and still be equivalent, one 
      would expect to find a match for P in Q. A canonically-equivalent matching 
      process requires special processing at the boundaries to check for 
      situations like this. (It does not require such special processing within 
      the P or the substring of Q since collation is defined to observe 
      canonical equivalence.)</font></li>
  </ol>
  <p>The following definitions come into play:</p>
  <p><b>DS1. </b>Define <i>S[start,end]</i> to be the substring of S that 
  includes the character after the offset <i>start</i> up to the character 
  before offset <i>end</i>. For example, if S is &quot;abcd&quot;, then S[1,3] 
  is &quot;bc&quot;.</p>
  <p>Suppose there is a collation C, a pattern string P and a target string Q. C 
  has some particular set of attributes, such as a strength setting, and choice 
  of variable weighting.</p>
  <p><b>DS2. </b>There is a <i>match</i> according to C for P within Q[<i>s,e</i>] 
  if and only if C generates the same sort key for P as for Q[s,e].</p>
  <p><b>DS3. </b>There is a <i>canonical match</i> according to C for P within 
  Q[<i>s,e</i>] if and only if there is some Q', canonically equivalent to Q[<i>s,e</i>], 
  and some <i>s'</i> and <i>e'</i> such that P matches within Q[<i>s',e'</i>].</p>
  <p><b>DS4. </b>The match is <i>minimal</i> if for all positive <i>i</i> and <i>j</i>, 
  there is no match at Q[<i>s+i,e-j</i>]. In such a case, we also say that P 
  matchs <i>at</i> Q[<i>s,e</i>].</p>
  <ul>
    <li>By using minimal matches, the issue with ignorables is avoided.</li>
  </ul>
  <p><b>DS5. </b>The match is <i>grapheme-complete</i> if <i>s</i> and <i>e </i>are 
  both at grapheme cluster boundaries.</p>
  <ul>
    <li>By using grapheme-complete matches, contractions and combining sequences 
      are not interrupted.</li>
  </ul>
  <p><b>DS6.</b> The <i>first forward match</i> for P in Q starting at <i>b</i> 
  is the least offset <i>s</i> greater than or equal to <i>b</i> such that for 
  some <i>e</i>, P matches within Q[s,e].</p>
  <p><b>DS7.</b> The <i>first backward match</i> for P in Q starting at <i>b</i> 
  is the greatest offset <i>e</i> less than or equal to <i>b</i> such that for 
  some <i>s</i>, P matches within Q[s,e].</p>
  <ul>
    <li>Forward and backward matches can be narrowed to be minimal or 
      grapheme-complete, or broadened to be canonical, or use any mixture of 
      these.</li>
  </ul>
  <h2><a name="Acknowledgements">Acknowledgements</a></h2>
  <p>Thanks to Åke Persson, Kent Karlsson, Roozbeh Pournader, Vladimir 
  Weinstein, and Richard Gillam for their feedback on previous versions of this 
  document, and Cathy Wissink for her contributions to the text.</p>
  <h2><a name="References">References</a></h2>
  <table class="noborder" cellpadding="8">
    <tr>
      <td width="1" class="noborder">[<a name="AllKeys">AllKeys</a>]</td>
      <td class="noborder">
        <p align="left">The latest version of this file is found on:<br>
        <a href="allkeys.txt">http://www.unicode.org/reports/tr10/allkeys.txt<br>
        </a>The version corresponding to this document is found on:<a href="allkeys-3.1.1.txt"><br>
        http://www.unicode.org/reports/tr10/allkeys-3.1.1.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="CanStd">CanStd</a>]</td>
      <td class="noborder">CAN/CSA 2243.4.1</td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="FAQ">FAQ</a>]</td>
      <td class="noborder">Unicode Frequently Asked Questions<br>
        <a href="http://www.unicode.org/faq/">http://www.unicode.org/faq/<br>
        </a><i>For answers to common questions on technical issues.</i></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Glossary">Glossary</a>]</td>
      <td class="noborder">Unicode Glossary<a href="http://www.unicode.org/glossary/"><br>
        http://www.unicode.org/glossary/<br>
        </a><i>For explanations of terminology used in this and other documents.</i></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="ICUCollator">ICUCollator</a>]</td>
      <td class="noborder"><a href="http://oss.software.ibm.com/icu/userguide/Collate_Intro.html">http://oss.software.ibm.com/icu/userguide/Collate_Intro.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="JavaCollator">JavaCollator</a>]</td>
      <td class="noborder"><a href="http://java.sun.com/j2se/1.4/docs/api/java/text/Collator.html">http://java.sun.com/j2se/1.4/docs/api/java/text/Collator.html</a>,<br>
        <a href="http://java.sun.com/j2se/1.4/docs/api/java/text/RuleBasedCollator.html">http://java.sun.com/j2se/1.4/docs/api/java/text/RuleBasedCollator.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Reports">Reports</a>]</td>
      <td class="noborder">Unicode Technical Reports<br>
        <a href="../index.html">http://www.unicode.org/reports/<br>
        </a><i>For information on the status and development process for 
        technical reports, and for a list of technical reports.</i></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Sample">Sample</a>]</td>
      <td class="noborder"><a href="Sample/index.html">http://www.unicode.org/reports/tr10/Sample/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="SoStd">SoStd</a>]</td>
      <td class="noborder">ISO/IEC 14651</td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Test">Test</a>]</td>
      <td class="noborder">The latest versions of these files are on:<br>
        <a href="CollationTest.html">http://www.unicode.org/reports/tr10/CollationTest.html</a><br>
        <a href="CollationTest.zip">http://www.unicode.org/reports/tr10/CollationTest.zip<br>
        </a>The version corresponding to this document is found on:<br>
        <a href="CollationTest-3.1.1.html">http://www.unicode.org/reports/tr10/CollationTest-3.1.1.html</a><br>
        <a href="CollationTest-3.1.1.zip">http://www.unicode.org/reports/tr10/CollationTest-3.1.1.zip</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Versions">Versions</a>]</td>
      <td class="noborder">Versions of the Unicode Standard<br>
        <a href="http://www.unicode.org/versions/">http://www.unicode.org/versions/<br>
        </a><i>For details on the precise contents of each version of the 
        Unicode Standard, and how to cite them.</i></td>
    </tr>
  </table>
  &nbsp;
  <h2><a name="Modifications">Modifications</a></h2>
  <p>The following summarizes modifications from the previous version of this 
  document.</p>
  <table class="noborder">
    <tr>
      <td width="1" class="noborder"><a name="TrackingNumber9">9</a></td>
      <td class="noborder">
        <ul>
          <li>Added <a href="tr10-9.html#C4">C4</a></li>
          <li>Added more conditions in <a href="tr10-9.html#Well-Formed">3.3 Well-Formed 
            Collation Element Tables</a></li>
          <li>Added <a href="tr10-9.html#S1.3">S1.3</a></li>
          <li>Added treatment of ignorables after variables in <a href="tr10-9.html#Variable_Weighting">3.2.2 
            Variable Weighting</a></li>
          <li>Added <a href="tr10-9.html#Stability">3.4 Stability</a></li>
          <li>Modified and reorganized <a href="tr10-9.html#Weight_Derivation">7 Weight 
            Derivation</a>. In particular, CJK characters and unassigned 
            characters are given different weights. Added MAX to 7.3.</li>
          <li>Added references</li>
          <li>Minor editing</li>
          <li>Clarified noncharacter code points in <a href="tr10-9.html#Illegal_Code_Points">7.1.1 
            Illegal code points</a></li>
          <li>Modified <a href="tr10-9.html#S1.2">S1.2</a> and <a href="tr10-9.html#Rearrangement">3.1.3 
            Rearrangement</a> to use the Logical_Order_Exception property, and 
            removed <i>rearrange</i> from the file syntax in <a href="tr10-9.html#File_Format">3.2.1 
            File Format</a>, and from <a href="tr10-9.html#Tailoring">5 Tailoring</a>.</li>
          <li>Incorporated Cathy's notes on linguistic applicability.</li>
          <li>Updated links for <i>[<a href="tr10-9.html#Test">Test</a>].</i></li>
        </ul>
      </td>
    </tr>
  </table>
  <hr width="50%">
  <p class="copyright"><font size="-1">Copyright © 1998-2002 Unicode, Inc. All 
  Rights Reserved. The Unicode Consortium makes no expressed or implied warranty 
  of any kind, and assumes no liability for errors or omissions. No liability is 
  assumed for incidental and consequential damages in connection with or arising 
  out of the use of the information or programs contained or accompanying this 
  technical report.</font>
  <p class="copyright"><font size="-1">Unicode and the Unicode logo are 
  trademarks of Unicode, Inc., and are registered in some jurisdictions.</font></p>
</div>

</body>

</html>
