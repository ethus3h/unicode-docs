<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"

       "http://www.w3.org/TR/REC-html40/loose.dtd"> 

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<meta name="keywords" content="unicode, normalization, composition, decomposition">
<meta name="description" content="Specifies the Unicode Normalization Formats">

<title>UAX #15: Unicode Normalization Forms</title>

<!-- WEB ONLY -->
<link rel="stylesheet" type="text/css" href="../reports-web.css">
<!-- BOOK ONLY 
<link rel="stylesheet" type="text/css" href="../reports-book.css"> -->
<style type="text/css">div.book-only{ background-color: #FFFF00}</style>
</head>
<body><div class="book"><!-- START WEB ONLY --><div class="web-only">
<table class="header" cellspacing="0" cellpadding="0" width="100%">
  <tr>
    <td class="icon"><a href="http://www.unicode.org">
    <img align="middle" alt="[Unicode]" border="0" src="../logo60s2.gif" width="34" 
    height="33"></a>&nbsp;&nbsp;<a class="bar" href="../index.html">Technical Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>

</table>
</div>
<div class="body">
  <h2 class="uaxtitle">Unicode Standard Annex&nbsp;#15</h2>
  <h1>Unicode Normalization Forms</h1>
<div class="web-only">
  <table border="1" cellpadding="2" width="90%">
    <tr>
      <td valign="top" width="20%">Version</td>
      <td valign="top">Unicode 5.0.0</td>
    </tr>
    <tr>
      <td valign="top">Authors</td>
      <td valign="top">Mark Davis (<a href="mailto:mark.davis@google.com">mark.davis@google.com</a>), 
      Martin Dürst</td>
    </tr>
    <tr>
      <td valign="top">Date</td>
      <td valign="top">2006-10-12</td>
    </tr>
    <tr>
      <td valign="top">This Version</td>
      <td valign="top">
      <a href="tr15-27.html">
		http://www.unicode.org/reports/tr15/tr15-27.html</a></td>
    </tr>
    <tr>
      <td valign="top">Previous Version</td>
      <td valign="top">
      <a href="tr15-25.html">
      http://www.unicode.org/reports/tr15/tr15-25.html</a></td>
    </tr>
    <tr>
      <td valign="top">Latest Version</td>
      <td valign="top"><a href="../tr15.1">
      http://www.unicode.org/reports/tr15/</a></td>
    </tr>
    <tr>
      <td valign="top">Revision</td>
      <td valign="top"><a href="tr15-27.html#Modifications">27</a></td>
    </tr>
  </table>
  </div> <!-- WEB ONLY -->
  <h4 class="summary">Summary</h4>
  <p><i>This annex describes specifications for four normalized forms of Unicode text. With these 
  forms, equivalent text (canonical or compatibility) will have identical binary representations. 
  When implementations keep strings in a normalized form, they can be assured that equivalent 
  strings have a unique binary representation.</i></p>
  <div class="web-only">
  
    <h4 class="status">Status</h4>
  <p><i>This document has been reviewed by Unicode members and other interested 
	parties, and has been approved for publication by the Unicode Consortium. 
	This is a stable document and may be used as reference material or cited as 
	a normative reference by other specifications.</i></p>
  <blockquote>
    <p><i><b>A Unicode Standard Annex (UAX)</b> forms an integral part of the Unicode Standard, but 
    is published online as a separate document. The Unicode Standard may require conformance to normative 
    content in a Unicode Standard Annex, if so specified in the Conformance chapter of that version 
    of the Unicode Standard. The version number of a UAX document corresponds to the version of the Unicode Standard of which it forms a part.</i></p>
  </blockquote>
  <p><i>Please submit corrigenda and other comments with the online reporting form [<a href="../tr41/tr41-1.html#Feedback">Feedback</a>]. 
  Related information that is useful in understanding this annex is found in
  Unicode Standard Annex #41, “<a href="../tr41/tr41-1.html">Common References for Unicode Standard Annexes</a>.” For the latest version of the Unicode Standard, see [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]. 
  For a list of current Unicode Technical Reports, see [<a href="../tr41/tr41-1.html#Reports">Reports</a>]. For more 
  information about versions of the Unicode Standard, see [<a href="../tr41/tr41-1.html#Versions">Versions</a>].</i></p>
  </div> <!-- WEB ONLY -->
  <h4 class="contents">Contents</h4>
  <ul class="toc">
    <li>1&nbsp;<a href="tr15-27.html#Introduction">Introduction</a>
    <ul class="toc">
      <li>1.1&nbsp;<a href="tr15-27.html#Concatenation">Concatenation</a></li>
    </ul>
    </li>
    <li>2&nbsp;<a href="tr15-27.html#Notation">Notation</a></li>
    <li>3&nbsp;<a href="tr15-27.html#Versioning">Versioning and Stability</a><ul class="toc">
      <li>3.1 <a href="tr15-27.html#Stability_of_Normalized_Forms">Stability of 
      Normalized Forms</a></li>
      <li>3.2 <a href="tr15-27.html#Stability_of_the_Normalization_Process">Stability 
      of the Normalization Process</a></li>
      <li>3.3 <a href="tr15-27.html#Guaranteeing_Process_Stability">Guaranteeing 
      Process Stability</a></li>		<li>3.4 <a href="tr15-27.html#Forbidding_Characters">Forbidding Characters</a></li>
    </ul>
    </li>
    <li>4&nbsp;<a href="tr15-27.html#Conformance">Conformance</a></li>
    <li>5&nbsp;<a href="tr15-27.html#Specification">Specification</a></li>
    <li>6&nbsp;<a href="tr15-27.html#Primary_Exclusion_List_Table">Composition Exclusion Table</a></li>
    <li>7&nbsp;<a href="tr15-27.html#Examples">Examples and Charts</a> 
    </li>
    <li>8&nbsp;<a href="tr15-27.html#Design_Goals">Design Goals</a></li>
    <li>9&nbsp;<a href="tr15-27.html#Implementation_Notes">Implementation Notes</a></li>
    <li>10&nbsp;<a href="tr15-27.html#Decomposition">Decomposition</a></li>
    <li>11&nbsp;<a href="tr15-27.html#Code_Sample">Code Sample</a></li>
    <li>12&nbsp;<a href="tr15-27.html#Legacy_Encodings">Legacy Encodings</a></li>
    <li>13&nbsp;<a href="tr15-27.html#Programming_Language_Identifiers">Programming Language Identifiers</a></li>
    <li>14&nbsp;<a href="tr15-27.html#Annex8">Detecting Normalization Forms</a><ul class="toc">
    <li>14.1&nbsp; <a href="tr15-27.html#Stable_Code_Points">Stable Code Points</a></li>
    </ul></li>
    <li>15&nbsp;<a href="tr15-27.html#Conformance_Testing">Conformance Testing</a></li>
    <li>16&nbsp;<a href="tr15-27.html#Hangul">Hangul</a>
    </li>
    <li>17&nbsp;<a href="tr15-27.html#Intellectual_Property_Annex">Intellectual Property</a></li>
    <li>18&nbsp;<a href="tr15-27.html#Corrigenda">Corrigenda</a></li>
    <li>19&nbsp;<a href="tr15-27.html#Canonical_Equivalence">Canonical Equivalence</a></li>
    <li>20&nbsp;<a href="tr15-27.html#Corrigendum_5_Sequences">Corrigendum 5 
    Sequences</a></li>	<li>21 	<a href="tr15-27.html#Stream_Safe_Text_Format">	Stream-Safe Text Format</a></li>
    <li><a href="tr15-27.html#Acknowledgments">Acknowledgments</a></li>
    <li><a href="tr15-27.html#References">References</a></li>
    <li><a href="tr15-27.html#Modifications">Modifications</a></li>
  </ul>
  <hr>
  <h2 class="section"><a name="Introduction"></a>1 Introduction</h2>
  <p>The Unicode Standard defines two equivalences between characters: canonical equivalence 
  and compatibility equivalence. Canonical equivalence is a basic equivalency between characters or 
  sequences of characters. <span style="font-style: italic; ">Figure 1</span> 
  illustrates this equivalence.</p>
  <p class="caption">Figure 1. <span style="font-weight: 400">Canonical 
	Equivalence</span></p>
  <div align="center">
    <center>
    <table cellspacing="2" cellpadding="2" style="border-collapse: collapse">
      <tr>
        <td>Combining sequence&nbsp;&nbsp;&nbsp;</td>
        <td style="text-align: center"><span class="charSample">Ç</span></td>
        <td><span class="charSample">↔</span></td>
        <td style="text-align: center"><span class="charSample">C ◌̧</span></td>
      </tr>
      <tr>
        <td>Hangul </td>
        <td style="text-align: center"><span class="charSample">가</span></td>
        <td><span class="charSample">↔</span></td>
        <td style="text-align: center"><span class="charSample">가</span></td>
      </tr>
      <tr>
        <td>Singleton </td>
        <td style="text-align: center"><span class="charSample">Ω</span></td>
        <td><span class="charSample">↔</span></td>
        <td style="text-align: center"><span class="charSample">Ω</span></td>
      </tr>
    </table>
    </center>
  </div>
  <p>For round-trip compatibility with existing standards, Unicode has encoded many 
  entities that are really variants of existing nominal characters. The visual representations of 
  these characters are typically a subset of the possible visual representations of the nominal 
  character. These are given compatibility decompositions in the standard. Because the characters 
  are visually distinguished, replacing a character by a compatibility equivalent may mean 
  this visual distinction is lost. If the visual distinction is stylistic, then markup or styling 
  could be used to represent the formatting information. However, some characters with compatibility
  decompositions are used in mathematical notation to represent distinction 
  of a semantic nature; replacing the use of distinct character codes by formatting may cause 
  problems. See <span style="font-style: italic; ">Figure 2</span> 
  for examples of compatibility equivalents.</p>
  <p>Both canonical and compatibility equivalences are explained in more detail in 
	<i>Chapter 2, General Structure</i>, and <i>Chapter 3, Conformance,</i> of <i>
  	The Unicode Standard</i> in [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]. In addition, the 
  Unicode Standard describes several forms of normalization in <i>Section 5.6, Normalization.</i> 
  These Normalization Forms are designed to produce a unique normalized form for any given string. 
  Two of these forms are precisely specified in <i>Section 3.7, Decomposition</i>,
	in [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]. In 
  particular, the standard defines a <i>canonical decomposition</i> format, which can be used as a 
  normalization for interchanging text. This format allows for binary comparison while maintaining 
  canonical equivalence with the original unnormalized text.</p>
  <p>The standard also defines a <i>compatibility decomposition</i> format, which allows for binary 
  comparison while maintaining compatibility equivalence with the original unnormalized text. The 
  latter can also be useful in many circumstances, because it folds the differences between 
  characters that are inappropriate in those circumstances. For example, the halfwidth and 
  fullwidth <i>katakana</i> characters will have the same compatibility decomposition and are thus 
  compatibility equivalents; however, they are not canonical equivalents.</p>
  <p class="caption">Figure 2. <span style="font-weight: 400">Compatibility Equivalence</span></p>
  <div align="center">
    <center>
    <table cellspacing="2" cellpadding="2" style="border-collapse: collapse" id="table1">
      <tr>
        <td>Font variants</td>
        <td align="right" style="text-align: center" colspan="2">		<span class="charSample">ℌ</span></td>
        <td align="right" style="text-align: center" colspan="2">		<span class="charSample">ℍ</span></td>
      </tr>
      <tr>
        <td>Breaking differences&nbsp;&nbsp;&nbsp;</td>
        <td align="right" style="text-align: center" colspan="4">		<span class="charSample">-</span></td>
      </tr>
      <tr>
        <td>Cursive forms</td>
        <td align="right" style="text-align: center">
        <span class="charSample">ﻨ</span></td>
        <td align="right" style="text-align: center">
        <span class="charSample">ﻧ</span></td>
        <td align="right" style="text-align: center">
        <span class="charSample">ﻦ</span></td>
        <td align="right" style="text-align: center">
        <span class="charSample">ﻥ</span></td>
      </tr>
      <tr>
        <td>Circled</td>
        <td align="right" style="text-align: center" colspan="4">
		<span class="charSample">①</span></td>
      </tr>
      <tr>
        <td>Width, size, rotated</td>
        <td align="right" style="text-align: center"><span class="charSample">ｶ</span></td>
        <td align="right" style="text-align: center"><span class="charSample">カ</span></td>
        <td align="right" style="text-align: center"><span class="charSample">︷</span></td>
        <td align="right" style="text-align: center"><span class="charSample">{</span></td>
      </tr>
      <tr>
        <td>Superscripts/subscripts&nbsp;</td>
        <td align="right" style="text-align: center" colspan="2">
		<span class="charSample">⁹</span></td>
        <td align="right" style="text-align: center" colspan="2">
		<span class="charSample">₉</span></td>
      </tr>
      <tr>
        <td>Squared characters</td>
        <td align="right" style="text-align: center" colspan="4">
		<span class="charSample">㌀</span></td>
      </tr>
      <tr>
        <td>Fractions</td>
        <td align="right" style="text-align: center" colspan="4">
		<span class="charSample">¼</span></td>
      </tr>
      <tr>
        <td>Others</td>
        <td align="right" style="text-align: center" colspan="4">		<span class="charSample">ǆ</span></td>
      </tr>
    </table>
    </center>
  </div>
  <p class="caption">&nbsp;</p>
	<p class="caption">Table 1. <span style="font-weight: 400">Normalization Forms</span></p>
  <div align="center">
  <table border="1" cellspacing="0" cellpadding="2" id="table2">
    <tr>
      <th align="left" height="20">Title</th>
      <th align="left" height="20">Description</th>
      <th align="left" height="20">Specification</th>
    </tr>
    <tr>
      <td valign="TOP" height="40">Normalization Form&nbsp;D (NFD)</td>
      <td valign="TOP" height="40">Canonical Decomposition</td>
      <td valign="TOP" height="40"><i>Sections 3.7</i>, <i>3.11</i>, and <i>3.12</i> [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]<i>;</i> 
      also summarized under <span class="section">Section</span> <span class="secno">10<i>,</i></span><i> <a href="tr15-27.html#Decomposition">Decomposition</a></i></td>
    </tr>
    <tr>
      <td valign="TOP" height="59">Normalization Form&nbsp;C (NFC)</td>
      <td valign="TOP" height="59">Canonical Decomposition,<br>
      followed by Canonical Composition</td>
      <td valign="TOP" height="59">See <span class="section">Section </span><span class="secno">5,</span> <i><a href="tr15-27.html#Specification">
      Specification</a></i></td>
    </tr>
    <tr>
      <td valign="TOP" height="40">Normalization Form&nbsp;KD (NFKD)</td>
      <td valign="TOP" height="40">Compatibility Decomposition</td>
      <td valign="TOP" height="40"><i>Sections 3.7</i>, <i>3.11</i>, and <i>3.12</i> [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]<i>;</i> 
      also summarized under <span class="section">Section</span> <span class="secno">10<i>,</i></span><i> <a href="tr15-27.html#Decomposition">Decomposition</a></i></td>
    </tr>
    <tr>
      <td valign="TOP" height="60">Normalization Form&nbsp;KC (NFKC)</td>
      <td valign="TOP" height="60">Compatibility Decomposition,<br>
      followed by Canonical Composition</td>
      <td valign="TOP" height="60">See <span class="section">Section</span> <span class="secno">5,</span> <i><a href="tr15-27.html#Specification">
      Specification</a></i></td>
    </tr>
  </table>
  </div>
  <p>&nbsp;</p>
	<p>Both of these formats are normalizations to decomposed characters. While <i>Section 3.7, 
  Decomposition</i>, in [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>] also discusses normalization to composite characters (also known as <i>
  decomposable</i> or <i>precomposed</i> characters), it does not precisely specify a format. 
  Because of the nature of the precomposed forms in the Unicode Standard, there is more than one 
  possible specification for a normalized form with composite characters. This annex provides a 
  unique specification for normalization, and a label for each normalized form.</p>
  <p>The four Normalization Forms are labeled as shown in <i>Table 1.</i></p>
  <p>As with decomposition, there are two forms of normalization that convert to 
	composite characters: <i>Normalization Form C</i> and <i>Normalization Form KC</i>. The difference between 
  these depends on whether the resulting text is to be a <i>canonical</i> equivalent to the original 
  unnormalized text or a <i>compatibility</i> equivalent to the original unnormalized 
  text. (In <i>NFKC</i> and <i>NFKD,</i> a <i>K</i> is used to stand for <i>compatibility</i> to 
  avoid confusion with the <i>C</i> standing for <i>composition</i>.) Both types of normalization 
  can be useful in different circumstances.</p>
  <p><i>Figures 3–6</i> illustrate different 	ways in which source text can be normalized. In the first three figures, the NFKD form is always the same as the NFD form, and the NFKC form is always 	
  	the same as the NFC form, so for simplicity those columns are omitted. For 	
  	consistency, all of these examples use Latin characters, although similar 	
  	examples are found in other scripts.</p>
    <div align="center">

  <p class="caption"><b>Figure 3.<span style="font-weight: 400"> Singletons</span></b></p>
	  <div class="web-only">
 			<p class="center"><img border="0" src="images/UAX15-NormFig3.jpg" alt="ohm etc. example"></p>
	   </div>
	   <div class="book-only">
		   <p class="center"><img border="0" src="print-images/UAX15-NormFig3.jpg" alt="ohm etc. example" width="184" height="84"></p>
	   </div>
    </div>		
  <p>Certain characters are known as singletons. They never remain in the text after normalization. Examples 
	include the <i>angstrom</i> and <i>ohm</i> symbols, which map to their normal letter 
	counterparts <i>a-with-ring </i>and<i> omega</i>, respectively.</p> 	
  		  <p class="caption">Figure 4. <span style="font-weight: 400">Canonical Composites</span></p>	<p class="center">
	  <div class="web-only">
 			<p class="center"><img border="0" src="images/UAX15-NormFig4.jpg" alt="composition examples"></p>
	   </div>
	   <div class="book-only">
		   <p class="center"><img border="0" src="print-images/UAX15-NormFig4.jpg" alt="composition examples" width="184" height="84"></p>
	   </div>
  <p>Many characters are known as canonical 
	composites, or precomposed characters. In the D forms, they are decomposed; in the C forms, they are <i>
	usually</i>
	precomposed. (For exceptions, see 
	<span class="section">Section </span><span class="secno">6,</span>&nbsp;<i><a href="tr15-27.html#Primary_Exclusion_List_Table">Composition Exclusion Table</a></i>.)</p>
	<p>Normalization provides a unique order 
	for combining marks, with a uniform order for all D and C forms. Even when there is no precomposed character, as with 
	the “q” with accents in <i>Figure 5</i>, the ordering may be modified by 
	normalization. </p>  <p class="caption">Figure 5.<span style="font-weight: 400"> Multiple Combining Marks</span></p>
	<p class="center">
	  <div class="web-only">
 			<p class="center"><img border="0" src="images/UAX15-NormFig5.jpg" alt="multiple marks examples"></p>
	   </div>
	   <div class="book-only">
		   <p class="center"><img border="0" src="print-images/UAX15-NormFig5.jpg" alt="composition examples" width="209" height="156"></p>
	   </div>
	<p>The 
	example of the letter “d” with accents shows a situation where a precomposed character 
	plus another accent changes in NF(K)C to 
	a <i>different</i> 	precomposed character plus a different accent.</p>
  <p class="caption">Figure 6. <span style="font-weight: 400">Compatibility Composites</span></p>	<p class="center">
	  <div class="web-only">
 			<p class="center"><img border="0" src="images/UAX15-NormFig6.jpg" alt="fi ligature, etc."></p>
	   </div>
		   <div class="book-only">
		   <p class="center"><img border="0" src="print-images/UAX15-NormFig6.jpg" alt="fi ligature, etc." width="317" height="149"></p>
	   </div>
	<p>In the NFKC and NFKD forms, many 
	formatting distinctions are removed, as shown in <i>Figure 6</i>. The “fi” 
	ligature changes into its components “f” and “i”, the superscript formatting 
	is removed from the “5”, and the long “s” is changed into a normal “s”.</p>
	<p>Normalization Form KC does <i>not</i> attempt to map character sequences to 
    compatibility composites. For example, a compatibility composition of “office” does <i>not</i> 
	produce “o\uFB03ce”, even though “\uFB03” is a character that is the 
	compatibility equivalent of the sequence of three characters “ffi”. In other 
	words, the composition phase of NFC and NFKC are the same—only their 
	decomposition phase differs, with NFKC applying compatibility 
	decompositions.</p>
  <p>All of the definitions in this annex depend on the rules for equivalence and decomposition 
  found in <i>Chapter 3, Conformance</i>, of [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]
  and the decomposition mappings in the Unicode Character Database [<a href="../tr41/tr41-1.html#UCD">UCD</a>].</p>
  <blockquote>
    <p><span class="note">Note:</span> Text exclusively containing only ASCII characters (U+0000..U+007F) is left unaffected by all of the Normalization Forms. This is 
	particularly important for programming languages (see <span class="section">Section </span>
	<span class="secno">13,</span> <i><a href="tr15-27.html#Programming_Language_Identifiers">Programming Language 
    Identifiers</a></i>).</p>
  </blockquote>
  <p>Normalization Form C uses canonical composite characters where possible, and maintains the 
  distinction between characters that are compatibility equivalents. Typical strings of composite 
  accented Unicode characters are already in Normalization Form C. Implementations of Unicode 
	that 
  restrict themselves to a repertoire containing no combining marks (such as those that declare 
  themselves to be implementations at level 1 as defined in ISO/IEC 10646-1) are already typically 
  using Normalization Form C. (Implementations of later versions of 10646 need to be aware of the 
  versioning issues—see <span class="section">Section </span><span class="secno">3,</span> <i><a href="tr15-27.html#Versioning">Versioning and Stability</a></i>.)</p>
  <p>The <i>W3C Character Model for the World Wide Web</i> [<a href="../tr41/tr41-1.html#CharMod">CharMod</a>] uses 
  Normalization Form C for XML and related standards (that document is not yet final, but this 
  requirement is not expected to change). See the <i>W3C Requirements for String Identity, Matching, 
  and String Indexing</i> [<a href="../tr41/tr41-1.html#CharReq">CharReq</a>] for more background.</p>
  <p>Normalization Form KC additionally folds the differences between compatibility-equivalent 
  characters that are inappropriately distinguished in many circumstances. For example, the 
  halfwidth and fullwidth <i>katakana</i> characters will normalize to the same strings, as will 
  Roman numerals and their letter equivalents. More complete examples are provided in 
	<span class="section">Section </span><span class="secno">7<i>,</i></span><i>
	<a href="tr15-27.html#Examples">Examples and Charts</a></i>.</p>
  <p>Normalization Forms KC and KD must <i>not</i> be blindly applied to arbitrary text. Because 
  they erase many formatting distinctions, they will prevent round-trip conversion to and from many 
  legacy character sets, and unless supplanted by formatting markup, they may remove distinctions that 
  are important to the semantics of the text. It is best to think of these 
	Normalization Forms as 
  being like uppercase or lowercase mappings: useful in certain contexts for identifying core 
  meanings, but also performing modifications to the text that may not always be appropriate. They 
  can be applied more freely to domains with restricted character sets, such as in
	<span class="section">Section</span> <span class="secno">13,</span><i>
	<a href="tr15-27.html#Programming_Language_Identifiers">Programming Language Identifiers</a>.</i></p>
  <p>To summarize the treatment of compatibility composites that were in the source text:</p>
  <ul>
    <li>Both NFD and NFC maintain compatibility composites.</li>
    <li>Neither NFKD nor NFKC maintains compatibility composites.</li>
    <li>None of the forms <i>generate</i> compatibility composites that were not in the source text.
    </li>
  </ul>
  <p><i>For a list of all characters that may change in any of the Normalization 
	Forms (aside from 
  reordering), see <a href="charts">Normalization Charts</a> [<a href="../tr41/tr41-1.html#Charts">Charts</a>].</i></p>
  <h3 class="section">1.1 <a name="Concatenation">Concatenation</a></h3>
  <p>In using normalization functions, it is important to realize that <i>none</i> of 
  the Normalization Forms are closed under string concatenation. That is, even if two strings 
  X and Y are normalized, their string concatenation X+Y is <i>not</i> guaranteed to be normalized. 
  This even happens in NFD, because accents are canonically ordered, and may rearrange around the 
  point where the strings are joined. Consider the string concatenation examples shown in <i>Table 2</i>.</p>
	<p>However, it is possible to produce an optimized function that concatenates two normalized 
  strings and <i>does</i> guarantee that the result is normalized. Internally, 
	it only needs to normalize characters around the boundary of where the 
	original strings were joined, within stable code points. For more 
	information, see <span class="section">Section </span><span class="secno">14.1,</span> <i><a href="tr15-27.html#Stable_Code_Points">Stable Code 
  Points</a>.</i></p>
	<div class="book-only">
		&nbsp;</div>
  <p class="caption">Table 2. <span style="font-weight: 400">String Concatenation</span></p>
  <div align="center">
    <center>
    <table border="1" cellpadding="2">
      <tr>
        <th align="left">Form</th>
        <th align="left">String1</th>
        <th align="left">String2</th>
        <th align="left">Concatenation</th>
        <th align="left">Correct Normalization</th>
      </tr>
      <tr>
        <td>NFD</td>
        <td>a ^</td>
        <td>. (dot under)</td>
        <td>a ^ .</td>
        <td>a . ^</td>
      </tr>
      <tr>
        <td>NFC</td>
        <td>a</td>
        <td>^</td>
        <td>a ^</td>
        <td>â</td>
      </tr>
      <tr>
        <td>NFC</td>
        <td>ᄀ</td>
        <td>ᅡ ᆨ</td>
        <td>ᄀ ᅡ ᆨ</td>
        <td>각</td>
      </tr>
    </table>
    </center>
  </div>
  <p>However, all of the Normalization Forms <i>are</i> closed under substringing. For 
  example, if one takes a substring of a normalized string X, from offsets 5 to 10, one is 
  guaranteed that the resulting string is still normalized.</p>
  <h2 class="section"><a name="Notation"></a>2 Notation</h2>
  <p>All of the definitions in this annex depend on the rules for equivalence and decomposition 
  found in <i>Chapter 3, Conformance</i>, of [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>] 
  and the Character Decomposition Mapping and Canonical Combining Class property in 
	the Unicode Character Database [<a href="../tr41/tr41-1.html#UCD">UCD</a>]. 
  Decomposition <i>must</i> be done in accordance with these rules. In particular, the decomposition 
  mappings found in the Unicode Character Database must be applied recursively, and then the string 
  put into canonical order based on the characters’ combining classes.</p>
  <p><i>Table 3</i> lists examples of the notational conventions used in this 
	annex.</p>
	<p class="caption">Table 3. <span style="font-weight: 400">Notation Examples</span></p>
  <table cellpadding="2" border="0" cellspacing="0" style="border-collapse: collapse" id="table3">
    <tr>
      <th>Example Notation</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>combiningClass(X)</td>
      <td>The combining class of a character X</td>
    </tr>
    <tr>
      <td>&quot;...\uXXXX...&quot;</td>
      <td>The Unicode character U+XXXX embedded within a string</td>
    </tr>
    <tr>
      <td>&quot;...\UXXXXXXXX...&quot;</td>
      <td>The Unicode character U+XXXXXXXX embedded within a string</td>
    </tr>
    <tr>
      <td>B-C</td>
      <td>A single character that is equivalent to the sequence of characters B + C</td>
    </tr>
    <tr>
      <td>k<sub>i</sub>, a<sub>m</sub>, and k<sub>f</sub></td>
      <td>Conjoining jamo types (initial, medial, final) represented by subscripts</td>
    </tr>
    <tr>
      <td>&quot;c¸&quot;</td>
      <td><i>c</i> followed by a <i>nonspacing cedilla:</i> spacing accents (without a dotted 
      circle) may be used to represent nonspacing accents</td>
    </tr>
    <tr>
      <td>NFX(S)</td>
      <td>Any Normalization Form: NFD(S), NFKD(S), NFC(S), and NFKC(S) are the 
		possibilities</td>
    </tr>
    <tr>
      <td><i>toNFX(s)</i> </td>
      <td>A function that produces the the normalized form of a string s according to the definition 
      of Normalization Form X</td>
    </tr>
    <tr>
      <td><i>isNFC(s)</i></td>
      <td>
      <p dir="ltr">A binary property of a string s: isNFX(s) is true if and only if toNFX(s) 
      is identical to s; see also <span class="section">Section</span> <span class="secno">14,</span> 
		<i> 
		<a href="tr15-27.html#Annex8">Detecting Normalization Forms</a>.</i></td>
    </tr>
    <tr>
      <td>X ≈ Y</td>
      <td>X is canonically equivalent to Y</td>
    </tr>
    <tr>
      <td>X[a, b]</td>
      <td>The substring of X that includes all code units after offset a and before offset b; 
		for 
      example, if X is “abc”, then X[1,2] is “b”</td>
    </tr>
  </table>
  <p>Additional conventions used in this annex:</p>
  <ol>
    <li>A sequence of characters may be represented by using plus signs between the character names 
    or by using string notation.</li>
    <li>An <i>offset into a Unicode string</i> is a number from 0 to <i>n</i>, where <i>n</i> is the 
    length of the string and indicates a position that is logically between Unicode code units (or 
    at the very front or end in the case of 0 or <i>n</i>, respectively).</li>
    <li>Unicode names may be shortened, as shown in <i>Table 4.</i></li>
  </ol>
  <p class="caption">Table 4. <span style="font-weight: 400">Character Abbreviation</span></p>
  <div align="center">
    <center>
    <table cellpadding="2" border="0" cellspacing="0" style="border-collapse: collapse">
      <tr>
        <th width="129">Abbreviation</th>
        <th width="458">Full Unicode Name</th>
      </tr>
      <tr>
        <td width="129"><i>E-grave</i></td>
        <td width="458">LATIN CAPITAL LETTER E WITH GRAVE</td>
      </tr>
      <tr>
        <td width="129"><i>ka</i>&nbsp;</td>
        <td width="458">KATAKANA LETTER KA</td>
      </tr>
      <tr>
        <td width="129"><i>hw_ka</i></td>
        <td width="458">HALFWIDTH KATAKANA LETTER KA</td>
      </tr>
      <tr>
        <td width="129"><i>ten</i></td>
        <td width="458">COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK</td>
      </tr>
      <tr>
        <td width="129"><i>hw_ten</i></td>
        <td width="458">HALFWIDTH KATAKANA VOICED SOUND MARK</td>
      </tr>
    </table>
	<p>&nbsp;</p>
    </center>
  </div>
  <h2 class="section"><a name="Versioning"></a>3 Versioning and Stability</h2>
  <p>It is crucial that Normalization Forms remain stable over time. That is, if a string that does 
  not have any unassigned characters is normalized under one version of Unicode, it must remain 
  normalized under all future versions of Unicode. This is the backward compatibility requirement. 
  To meet this requirement, a fixed version for the composition process is specified, called 
  the <i>composition version.</i> The composition<i></i> version is defined to be <b>Version 3.1.0</b> 
  of the Unicode Character Database. For more information, see</p>
  <ul>
    <li>Versions of the Unicode Standard [<a href="../tr41/tr41-1.html#Versions">Versions</a>]</li>
    <li>Unicode 3.1 [<a href="../tr41/tr41-1.html#Unicode3.1">Unicode3.1</a>]</li>
    <li>Unicode Character Database [<a href="../tr41/tr41-1.html#UCD">UCD</a>]</li>
  </ul>
  <p>To see what difference the composition version makes, suppose that a future version of Unicode 
  were to add the composite <i>Q-caron</i>. For an implementation that uses that future version of 
  Unicode, strings in Normalization Form C or KC would continue to contain the sequence <i>Q&nbsp;+&nbsp;caron,</i> 
  and <i>not</i> the new character <i>Q-caron</i>, because a canonical composition for <i>Q-caron</i> 
  was not defined in the composition version. See <span class="section">Section </span><span class="secno">6,</span>
  <i><a href="tr15-27.html#Primary_Exclusion_List_Table">Composition Exclusion Table</a></i>, for more information.</p>
  <p>It would be possible to add more compositions in a future version of Unicode, as long as the 
  backward compatibility requirement is met. It requires that for any new composition XY 
	→ Z, at 
  most one of X or Y was defined in a previous version of Unicode. That is, Z must be a new 
  character, and either X or Y must be a new character. However, the Unicode Consortium strongly 
  discourages new compositions, even in such restricted cases.</p>
  <p>In addition to fixing the composition version, future versions of Unicode must be restricted in 
  terms of the kinds of changes that can be made to character properties. Because of this, the 
  Unicode Consortium has a clear policy to guarantee the stability of 
	Normalization Forms.</p>
  <h3 class="section">3.1 <a name="Stability_of_Normalized_Forms">Stability of Normalized 
  Forms</a></h3>
  <p><i>A normalized string is guaranteed to be stable; that 
  is, once normalized, a string is normalized according to all future versions of Unicode.</i></p>
  <p>More precisely, if a string has been normalized according to a particular 
	version of Unicode <i>and</i> contains only characters allocated in that version, it 
  will qualify as normalized according to any future version of Unicode.</p>
  <h3 class="section"><b>3.2 <a name="Stability_of_the_Normalization_Process">
  Stability of the Normalization Process</a></b></h3>
  <p>The <i>process</i> of producing a normalized string from an 
  unnormalized string has the same results under each version of Unicode, except for certain edge 
  cases addressed in the following corrigenda:</p>
  <ul>
    <li>Three corrigenda correct certain data mappings for a total of 
    seven characters:<table border="1" cellpadding="2" cellspacing="0" style="margin:0.5em; border-collapse: collapse" id="AutoNumber1">
      <tr>
        <td width="100%">
        Corrigendum #2, “<a href="http://www.unicode.org/versions/corrigendum2.html">U+FB1D 
        Normalization</a>” [<a href="../tr41/tr41-1.html#Corrigendum2">Corrigendum2</a>]</td>
      </tr>
      <tr>
        <td width="100%">
        Corrigendum #3, “<a href="http://www.unicode.org/versions/corrigendum3.html">U+F951 
        Normalization</a>” [<a href="../tr41/tr41-1.html#Corrigendum3">Corrigendum3</a>]</td>
      </tr>
      <tr>
        <td width="100%">
        Corrigendum #4, “<a href="http://www.unicode.org/versions/corrigendum4.html">Five Unihan 
        Canonical Mapping Errors</a>” [<a href="../tr41/tr41-1.html#Corrigendum4">Corrigendum4</a>]</td>
      </tr>
    </table>
    </li>
    <li>
    Corrigendum #5, “<a href="http://www.unicode.org/versions/corrigendum5.html">Normalization Idempotency</a>” 
	[<a href="../tr41/tr41-1.html#Corrigendum5">Corrigendum5</a>], fixed a problem in the description of the 
    normalization process for some instances of particular sequences. <i>Such instances never occur 
    in meaningful text.</i></li>
  </ul>
  <h3 class="section">3.3 <a name="Guaranteeing_Process_Stability">Guaranteeing Process 
  Stability</a></h3>
  <p>Unicode provides a mechanism for those implementations that require 
  not only normalized strings, <i>but also the normalization process</i>, to be absolutely stable 
  between two versions (including the edge cases mentioned in <span class="section">Section </span><span class="secno">3.2,</span>
	<a href="tr15-27.html#Stability_of_the_Normalization_Process"> 
	<i>Stability of the Normalization Process</i>)</a>. This, of course, 
  is true only where the repertoire of characters is limited to those character present in the 
  earlier version of Unicode.</p>
  <p>To have the newer implementation produce the same results as the 
  older version (for characters defined as of the older version):</p>
  <ol>
    <li>Premap a maximum of seven (rare) characters according to whatever 
    corrigenda came between the two versions (see [<a href="../tr41/tr41-1.html#Errata">Errata</a>]).<ul>
      <li>For example, for a Unicode 4.0 implementation to produce the 
      same results as Unicode 3.2, the five characters mentioned in
      [<a href="../tr41/tr41-1.html#Corrigendum4">Corrigendum4</a>] are premapped 
      to the <i>old</i> values given in version 4.0 of the UCD data file [<a href="../tr41/tr41-1.html#Corrections">Corrections</a>].</li></ul>
    </li>
    <li>If the earlier version is before Unicode 4.1 and the later version 
    is 4.1 or later, reorder the sequences listed in <i>Table 11</i> of <span class="section">Section</span> <span class="secno">20,</span><i>
	<a href="tr15-27.html#Corrigendum_5_Sequences">Corrigendum 5 Sequences</a></i>, as follows:
    <blockquote>
      <table border="1" cellpadding="2" cellspacing="0" style="border-collapse: collapse;" id="AutoNumber2">
        <tr>
          <td><b>From:</b></td>
          <td style="text-align: center">first_character&nbsp;
          </td>
          <td style="text-align: center">intervening_character(s)</td>
          <td style="text-align: center"><i>last_character</i></td>
        </tr>
        <tr>
          <td><span style="font-weight: 700">T</span><span style="font-weight: 700; ">o:</span></td>
          <td style="text-align: center">first_character&nbsp;
          </td>
          <td style="text-align: center"><i>last_character</i> </td>
          <td style="text-align: center">intervening_character(s)</td>
        </tr>
      </table>
    </blockquote>
    </li>
    <li>Apply the newer version of normalization.</li>
  </ol>
  <blockquote>
	<p><span class="note">Note:</span> For step 2, in most implementations it is actually more 
  efficient (and much simpler) to parameterize the code to provide for both pre- and post-Unicode 
  4.1 behavior. This typically takes only one additional conditional statement.</p>
	</blockquote>
	<h3 class="section">3.4 <a name="Forbidding_Characters">Forbidding 
	Characters</a></h3>
	<p>An alternative approach for certain protocols is to forbid characters 
	that differ in normalization status across versions. The characters and 
	sequences affected are not in any practical use, so this may be viable for 
	some implementations. For example, when upgrading from Unicode 3.2 to 
	Unicode 5.0, there are three relevant corrigenda:</p>
	<ul>
		<li>
		Corrigendum #3, “<a href="http://www.unicode.org/versions/corrigendum3.html">U+F951 
        Normalization</a>” [<a href="../tr41/tr41-1.html#Corrigendum3">Corrigendum3</a>]</li>
		<li>
		Corrigendum #4, “<a href="http://www.unicode.org/versions/corrigendum4.html">Five Unihan 
        Canonical Mapping Errors</a>” [<a href="../tr41/tr41-1.html#Corrigendum4">Corrigendum4</a>] <br>
		The five characters are U+2F868, U+2F874, U+2F91F, U+2F95F, and U+2F9BF.</li>
		<li>
		Corrigendum #5, “<a href="http://www.unicode.org/versions/corrigendum5.html">Normalization Idempotency</a>” 
		[<a href="../tr41/tr41-1.html#Corrigendum5">Corrigendum5</a>]</li>
	</ul>
	<blockquote>
		<p>The characters in Corrigenda #3 and #4 are 
		all extremely rare Han characters. They are compatibility characters
		included only for compatibility with a single East Asian
		character set standard each: U+F951 for a duplicate character
		in KS X 1001, and the other five for CNS 11643-1992. That&#x2019;s
 why
		they have canonical decomposition mappings in the first place.</p>
		<p>The duplicate character in KS X 1001 is a rare character in
		Korean to begin with—in a South Korean standard, where the
		use of Han characters at all is uncommon in actual data. And
		this is a pronunciation duplicate, which even if it were used
		would very likely be inconsistently and incorrectly used by
		end users, because there is no visual way for them to make
		the correct distinctions.</p>
		<p>The five characters from CNS 11643-1992 have even less utility.
		They are minor glyphic variants of unified characters—the
		kinds of distinctions that are subsumed already within all
		the unified Han ideographs in the Unicode Standard. They are from Planes 4–15 of
		CNS 11643-1992, which never saw any commercial implementation
		in Taiwan. The IT systems in Taiwan almost all implemented
		Big Five instead, which was a slight variant on Planes 1 and 2
		of CNS 11643-1986, and which included none of the five glyph
		variants in question here.</p>
		<p >As for Corrigendum #5, it is important to recognize that none of the 
		affected sequences occur in any well-formed text in any language. See 
		<span class="section">Section </span><span class="secno">20,</span>&nbsp;<i><a href="tr15-27.html#Corrigendum_5_Sequences">Corrigendum 
		5 Sequences</a>.</i></p>
	</blockquote>
  <p>For more information, see <span class="section">Section </span><span class="secno">18,</span> <i><a href="tr15-27.html#Corrigenda">Corrigenda</a></i>.</p>
  <h2 class="section"><a name="Conformance"></a>4 Conformance</h2>
  <p><i><b>UAX15-C1.</b> A process that produces Unicode text that 
  purports to be in a Normalization Form shall do so in accordance with the specifications in this 
  annex.</i></p>
  <p><i><b>UAX15-C2.</b> A process that tests Unicode text to 
  determine whether it is in a Normalization Form shall do so in accordance with the specifications 
  in this annex.</i></p>
  <p><i><b>UAX15-C3.</b> A process that purports to transform text 
  into a Normalization Form must be able to pass the conformance test described in
	<span class="section">Section</span> <span class="secno">15,</span>
	<a href="tr15-27.html#Conformance_Testing">Conformance Testing</a>.</i></p>
	<p><i><b>UAX15-C4.</b> 
	A process that purports to transform 
	text according to the</i> <a href="tr15-27.html#Stream_Safe_Text_Format">
	<span style="font-style: italic; ">Stream-Safe Text 
	Format</span></a><i> must do so in 
	accordance with the specifications in this annex.</i></p>
	<p>The specifications for Normalization Forms are written in terms of a process for 
    producing a decomposition or composition from an arbitrary Unicode string. This is a 
	<i>logical</i> 
    description—particular implementations can have more efficient mechanisms as long as they 
    produce the same result. See C18 in <i>Chapter 3, Conformance</i>, of [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>] 
	and the notes following. Similarly, testing for a particular Normalization Form does not require 
    applying the process of normalization, so long as the result of the test is equivalent to 
    applying normalization and then testing for binary identity.</p>
  <h2 class="section"><a name="Specification"></a>5 Specification</h2>
  <p>This section specifies the format for Normalization Forms C and KC. It uses four 
  definitions <a href="tr15-27.html#D1">D1</a>, <a href="tr15-27.html#D2">D2</a>, <a href="tr15-27.html#D3">D3</a>, <a href="tr15-27.html#D4">D4</a>, 
  and two rules <a href="tr15-27.html#Normalization_Form_C">R1</a> and <a href="tr15-27.html#Normalization_Form_KC">R2</a>. 
	In these definitions and rules, and in explanatory text, the term “character” is used. 
	It should be interpreted as meaning 
	“code point,” 
	because the algorithm applies to any sequence of code points, including those 
	containing code points that are not assigned characters. </p>
  <p>All combining character sequences start with a character of combining class zero. For 
  simplicity, the following term is defined for such characters:</p>
  <p><a name="D1"></a><b>D1.</b> A character S is a <i>starter</i> if it has a combining class of 
  zero in the Unicode Character Database. Any other character is a	<span style="font-style: italic;">non-starter</span>.</p>
  <p>Because of the definition of canonical equivalence, the order of combining characters with the 
  same combining class makes a difference. For example, <i>a-macron-breve</i> is not the same as <i>
  a-breve-macron</i>. Characters cannot be composed if that would change the canonical order of the 
  combining characters.</p>
  <p><a name="D2"></a><b>D2.</b> In any character sequence beginning with a starter S, a character C 
  is <i>blocked</i> from S if and only if there is some character B between S and C, and either B is 
  a starter or it has the same <b>or higher</b> combining class as C.</p>
  <ul>
    <li>This definition is to be applied only to strings that are already canonically decomposed.</li>
  </ul>
  <p>When B blocks C, changing the order of B and C would result in a character sequence that is <i>
  not</i> canonically equivalent to the original. See <i>Section 3.11, Canonical Ordering 
  Behavior</i>&nbsp; [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>].</p>
  <p>If a combining character sequence is in canonical order, then testing whether a character is 
  blocked requires looking at only the immediately preceding character.</p>
  <p>The process of forming a composition in Normalization Form C or KC involves 
	two steps:</p>
  <ol>
	<li>Decomposing the string according to the canonical (or compatibility, respectively) mappings 
    of the Unicode Character Database that correspond to the latest version of 
	Unicode supported by the implementation.</li>
	<li>Composing the resulting string according to the <i>canonical</i> mappings of the composition 
    version of the Unicode Character Database by successively composing each unblocked character 
    with the last starter.</li>
	</ol>
  <p><i>Figure 7</i> shows a sample of the<span style="font-style: italic; "> </span>
	how the composition process works. The dark green cubes represent starters, and the light gray cubes represent 
  non-starters. In the first step, the string is fully decomposed and reordered. In the second 
  step, each character is checked against the last non-starter and starter, and 
  combined if all the conditions are met. Examples are provided in<span class="section"><i> </i>Section</span> <span class="secno"> 
	7,</span><i> <a href="tr15-27.html#Examples">Examples and Charts</a>,</i> and a code sample is provided in 
	<span class="section">Section</span> <span class="secno">11,</span> 
	<a href="tr15-27.html#Code_Sample"> <i>Code Sample</i></a>.</p>
  <p class="caption">Figure 7. <span style="font-weight: 400">Composition Process</span></p>
	  <div class="web-only">
 			<p class="center"><img border="0" src="images/UAX15-figure7.jpg" alt="diagram" width="432" height="154"></p>
	   </div>
	  <div class="book-only">
 			<p class="center"><img border="0" src="print-images/UAX15-figure7.jpg" alt="diagram" width="432" height="154"></p>
	  </div>
  <p>A precise notion is required for when an unblocked character can be composed with a starter. 
  This uses the following two definitions.</p>
  <p><a name="D3"></a><b>D3.</b> A <i>primary composite</i> is a character that has a canonical 
  decomposition mapping in the Unicode Character Database (or has a canonical Hangul decomposition) 
  but is not in the <span class="section">Section </span><span class="secno">6,</span> <i><a href="tr15-27.html#Primary_Exclusion_List_Table">Composition 
  Exclusion Table</a></i>.</p>
  <blockquote>
    <p><span class="note">Note:</span> Hangul syllable decomposition is considered a canonical decomposition. See
    [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>] 
    and <span class="section">Section</span> <span class="secno">16,</span><i> <a href="tr15-27.html#Hangul">Hangul</a></i>.</p>
  </blockquote>
  <p><a name="D4"></a><b>D4.</b> A character X can be <i>primary combined</i> with a character Y if 
  and only if there is a primary composite Z that is canonically equivalent to the sequence &lt;X, Y&gt;.</p>
  <p>Based upon these definitions, the following rules specify the Normalization Forms C and KC.</p>
  <h3><a name="Normalization_Form_C"></a>R1. Normalization Form C</h3>
  <p>The Normalization Form C for a string S is obtained by applying the following process, or any 
  other process that leads to the same result:</p>
  <ol>
    <li>Generate the <i>canonical</i> decomposition for the source string S according to the 
    decomposition mappings in the <i>latest supported</i> version of the Unicode Character Database.
    </li>
    <li>Iterate through each character C in that decomposition, from first to last. If C is not 
    blocked from the last starter L and it can be primary combined with L, then replace L by the 
    composite L-C and remove C.</li>
  </ol>
  <p>The result of this process is a new string S&#39;, which is in Normalization Form C.</p>
  <h3><a name="Normalization_Form_KC"></a>R2. Normalization Form KC</h3>
  <p>The Normalization Form KC for a string S is obtained by applying the following process, or any 
  other process that leads to the same result:</p>
  <ol>
    <li>Generate the <i>compatibility</i> decomposition for the source string S according to 
    the decomposition mappings in the <i>latest supported</i> version of the Unicode Character 
    Database.</li>
    <li>Iterate through each character C in that decomposition, from first to last. If C is not 
    blocked from the last starter L and it can be primary combined with L, then replace L by the 
    composite L-C and remove C.</li>
  </ol>
  <p>The result of this process is a new string S&#39;, which is in Normalization Form KC.</p>
  <h2 class="section"><a name="Primary_Exclusion_List_Table"></a>6 Composition Exclusion Table</h2>
  <p>There are four classes of characters that are excluded from composition:</p>
  <ol>
    <li><b>Script-specifics:</b> precomposed characters that are generally not the preferred form 
    for particular scripts.
    <ul>
      <li>These <i>cannot</i> be computed from information in the Unicode Character Database.</li>
		<li>An example is U+0958 (&#x958;) <span class="name">DEVANAGARI 
		LETTER QA</span>.</li>
    </ul>
    </li>
    <li><b>Post composition version:</b> precomposed characters that are added after Unicode 3.0 
    [<a href="../tr41/tr41-1.html#Unicode3.0">Unicode3.0</a>] and whose decompositions 
	exist in prior versions of Unicode. This set will be updated with each subsequent version of Unicode. For more 
    information, see <span class="section">Section </span><span class="secno">3,</span><i> <a href="tr15-27.html#Versioning">Versioning and 
    Stability</a></i>.
    <ul>
      <li>These <i>cannot</i> be computed from information in the Unicode Character Database.</li>
		<li>An example is U+2ADC (<span class="mathsym1">&#x2ADC;</span>) 
		<span class="name">FORKING</span>.</li>
    </ul>
    </li>
    <li><b>Singletons:</b> characters having decompositions that consist of single characters (as 
    described below).
    <ul>
      <li>These <i>are</i> computed from information in the Unicode Character Database.</li>
		<li>An example is U+2126 (&#x2126;) <span class="name">OHM 
		SIGN</span>.</li>
    </ul><div class="book-only">&nbsp;</div>
    </li>
    <li><b>Non-starter decompositions:</b> precomposed characters whose decompositions start with a 
    non-starter.
    <ul>
      <li>These <i>are</i> computed from information in the Unicode Character Database.</li>
		<li>An example is U+0344 (&nbsp;&nbsp; ̈́) <span class="name">COMBINING GREEK DIALYTIKA TONOS</span>.</li>
    </ul>
    </li>
  </ol>
  <p>Two characters may have the same canonical decomposition in the Unicode Character Database. <i>
  	Table 5</i> shows an example.</p> 	<div class="book-only">
		<p>&nbsp;</p></div>
  <p class="caption">Table 5. <span style="font-weight: 400">Same Canonical Decomposition</span></p>
  <table border="1" cellspacing="2" cellpadding="2">
    <tr>
      <th>Source</th>
      <th>Same Decomposition</th>
    </tr>
    <tr>
      <td>212B (Å) <span class="name">ANGSTROM SIGN</span></td>
      <td rowspan="2">0041 (A)&nbsp;<span class="name">LATIN CAPITAL LETTER A</span> + 030A 
		(°)&nbsp;<span class="name">COMBINING RING ABOVE</span></td>
    </tr>
    <tr>
      <td>00C5 (Å) <span class="name">LATIN CAPITAL LETTER A WITH RING ABOVE</span></td>
    </tr>
  </table> 	<div class="book-only">
		<p>&nbsp;</p></div>
  <p>The Unicode Character Database will first decompose one of the characters to the other, and 
  then decompose from there. That is, one of the characters (in this case, U+212B <span class="name">ANGSTROM SIGN</span>) 
  will have a singleton decomposition. Characters with singleton decompositions are included in 
  Unicode for compatibility with certain preexisting standards. These singleton 
  decompositions are excluded from primary composition.</p>
  <h4 align="left">Data File</h4>
	<p>The Composition Exclusion Table is available as machine-readable 
	data file 
    [<a href="../tr41/tr41-1.html#Exclusions">Exclusions</a>].</p>
	<p>All four classes of characters are included in this file, 
	although the singletons and non-starter decompositions are commented out, 
	as they can be computed from the decomposition mappings in the Unicode 
	Character Database.</p>
	<p>A derived property containing the complete list of exclusions, 
	<code>Comp_Ex</code>, 
    is available separately in the Unicode Charactger Database [<a href="../tr41/tr41-1.html#UCD">UCD</a>] 
	and is described in the UCD documentation [<a href="../tr41/tr41-1.html#UCDDoc">UCDDoc</a>]. Implementations can 
    avoid computing the singleton and non-starter decompositions from the Unicode Character Database 
    by using the <code>Comp_Ex</code> property instead.</p> 	<div class="book-only">
		<p>&nbsp;</p></div>
  <h2 class="section"><a name="Examples"></a>7 Examples and Charts</h2>
  <p>This section provides some detailed examples of the results when each of the 
	Normalization Forms is applied. The <a href="charts">Normalization Charts</a> 
  [<a href="../tr41/tr41-1.html#Charts">Charts</a>] provide charts of all the characters in Unicode that differ 
  from at least one of their Normalization Forms (NFC, NFD, NFKC, NFKD).</p>
  	<div class="book-only"><p>&nbsp;</p>
		<p>&nbsp;</p></div><h4>Basic Examples</h4>
	<p>The 
	basic examples in <i>Table 6</i> do not involve compatibility 
	decompositions. Therefore, in each case Normalization Forms NFD and NFKD are 
	identical, and Normalization Forms NFC and NFKC are also identical.
 </p>
  <div class="center">
  <center><p class="caption">
  <a name="Common_Examples"></a>Table 6. 
	<span style="font-weight: 400">Basic Examples</span></p>
  <table border="1" cellspacing="1" cellpadding="1">
    <tr>
      <th valign="top" height="19" width="1"></th>
      <th valign="top" width="20%">Original</th>
      <th valign="top" width="20%">NFD, NFKD</th>
      <th valign="top" width="20%">NFC, NFKC</th>
      <th valign="TOP" align="LEFT">Notes</th>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">a</th>
      <td valign="TOP" align="CENTER" width="20%">D-dot_above</td>
      <td valign="TOP" align="CENTER" width="20%">D +&nbsp;dot_above</td>
      <td valign="TOP" align="CENTER" width="20%">D-dot_above</td>
      <td rowspan="2" valign="TOP">Both decomposed and precomposed canonical 
      sequences produce the same result.</td>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">b</th>
      <td valign="TOP" align="CENTER" width="20%">D +&nbsp;dot_above</td>
      <td valign="TOP" align="CENTER" width="20%">D +&nbsp;dot_above</td>
      <td valign="TOP" align="CENTER" width="20%">D-dot_above</td>
    </tr>
    <tr>
      <th valign="top" height="32" width="10">c</th>
      <td valign="TOP" align="CENTER" width="20%">D-dot_below +&nbsp;dot_above</td>
      <td valign="TOP" align="CENTER" width="20%">D +&nbsp;dot_below +&nbsp;dot_above</td>
      <td valign="TOP" align="CENTER" width="20%">D-dot_below +&nbsp;dot_above</td>
      <td rowspan="3" valign="TOP">The <i>dot_above</i> cannot be combined 
      with the D because the D has already combined with the intervening <i>dot_below</i>.<p>&nbsp;</td>
    </tr>
    <tr>
      <th valign="top" height="32" width="10">d</th>
      <td valign="TOP" align="CENTER" width="20%">D-dot_above +&nbsp;dot_below</td>
      <td valign="TOP" align="CENTER" width="20%">D +&nbsp;dot_below +&nbsp;dot_above</td>
      <td valign="TOP" align="CENTER" width="20%">D-dot_below +&nbsp;dot_above</td>
    </tr>
    <tr>
      <th valign="top" height="32" width="10">e</th>
      <td valign="TOP" align="CENTER" width="20%">D +&nbsp;dot_above +&nbsp;dot_below</td>
      <td valign="TOP" align="CENTER" width="20%">D +&nbsp;dot_below +&nbsp;dot_above</td>
      <td valign="TOP" align="CENTER" width="20%">D-dot_below +&nbsp;dot_above</td>
    </tr>
    <tr>
      <th valign="top" height="45" width="10">f</th>
      <td valign="TOP" align="CENTER" width="20%">D +&nbsp;dot_above +&nbsp;horn +&nbsp;dot_below</td>
      <td valign="TOP" align="CENTER" width="20%">D +&nbsp;horn +&nbsp;dot_below +&nbsp;dot_above</td>
      <td valign="TOP" align="CENTER" width="20%">D-dot_below +&nbsp;horn +&nbsp;dot_above</td>
      <td valign="TOP">There may be intervening combining marks, so long as the 
      result of the combination is canonically equivalent.</td>
    </tr>
    <tr>
      <th valign="top" height="29" width="10">g</th>
      <td valign="TOP" align="CENTER" width="20%">E-macron-grave</td>
      <td valign="TOP" align="CENTER" width="20%">E +&nbsp;macron +&nbsp;grave</td>
      <td valign="TOP" align="CENTER" width="20%">E-macron-grave</td>
      <td rowspan="2">Multiple combining characters are combined with the base 
      character.</td>
    </tr>
    <tr>
      <th valign="top" height="23" width="10">h</th>
      <td valign="TOP" align="CENTER" width="20%">E-macron +&nbsp;grave</td>
      <td valign="TOP" align="CENTER" width="20%">E +&nbsp;macron +&nbsp;grave</td>
      <td valign="TOP" align="CENTER" width="20%">E-macron-grave</td>
    </tr>
    <tr>
      <th valign="top" height="26" width="10">i</th>
      <td valign="TOP" align="CENTER" width="20%">E-grave +&nbsp;macron</td>
      <td valign="TOP" align="CENTER" width="20%">E +&nbsp;grave +&nbsp;macron</td>
      <td valign="TOP" align="CENTER" width="20%">E-grave +&nbsp;macron</td>
      <td>Characters will <i>not</i> be combined if they would not be canonical 
      equivalents because of their ordering.</td>
    </tr>
    <tr>
      <th valign="top" height="23" width="10">j</th>
      <td valign="TOP" align="CENTER" width="20%">angstrom_sign</td>
      <td valign="TOP" align="CENTER" width="20%">A + ring</td>
      <td valign="TOP" align="CENTER" width="20%">A-ring</td>
      <td rowspan="2" valign="TOP">Because Å (A-ring) is the preferred composite, it 
      is the form produced for both characters.</td>
    </tr>
    <tr>
      <th valign="top" height="23" width="10">k</th>
      <td valign="TOP" align="CENTER" width="20%">A-ring</td>
      <td valign="TOP" align="CENTER" width="20%">A + ring</td>
      <td valign="TOP" align="CENTER" width="20%">A-ring</td>
    </tr>
  </table>
    <p>&nbsp;</p> 	<div class="book-only">
		<p>&nbsp;</p></div>
    </center>
  </div>
  <h4>Effect of Compatibility Decompositions</h4>
	<p>The examples in <i>Table 7</i> and <i>Table 8</i> illustrate the 
	effect of compatibility decompositions. When text is normalized in forms NFD 
	and NFC, as in <i>Table 7</i>, compatibility-equivalent strings do not 
	result in the same strings. However, when the same strings are normalized in 
	forms NFKD and NFKC, as shown in <i>Table 8</i>, they do result in the same 
	strings. The tables also contain an entry showing that Hangul syllables are 
	maintained under all Normalization Forms.
	</p> 	<div class="book-only">
		<p>&nbsp;</p></div>
  <div class="center">
  <center>
	<p class="caption"><a name="Canonical_Composition_Examples"></a>Table 7. 
  <span style="font-weight: 400">NFD and NFC Applied to 
	Compatibility-Equivalent Strings</span></p>
  <table border="1" cellspacing="1" cellpadding="1">
    <tr>
      <th valign="top" height="19" width="1"></th>
      <th valign="top" width="20%">Original</th>
      <th valign="top" width="20%">NFD</th>
      <th valign="top" width="20%">NFC</th>
      <th valign="TOP" align="LEFT">Notes</th>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">l</th>
      <td valign="top" align="CENTER" width="20%">&quot;Äffin&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;A\u0308ffin&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Äffin&quot;</td>
      <td valign="TOP" rowspan="2">The <i>ffi_ligature</i> (U+FB03) is <i>not</i> 
      decomposed, because it has a compatibility mapping, not a canonical mapping. (See
      Table 8.)</td>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">m</th>
      <td valign="top" align="CENTER" width="20%">&quot;Ä\uFB03n&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;A\u0308\uFB03n&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Ä\uFB03n&quot;</td>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">n</th>
      <td valign="top" align="CENTER" width="20%">&quot;Henry IV&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Henry IV&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Henry IV&quot;</td>
      <td rowspan="2" valign="TOP">Similarly, the ROMAN NUMERAL IV (U+2163) is <i>
      not</i> decomposed.</td>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">o</th>
      <td valign="top" align="CENTER" width="20%">&quot;Henry \u2163&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Henry \u2163&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Henry \u2163&quot;</td>
    </tr>
    <tr>
      <th valign="top" height="20" width="10">p</th>
      <td valign="top" align="CENTER" width="20%">ga</td>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">ga</td>
      <td rowspan="5" valign="TOP">Different compatibility equivalents of a single 
      Japanese character will <i>not</i> result in the same string in NFC.</td>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">q</th>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">ga</td>
    </tr>
    <tr>
      <th valign="top" height="17" width="10">r</th>
      <td valign="top" align="CENTER" width="20%">hw_ka +&nbsp;hw_ten</td>
      <td valign="top" align="CENTER" width="20%">hw_ka +&nbsp;hw_ten</td>
      <td valign="top" align="CENTER" width="20%">hw_ka +&nbsp;hw_ten</td>
    </tr>
    <tr>
      <th valign="top" height="17" width="10">s</th>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;hw_ten</td>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;hw_ten</td>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;hw_ten</td>
    </tr>
    <tr>
      <th valign="top" height="17" width="10">t</th>
      <td valign="top" align="CENTER" width="20%">hw_ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">hw_ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">hw_ka +&nbsp;ten</td>
    </tr>
    <tr>
      <th valign="top" height="17" width="10">u</th>
      <td valign="top" align="CENTER" width="20%">kaks</td>
      <td valign="top" align="CENTER" width="20%">k<sub>i</sub> + a<sub>m</sub> + ks<sub>f</sub></td>
      <td valign="top" align="CENTER" width="20%">kaks</td>
      <td valign="TOP" align="CENTER">
      <p>Hangul syllables are maintained under normalization.</td>
    </tr>
  </table>
  </center>
  </div>
  <br>
  &nbsp;<!-- THERE ARE TWO COPIES OF TABLE 8 TO SOLVE A PAGINATION PROBLEM -->
  <div class="center">
  <center>
  <p class="caption"><a name="Compatibility_Composition_Examples"></a>Table 8. 
  <span style="font-weight: 400">NFKD and NFKC Applied to 
	Compatibility-Equivalent Strings</span></p>
  <table border="1" cellspacing="1" cellpadding="1">
    <tr>
      <th valign="top" height="19" width="10"></th>
      <th valign="top" width="20%">Original</th>
      <th valign="top" width="20%">NFKD</th>
      <th valign="top" width="20%">NFKC</th>
      <th valign="TOP" align="LEFT">Notes</th>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">l&#39;</th>
      <td valign="top" align="CENTER" width="20%">&quot;Äffin&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;A\u0308ffin&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Äffin&quot;</td>
      <td rowspan="2" valign="TOP">The <i>ffi_ligature</i> (U+FB03) <i>is</i> 
      decomposed in NFKC (where it is not in NFC).</td>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">m&#39;</th>
      <td valign="top" align="CENTER" width="20%">&quot;Ä\uFB03n&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;A\u0308ffin&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Äffin&quot;</td>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">n&#39;</th>
      <td valign="top" align="CENTER" width="20%">&quot;Henry IV&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Henry IV&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Henry IV&quot;</td>
      <td rowspan="2" valign="TOP">Similarly, the resulting strings here are 
      identical in NFKC.</td>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">o&#39;</th>
      <td valign="top" align="CENTER" width="20%">&quot;Henry \u2163&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Henry IV&quot;</td>
      <td valign="top" align="CENTER" width="20%">&quot;Henry IV&quot;</td>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">p&#39;</th>
      <td valign="top" align="CENTER" width="20%">ga</td>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">ga</td>
      <td rowspan="5" valign="TOP">Different compatibility equivalents of a single 
      Japanese character <i>will</i> result in the same string in NFKC.</td>
    </tr>
    <tr>
      <th valign="top" height="19" width="10">q&#39;</th>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">ga</td>
    </tr>
    <tr>
      <th valign="top" height="18" width="10">r&#39;</th>
      <td valign="top" align="CENTER" width="20%">hw_ka +&nbsp;hw_ten</td>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">ga</td>
    </tr>
    <tr>
      <th valign="top" height="17" width="10">s&#39;</th>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;hw_ten</td>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">ga</td>
    </tr>
    <tr>
      <th valign="top" height="18" width="10">t&#39;</th>
      <td valign="top" align="CENTER" width="20%">hw_ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">ka +&nbsp;ten</td>
      <td valign="top" align="CENTER" width="20%">ga</td>
    </tr>
    <tr>
      <th valign="top" height="17" width="10">u&#39;</th>
      <td valign="top" align="CENTER" width="20%">kaks</td>
      <td valign="top" align="CENTER" width="20%">k<sub>i</sub> + a<sub>m</sub> + ks<sub>f</sub></td>
      <td valign="top" align="CENTER" width="20%">kaks</td>
      <td valign="TOP" align="CENTER">
      <p>Hangul syllables are maintained under normalization.*</td>
    </tr>
  </table>
  </center>
  </div>
  <p>*In earlier versions of Unicode, jamo characters like ks<sub>f</sub> had 
  compatibility mappings to k<sub>f</sub> + s<sub>f</sub>. These mappings were removed in Unicode 
  2.1.9 to ensure that Hangul syllables are maintained.</p>
	<div class="book-only">
		&nbsp;</div>
  <h2 class="section"><a name="Design_Goals"></a>8 Design Goals</h2>
  <p>The following are the design goals for the specification of the 
	Normalization Forms and are 
  presented here for reference. The first goal is a fundamental conformance feature of the 
  design.</p>
  <h4>Goal 1: Uniqueness</h4>
  <p>The first, and by far the most important, design goal for the Normalization 
	Forms is 
  uniqueness. Two equivalent strings will have <i>precisely</i> the same normalized form. More 
  explicitly,</p>
  <ol>
    <li>If two strings x and y are canonical equivalents, then
    <ul class="nobullet">
      <li>toNFC(x) = toNFC(y)</li>
      <li>toNFD(x) = toNFD(y)</li>
    </ul>
    </li>
    <li>If two strings are compatibility equivalents, then
    <ul class="nobullet">
      <li>toNFKC(x) = toNFKC(y)</li>
      <li>toNFKD(x) = toNFKD(y)</li>
    </ul>
    </li>
    <li>All of the transformations are idempotent: that is,<ul class="nobullet">
      <li>toNFC(toNFC(x)) = toNFC(x)</li>
      <li>toNFD(toNFD(x)) = toNFD(x)</li>
      <li>toNFKC(toNFKC(x)) = toNFKC(x)</li>
      <li>toNFKD(toNFKD(x)) = toNFKD(x)</li>
    </ul>
    </li>
  </ol>
  <p>Goal 1.3 is a consequence of Goals 1.2 and 1.1, but is stated here for clarity.</p>
  <h4>Goal 2: Stability</h4>
  <p>The second major design goal for the Normalization Forms is stability of characters that are 
  not involved in the composition or decomposition process.</p>
  <ol>
    <li>If X contains a character with a compatibility decomposition, then toNFD(X) and toNFC(X) 
    still contain that character.</li>
    <li>As much as possible, if there are no combining characters in X, then toNFC(X) = X.<ul>
      <li dir="ltr">
      <p dir="ltr">The only characters for which this is not true are those in the 
      <span class="section">Section </span><span class="secno">6,</span> <i><a href="tr15-27.html#Primary_Exclusion_List_Table">Composition Exclusion Table</a></i>.</li>
    </ul>
    </li>
    <li>Irrelevant combining marks should not affect the results of composition. See example <b>f</b> 
    in <span class="section">Section</span> <span class="secno">7,</span><i> <a href="tr15-27.html#Examples">Examples and Charts</a>,</i> where the <i>horn</i> 
    character does not affect the results of composition.</li>
  </ol>
  <h4>Goal 3: Efficiency</h4>
  <p>The third major design goal for the Normalization Forms is to allow efficient 
  implementations.</p>
  <ol>
    <li>It is possible to implement efficient code for producing the Normalization Forms. In 
    particular, it should be possible to produce Normalization Form C very quickly from strings that 
    are already in Normalization Form C or are in Normalization Form D.<br>

	</li>
    <li>Normalization Forms that compose do not have to produce the shortest possible results, because that can be 
    computationally expensive.</li>
  </ol> 	
  <h2 class="section"><a name="Implementation_Notes"></a>9 Implementation Notes</h2>
  <p dir="ltr">There are a number of optimizations that can be made in programs that produce 
  Normalization Form C. Rather than first decomposing the text fully, a quick check can be made on 
  each character. If it is already in the proper precomposed form, then no work has to be done. Only 
  if the current character is combining or in <span class="section">Section </span><span class="secno">6,</span><i>
  <a href="tr15-27.html#Primary_Exclusion_List_Table">Composition Exclusion Table</a></i>, does a slower code 
  path need to be invoked. (This code path will need to look at previous characters, back to the 
  last starter. See <span class="section">Section </span><span class="secno">14,</span> <i>
	<a href="tr15-27.html#Detecting_Normalization_Forms">Detecting Normalization Forms</a></i>, for more 
  information.)</p>
  <p>The majority of the cycles spent in doing composition are spent looking up the appropriate data. 
  The data lookup for Normalization Form C can be very efficiently implemented, because it has 
  to look up only pairs of characters, not arbitrary strings. First a multistage table (also known as <i>
  trie;</i> see <a href="../tr41/tr41-1.html#Unicode">[Unicode]</a> <i>Chapter 5, Implementation Guidelines</i>)
  is used to map a character <i>c</i> to a small integer <i>i</i> in a contiguous range from 
  0 to <i>n.</i> The code for doing this looks like:</p>
  <blockquote>
    <pre>i = data[index[c &gt;&gt; BLOCKSHIFT] + (c &amp; BLOCKMASK)];</pre>
  </blockquote>
  <p>Then a pair of these small integers are simply mapped through a two-dimensional array to get a 
  resulting value. This yields much better performance than a general-purpose string lookup in a 
  hash table.</p>
  <p>Because the Hangul compositions and decompositions are algorithmic, memory 
	storage can be significantly reduced if the corresponding operations are 
	done in code. See <span class="section">Section </span><span class="secno">16,</span><i>
  <a href="tr15-27.html#Hangul">Hangul</a></i>, for more information.</p>
  <blockquote>
    <p><span class="note">Note:</span> Any such optimizations must be carefully checked to ensure that they still 
    produce conformant results. In particular, the code must still be able to pass the test 
    described in <span class="section">Section</span> <span class="secno">15,</span> <i> <a href="tr15-27.html#Conformance_Testing">Conformance Testing</a>.</i></p>
  </blockquote>
  <p>For more information on useful implementation techniques, see 
	<span class="section">Section</span> <span class="secno">14,</span><i>
	<a href="tr15-27.html#Detecting_Normalization_Forms">Detecting Normalization Forms</a>,</i> and [<a href="../tr41/tr41-1.html#UTN5">UTN5</a>].</p>
  <h2 class="section"><a name="Decomposition"></a>10 Decomposition</h2>
  <p>For those reading this annex online, the following 
  summarizes the canonical decomposition process. For a complete discussion, see <i>
	Sections 3.7, Decomposition </i>, and<i> 3.11, Canonical Ordering Behavior</i> [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>].</p>
  <p><i>Canonical decomposition</i> is the process of taking a string, 
	recursively replacing composite characters using the Unicode canonical 
	decomposition mappings (including the algorithmic Hangul canonical 
	decomposition mappings; see <span class="section">Section </span><span class="secno">16,</span><i> <a href="tr15-27.html#Hangul">Hangul</a></i>), 
  and putting the result in canonical order.</p>
  <p><i>Compatibility decomposition</i> is the process of taking a string, replacing composite 
  characters using <i>both</i> the Unicode canonical decomposition mappings <i>and</i> the Unicode 
  compatibility decomposition mappings, and putting the result in canonical order.</p> 	
  <p>A string is put into <i>canonical order</i> by repeatedly replacing any exchangeable pair by 
  the pair in reversed order. When there are no remaining exchangeable pairs, then the string is in 
  canonical order. Note that the replacements can be done in any order.</p>
  <p>A sequence of two adjacent characters in a string is an <i>exchangeable pair</i> if the 
  combining class (from the Unicode Character Database) for the first character is greater than the 
  combining class for the second, and the second is not a starter; that is, if <code>
  combiningClass(first) &gt; combiningClass(second) &gt; 0</code>. See <i>Table 
	9.</i></p>
  <p class="caption">Table 9. <span style="font-weight: 400">Examples of Exchangeable Pairs</span></p>
  <div class="center">
  <center>
    <table border="1" cellspacing="2" cellpadding="2">
      <tr>
        <th>Sequence</th>
        <th>Combining Classes</th>
        <th>Status</th>
      </tr>
      <tr>
        <td>&lt;acute, cedilla&gt;</td>
        <td>230, 202</td>
        <td>exchangeable, because 230 &gt; 202</td>
      </tr>
      <tr>
        <td>&lt;a, acute&gt;</td>
        <td>0, 230</td>
        <td>not exchangeable, because 0 &lt;= 230</td>
      </tr>
      <tr>
        <td>&lt;diaeresis, acute&gt;</td>
        <td>230, 230</td>
        <td>not exchangeable, because 230 &lt;= 230</td>
      </tr>
      <tr>
        <td>&lt;acute, a&gt;</td>
        <td>230, 0</td>
        <td>not exchangeable, because the second class is zero</td>
      </tr>
    </table>
  </center>
  </div>
  <p><b><i>Example of Decomposition. </i></b>The following three steps 
	demonstrate the decomposition process for an example string containing the characters “ác´¸”
	<i>(a-acute, c, acute, cedilla).</i></p>
	<ol>
		<li>The data file contains the following relevant information:<br><i>code; name; ... combining class; ... decomposition.</i>
		<pre>0061;LATIN SMALL LETTER A;...0;...
0063;LATIN SMALL LETTER C;...0;...
00E1;LATIN SMALL LETTER A WITH ACUTE;...0;...0061 0301;...
0107;LATIN SMALL LETTER C WITH ACUTE;...0;...0063 0301;...
0301;COMBINING ACUTE ACCENT;...230;...
0327;COMBINING CEDILLA;...202;...</pre></li>
		<li>Applying the canonical decomposition mappings results in “a´c´¸” <i>(a, acute, c, acute, 
      cedilla).</i>
		<ul>
			<li>This is because <tt>00E1</tt> <i>(a-acute)</i> has a canonical decomposition mapping to
        	<tt>0061 0301</tt> <i>(a, acute)</i></li>
		</ul></li>
		<li>Applying the canonical ordering results in “a´c¸´” <i>(a, acute, c, cedilla, acute).</i>
		<ul>
			<li>This is because <i>cedilla</i> has a lower combining class (202) than acute (230) does. 
        The positions of &#39;a&#39; and &#39;c&#39; are not affected, because they are starters.</li>
		</ul></li>
	</ol>
  <h2 class="section"><a name="Code_Sample"></a>11 Code Sample</h2>
  <p>A code sample is available for each of the four Normalization Forms. For clarity, this sample 
  is not optimized. The implementations for NFKC and NFC transform a string in two passes: pass 1 
  decomposes, while pass 2 composes by successively composing each unblocked character with the last 
  starter.</p>
  <p>In some implementations, people may be working with streaming interfaces that read and write 
  small amounts at a time. In those implementations, the text back to the last starter needs to be 
  buffered. Whenever a second starter would be added to that buffer, the buffer can be flushed.</p>
  <p>The sample is written in Java, although for accessibility it avoids the use of object-oriented 
  techniques. For access to the code and for a live demonstration, see
  <a href="Normalizer.html">Normalizer.html</a> [<a href="../tr41/tr41-1.html#Sample">Sample</a>]. 
  Equivalent Perl code is available on the W3C site [<a href="../tr41/tr41-1.html#CharLint">CharLint</a>].</p>
  <h2 class="section"><a name="Legacy_Encodings"></a>12 Legacy Encodings</h2>
  <p>While the Normalization Forms are specified for Unicode text, they can also be extended to 
  non-Unicode (legacy) character encodings. This is based on mapping the legacy character set 
  strings to and from Unicode using definitions <a href="tr15-27.html#D5">D5</a> and <a href="tr15-27.html#D6">D6</a>.</p>
  <p><a name="D5"></a><b>D5.</b> An <i>invertible transcoding</i> T for a legacy character set L is 
  a one-to-one mapping from characters encoded in L to characters in Unicode with an associated 
  mapping T<sup>-1</sup> such that for any string S in L, T<sup>-1</sup>(T(S))&nbsp;=&nbsp;S.</p>
  <p>Most legacy character sets have a single invertible transcoding
  in common use. In a few cases there may be multiple invertible transcodings. For example, 
  Shift-JIS may have two different mappings used in different circumstances: one to preserve the &#39;/&#39; 
  semantics of 5C<sub>16</sub>, and one to preserve the &#39;¥&#39; semantics.</p>
  <p>The character indexes in the legacy character set string may be different from
  character indexes in the Unicode equivalent. For example, if a legacy string uses visual encoding 
  for Hebrew, then its first character might be the last character in the Unicode string.</p>
  <p>If transcoders are implemented for legacy character sets, it is recommended that the result be 
  in Normalization Form C where possible. See Unicode Technical 
  Report #22, “<a href="../tr22/index.html">Character Mapping Tables</a>,” for more information.</p>
  <p><a name="D6"></a><b>D6.</b> Given a string S encoded in L and an invertible transcoding T for 
  L, the <i>Normalization Form X of S under T</i> is defined to be the result of mapping to Unicode, 
  normalizing to Unicode Normalization Form X, and mapping back to the legacy character encoding—for example,&nbsp;T<sup>-1</sup>(NFX(T(S))). Where there is a single invertible 
  transcoding for that character set in common use, one can simply speak of the 
  Normalization Form X of S.</p>
  <p>Legacy character sets are classified into three categories based on their normalization behavior with 
  accepted transcoders.</p>
  <ol>
	<li><i>Prenormalized.</i> Any string in the character set is already in Normalization Form X.
    <ul>
		<li>For example, ISO 8859-1 is prenormalized in NFC.</li>
	</ul></li>
	<li><i>Normalizable.</i> Although the set is not prenormalized, any string in the set
	<i>can</i> 
    be normalized to Normalization Form X.
    <ul>
		<li>For example, ISO 2022 (with a mixture of ISO 5426 and ISO 8859-1) is normalizable.</li>
	</ul></li>
	<li><i>Unnormalizable.</i> Some strings in the character set cannot be normalized into 
	Normalization Form X.
    <ul>
		<li>For example, ISO 5426 is unnormalizable in NFC under common transcoders, because it 
      contains combining marks but not composites.</li>
	</ul></li>
	</ol>
  <h2 class="section"><a name="Programming_Language_Identifiers"></a>13 Programming Language Identifiers</h2>
  <p>This section has been moved to Unicode Standard Annex #31, “Identifier and 
	Pattern Syntax” [<a href="../tr41/tr41-1.html#UAX31">UAX 31</a>].</p>
  <h2 class="section"><a name="Annex8"></a>14 <a name="Detecting_Normalization_Forms">Detecting 
  Normalization Forms</a></h2>
  <p>The Unicode Character Database supplies properties that allow implementations to quickly 
  determine whether a string x is in a particular Normalization Form—for example, isNFC(x). This is, in general, many times faster than normalizing and then comparing.</p>
  <p>For each Normalization Form, the properties provide three possible values for each Unicode code 
  point, as shown in <i>Table 10</i>.</p>
  <div class="center">
  <center>
  <p class="caption">Table 10. <span style="font-weight: 400">Description of Quick_Check Values</span></p>
  <table border="1" cellspacing="0" cellpadding="4">
    <tr>
      <th>Valuee</th>
      <th>Description</th>
    </tr>
    <tr>
      <th height="26">NO</th>
      <td height="26">The code point cannot occur in that Normalization Form.</td>
    </tr>
    <tr>
      <th>YES</th>
      <td>The code point is a starter 
		and can occur in the Normalization Form.
		In addition, for NFKC and NFC, 
		the character may compose with a following character, but it <i>never</i> 
		composes with a previous character.</td>
    </tr>
    <tr>
      <th>MAYBE</th>
      <td>The code point can occur, subject to canonical ordering, but with 
		constraints. In particular, the text may not be in the specified 
		Normalization Form depending on 
		the context in which the character occurs.</td>
    </tr>
  </table>
   </center>
  </div>
 <p>Code that uses this property can do a <i>very</i> fast first pass over a string to determine 
  the Normalization Form. The result is also either NO, YES, or MAYBE. For NO or YES, the answer is 
  definite. In the MAYBE case, a more thorough check must be made, typically by putting a copy of 
  the string into the Normalization Form and checking for equality with the original.</p>
  <ul>
    <li>Even the slow case can be optimized, with a function that does not perform a complete 
    normalization of the entire string, but instead works incrementally, only normalizing a limited 
    area around the MAYBE character. See <span class="section">Section </span><span class="secno">14.1,<i> </i></span>
	<i><a href="tr15-27.html#Stable_Code_Points">Stable Code Points</a></i>.</li>
  </ul>
  <p>This check is much faster than simply running the normalization algorithm, because it avoids 
  any memory allocation and copying. The vast majority of strings will return a definitive YES or NO 
  answer, leaving only a small percentage that require more work. The sample below is written in 
  Java, although for accessibility it avoids the use of object-oriented techniques.</p>
  <pre>public int quickCheck(String source) {
    short lastCanonicalClass = 0;
    int result = YES;
    for (int i = 0; i &lt; source.length(); ++i) {
        char ch = source.charAt(i);
        short canonicalClass = getCanonicalClass(ch);
        if (lastCanonicalClass &gt; canonicalClass &amp;&amp; canonicalClass != 0) {
            return NO;        }
        int check = isAllowed(ch);
        if (check == NO) return NO;
        if (check == MAYBE) result = MAYBE;
        lastCanonicalClass = canonicalClass;
    }
    return result;
}
<br>public static final int NO = 0, YES = 1, MAYBE = -1;</pre>
  <p>The <code>isAllowed()</code> call should access the data from Derived Normalization Properties 
  file [<a href="../tr41/tr41-1.html#NormProps">NormProps</a>] for the 
	Normalization Form in question.&nbsp; (For more 
  information, see the UCD documentation [<a href="../tr41/tr41-1.html#UCDDoc">UCDDoc</a>].) For example, here is a 
  segment of the data for NFC:</p>
  <pre>...

0338       ; NFC_MAYBE # Mn     COMBINING LONG SOLIDUS OVERLAY

...

F900..FA0D ; NFC_NO    # Lo [270] CJK COMPATIBILITY IDEOGRAPH-F900..CJK COMPATIBILITY IDEOGRAPH-FA0D

...</pre>
  <p>These lines assign the value NFC_MAYBE to the code point U+0338, and the value NFC_NO to the 
  code points in the range U+F900..U+FA0D. There are no MAYBE values for NFD and NFKD: 
  the <code>quickCheck</code> function will always produce a definite result for these 
	Normalization Forms. All characters that are not specifically mentioned in the file have the values YES.</p>
  <p>The data for the implementation of the <code>isAllowed()</code> call can be accessed in memory 
  with a hash table or a trie (see <span class="section">Section </span>
	<span class="secno">9,</span> 
  <a href="tr15-27.html#Implementation_Notes"><i>Implementation Notes</i></a>); the latter will be the fastest.</p>
	<p>There is also a Unicode 
	Consortium stability policy that canonical mappings are always limited in 
	all versions of Unicode, so that no string when decomposed with NFD expands 
	to more than 3× in length (measured in code units). This is true whether the 
	text is in UTF-8, UTF-16, or UTF-32. This guarantee also allows for certain 
	optimizations in processing, especially in determining buffer sizes. See 
	also<span class="section"><i> </i>Section</span> <span class="secno">21,</span>
	<a href="tr15-27.html#Stream_Safe_Text_Format"><i>Stream-Safe Text Format</i></a>.</p>
  <h3 class="section">14.1 <a name="Stable_Code_Points">Stable Code Points</a></h3>
  <p>It is sometimes useful to distinguish the set of code points that are <i>stable</i> under a 
  particular Normalization Form. They are the set of code points never affected by that particular 
  normalization process. This property is very useful for skipping over text that does not need to 
  be considered at all, either when normalizing or when testing normalization.</p>
	<p>Formally, each stable 
  code point CP fulfills <i>all</i> of the following conditions:</p>
  <ol>
    <li>CP has canonical combining class 0.</li>
    <li>CP is (as a single character) not changed by this Normalization Form.</li>
  </ol>
	<p>In case of NFC or NFKC, each stable code point CP fulfills <i>all</i> of the following 
	additional conditions:</p>
	<ol start="3">
    <li>CP can never compose with a previous character.</li>
	<li>CP can never compose with a following character.</li>
	<li>CP can never change if another character is added.</li>
  </ol>
  <p><i><b>Example.</b></i> In NFC, <i>a-breve</i> satisfies all but (5), but if one adds an
	<i>ogonek</i> it 
  changes to <i>a-ogonek</i> plus<i> breve</i>. So <i>a-breve</i> is not stable in NFC. However, <i>a-ogonek</i> 
  is stable in NFC, because it does satisfy (1–5).</p>
	<p>Concatenation of normalized 
	strings to produce a normalized result can be optimized using stable code 
	points. An implementation can find the last stable code point L in the first 
	string, and the first stable code point F in the second string. The 
	implementation has to normalize only the range from (and including) L to the 
	last code point before F. The result will then be normalized. This can be a 
	very significant savings in performance when concatenating large strings.</p>
	<p>Because characters with the 
	Quick_Check=YES property value satisfy conditions 1–3, the optimization can 
	also be performed using the Quick_Check property. In this case, the 
	implementation finds the last code point L with Quick_Check=YES in the first 
	string and the first code point F with Quick_Check=YES in the second string. 
	It then normalizes the range of code points starting from (and including) L to the code point 
	just before F.</p>
  <h2 class="section"><a name="Conformance_Testing"></a>15 Conformance Testing</h2>
  <p>Implementations must be thoroughly tested for conformance to the normalization specification.
  The Normalization Conformance Test [<a href="../tr41/tr41-1.html#Tests15">Test15</a>] file is available for 
  testing conformance. This file consists of a series of fields. When 
	Normalization Forms are 
  applied to the different fields, the results shall be as specified in the header of that file.</p>
  <h2 class="section"><a name="Hangul"></a>16 Hangul</h2>
  <p>Because the Hangul compositions and decompositions are algorithmic, memory storage can be 
  significantly reduced if the corresponding operations are done in code rather than by simply 
  storing the data in the general-purpose tables. Here is sample code illustrating algorithmic 
  Hangul canonical decomposition and composition done according to the specification in <i>Section 
  3.12, Combining Jamo Behavior </i> [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]. Although coded in Java, the 
  same structure can be used in other programming languages.</p>
  <p>The canonical Hangul decompositions specified here and in <i>Section 3.12, Combining Jamo 
  Behavior</i>, in [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>] directly decompose precomposed Hangul 
  syllable characters into two or three Hangul Jamo characters. This differs from all other 
  canonical decompositions in two ways. First, they are arithmetically specified. 
	Second, they directly map to more than two characters. The canonical decomposition <i>mapping</i> for 
  all other characters maps each character to one or two others. A character may have a canonical <i>
  decomposition</i> to more than two characters, but it is expressed as the recursive application of 
  mappings to at most a pair of characters at a time.</p>
  <p>Hangul decomposition could also be expressed this way. All LVT syllables decompose into 
  an LV syllable plus a T jamo. The LV syllables themselves decompose into an L jamo plus a T jamo. 
  Thus the Hangul canonical decompositions are fundamentally the same as the other canonical 
  decompositions in terms of the way they decompose. This analysis can also be used to produce more 
  compact code than what is given below.</p> 	<div class="book-only"><p>&nbsp;</p>
		</div>
  <h4><a name="common_constants">Common Constants</a></h4>
  <pre>    static final int
        SBase = 0xAC00, LBase = 0x1100, VBase = 0x1161, TBase = 0x11A7,
        LCount = 19, VCount = 21, TCount = 28,
        NCount = VCount * TCount,   // 588
        SCount = LCount * NCount;   // 11172</pre>
  <h4><a name="hangul_decomposition">Hangul Decomposition</a></h4>
  <pre>    public static String decomposeHangul(char s) {
        int SIndex = s - SBase;
        if (SIndex &lt; 0 || SIndex &gt;= SCount) {
            return String.valueOf(s);
        }
        StringBuffer result = new StringBuffer();
        int L = LBase + SIndex / NCount;
        int V = VBase + (SIndex % NCount) / TCount;
        int T = TBase + SIndex % TCount;
        result.append((char)L);
        result.append((char)V);
        if (T != TBase) result.append((char)T);
        return result.toString();
    }</pre>
  <h4><a name="hangul_composition">Hangul Composition</a></h4>
  <p>Notice an important feature of Hangul composition: whenever the source string is not in 
  Normalization Form D, one cannot just detect character sequences of the form &lt;L,&nbsp;V&gt; and 
  &lt;L,&nbsp;V,&nbsp;T&gt;. It is also necessary to catch the sequences of the form &lt;LV,&nbsp;T&gt;. To 
  guarantee uniqueness, these sequences must also be composed. This is illustrated in 
	step 2.</p>
  <pre>    public static String composeHangul(String source) {
        int len = source.length();
        if (len == 0) return &quot;&quot;;
        StringBuffer result = new StringBuffer();
        char last = source.charAt(0);            <span class="comment">// copy first char</span>
        result.append(last);

        for (int i = 1; i &lt; len; ++i) {
            char ch = source.charAt(i);

            <span class="comment">// 1. check to see if two current characters are L and V</span>

            int LIndex = last - LBase;
            if (0 &lt;= LIndex &amp;&amp; LIndex &lt; LCount) {
                int VIndex = ch - VBase;
                if (0 &lt;= VIndex &amp;&amp; VIndex &lt; VCount) {

                    <span class="comment">// make syllable of form LV</span>

                    last = (char)(SBase + (LIndex * VCount + VIndex) * TCount);

<span class="comment">                    </span>result.setCharAt(result.length()-1, last); <span class="comment">// reset last</span>
                    continue; <span class="comment">// discard ch</span>
                }
            }


            <span class="comment">// 2. check to see if two current characters are LV and T</span>

            int SIndex = last - SBase;
            if (0 &lt;= SIndex &amp;&amp; SIndex &lt; SCount &amp;&amp; (SIndex % TCount) == 0) {
                int TIndex = ch - TBase;
                if (0 &lt; TIndex &amp;&amp; TIndex &lt; TCount) {

                    <span class="comment">// make syllable of form LVT</span>

                    last += TIndex;
                    result.setCharAt(result.length()-1, last); <span class="comment">// reset last</span>
                    continue; <span class="comment">// discard ch</span>
                }
            }
            <span class="comment">// if neither case was true, just add the character</span>
            last = ch;
            result.append(ch);
        }
        return result.toString();
    }</pre>
  <p>Additional transformations can be performed on sequences of Hangul jamo for various purposes. 
  For example, to regularize sequences of Hangul jamo into standard syllables, the <i>choseong</i> 
  and <i>jungseong</i> fillers can be inserted, as described in <span style="; font-style:italic">
  Chapter 3, Conformance</span>, of <a href="../tr41/tr41-1.html#Unicode">[Unicode]</a>. 
  For keyboard input, additional compositions may be performed. For example, the trailing consonants 
  k<font size="-1"><sub>f</sub></font> + s<font size="-1"><sub>f</sub></font> may be combined into 
  ks<font size="-1"><sub>f</sub></font>. In addition, some Hangul input methods do not require a 
  distinction on input between initial and final consonants, and change between them on the basis of 
  context. For example, in the keyboard sequence m<sub>i</sub> + e<sub>m</sub> + n<sub>i</sub> + s<sub>i</sub> 
  + a<sub>m</sub>, the consonant n<sub>i</sub> would be reinterpreted as n<sub>f</sub>, because 
  there is no possible syllable <i>nsa</i>. This results in the two syllables <i>men</i> and <i>sa.</i></p>
  <p>However, none of these additional transformations are considered part of the Unicode 
  Normalization Forms.</p>
  <h4><a name="hangul_character_names">Hangul Character Names</a></h4>
  <p>Hangul decomposition is also used to form the character names for the Hangul syllables. While 
  the sample code that illustrates this process is not directly related to normalization, it is 
  worth including because it is so similar to the decomposition code.</p>
  <pre>    public static String getHangulName(char s) {
        int SIndex = s - SBase;
        if (0 &gt; SIndex || SIndex &gt;= SCount) {
            throw new IllegalArgumentException(&quot;Not a Hangul Syllable: &quot; + s);
        }
        StringBuffer result = new StringBuffer();
        int LIndex = SIndex / NCount;
        int VIndex = (SIndex % NCount) / TCount;
        int TIndex = SIndex % TCount;
        return &quot;HANGUL SYLLABLE &quot; + JAMO_L_TABLE[LIndex]
          + JAMO_V_TABLE[VIndex] + JAMO_T_TABLE[TIndex];
    }

    static private String[] JAMO_L_TABLE = {
        &quot;G&quot;, &quot;GG&quot;, &quot;N&quot;, &quot;D&quot;, &quot;DD&quot;, &quot;R&quot;, &quot;M&quot;, &quot;B&quot;, &quot;BB&quot;,
        &quot;S&quot;, &quot;SS&quot;, &quot;&quot;, &quot;J&quot;, &quot;JJ&quot;, &quot;C&quot;, &quot;K&quot;, &quot;T&quot;, &quot;P&quot;, &quot;H&quot;
    };

    static private String[] JAMO_V_TABLE = {
        &quot;A&quot;, &quot;AE&quot;, &quot;YA&quot;, &quot;YAE&quot;, &quot;EO&quot;, &quot;E&quot;, &quot;YEO&quot;, &quot;YE&quot;, &quot;O&quot;,
        &quot;WA&quot;, &quot;WAE&quot;, &quot;OE&quot;, &quot;YO&quot;, &quot;U&quot;, &quot;WEO&quot;, &quot;WE&quot;, &quot;WI&quot;,
        &quot;YU&quot;, &quot;EU&quot;, &quot;YI&quot;, &quot;I&quot;
    };

    static private String[] JAMO_T_TABLE = {
        &quot;&quot;, &quot;G&quot;, &quot;GG&quot;, &quot;GS&quot;, &quot;N&quot;, &quot;NJ&quot;, &quot;NH&quot;, &quot;D&quot;, &quot;L&quot;, &quot;LG&quot;, &quot;LM&quot;,
        &quot;LB&quot;, &quot;LS&quot;, &quot;LT&quot;, &quot;LP&quot;, &quot;LH&quot;, &quot;M&quot;, &quot;B&quot;, &quot;BS&quot;,
        &quot;S&quot;, &quot;SS&quot;, &quot;NG&quot;, &quot;J&quot;, &quot;C&quot;, &quot;K&quot;, &quot;T&quot;, &quot;P&quot;, &quot;H&quot;
    };</pre>
  <h2 class="section"><a name="Intellectual_Property_Annex"></a>17 Intellectual Property</h2>
  <blockquote>
    <p align="center"><i>Transcript of letter regarding disclosure of IBM Technology<br>
    (Hard copy is on file with the Chair of UTC and the Chair of NCITS/L2)<br>
    Transcribed on 1999-03-10</i></p>
    <p><i>February 26, 1999</i></p>
    <p>&nbsp;</p>
    <p><i>The Chair, Unicode Technical Committee</i></p>
    <p><i>Subject: Disclosure of IBM Technology - Unicode Normalization Forms</i></p>
    <p><i>The attached document entitled “Unicode Normalization Forms” does not require IBM 
    technology, but may be implemented using IBM technology that has been filed for US Patent. 
    However, IBM believes that the technology could be beneficial to the software community at 
    large, especially with respect to usage on the Internet, allowing the community to derive the 
    enormous benefits provided by Unicode.</i></p>
    <p><i>This letter is to inform you that IBM is pleased to make the Unicode normalization 
    technology that has been filed for patent freely available to anyone using them in implementing 
    to the Unicode standard.</i></p>
    <p><i>Sincerely,</i></p>
    <p><i>&nbsp;</i></p>
    <p><i>W. J. Sullivan,<br>
    Acting Director of National Language Support<br>
    and Information Development</i></p>
    <p>&nbsp;</p>
  </blockquote>
  <h2 class="section"><a name="Corrigenda">18 Corrigenda</a></h2>
  <p>The Unicode Consortium has well-defined policies in place to govern changes that affect 
  backward compatibility. For information on these stability policies, especially regarding 
  normalization, see <a href="http://www.unicode.org/policies/">Unicode Policies</a> [<a href="../tr41/tr41-1.html#Policies">Policies</a>]. 
  In particular: </p>
  <blockquote>
    <p><i>Once a character is encoded, its canonical combining class and decomposition mapping will 
    not be changed in a way that will destabilize normalization.</i></p>
  </blockquote>
  <p>What this means is:</p>
  <blockquote>
    <p><i>If a string contains only characters from a given version of the Unicode Standard (for 
    example, Unicode 3.1.1), and it is put into a normalized form in accordance with that 
    version of Unicode, then it will be in normalized form according to any future version 
    of Unicode.</i></p>
  </blockquote>
  <p>This guarantee has been in place for Unicode 3.1 and after. It has been necessary to correct 
  the decompositions of a small number of characters since Unicode 3.1, as listed in the 
  Normalization Corrections data file [<a href="../tr41/tr41-1.html#Corrections">Corrections</a>], but such corrections 
  are in accordance with the above principles: all text normalized on old systems will test as 
  normalized in future systems. All text normalized in future systems will test as normalized on 
  past systems. What may change, for those few characters, is that <i>unnormalized</i> text may 
  normalize differently on past and future systems.</p>
  <p>It is straightforward for any implementation with a future version of Unicode to support all 
  past versions of normalization. For an implementation of Unicode Version X to support a version of 
  NFC that precisely matches a older Unicode Version Y, the following two steps are taken:</p>
  <ol>
    <li>Before applying the normalization algorithm, map the characters that were corrected to their
    <i>old</i> values in Unicode Version Y.
    <ul>
      <li>Use the table in [<a href="../tr41/tr41-1.html#Corrections">Corrections</a>] for this step, by including any 
      code points that have a version later than Y and less than or equal to X.</li>
      <li>For example, for a Unicode 4.0 implementation to duplicate Unicode 3.2 results, exactly 
		five 
      characters must be mapped.</li>
    </ul>
    </li>
    <li>In applying the normalization algorithm, handle any code points that were not defined in 
    Unicode Version X as if they were unassigned.
    <ul>
      <li>That is, the code points will not decompose or compose, and their canonical combining 
      class will be zero.</li>
      <li>The Derived_Age property in the Unicode Character Database [UCD] can be used for the set 
      of code points in question.</li>
    </ul>
    </li>
  </ol>
  <p>[<a href="../tr41/tr41-1.html#Unicode4.1">Unicode4.1</a>]&nbsp; corrected a 
	definitional problem with D2. </p>
  <h2 class="section">19 <a name="Canonical_Equivalence">Canonical Equivalence</a></h2>
  <p>This section describes the relationship of normalization to respecting (or preserving) 
  canonical equivalence. A process (or function) <i>respects</i> canonical equivalence when 
  canonical-equivalent inputs always produce canonical-equivalent outputs. For a function that 
  transforms one string into another, this may also be called <i>preserving</i> canonical 
  equivalence. There are a number of important aspects to this concept:</p>
  <ol>
	<li>The outputs are <i>not</i> required to be identical, only canonically equivalent.</li>
	<li><i>Not</i> all processes are required to respect canonical equivalence. For example:
    <ul>
		<li>A function that collects a set of the General_Category values present in a string will and 
      should produce a different value for &lt;<i>angstrom sign, 
      semicolon&gt;</i> than for &lt;<i>A, combining ring 
      above, greek question mark&gt;</i>, even though they are canonically equivalent.</li>
		<li>A function that does a binary comparison of strings will also find these two sequences 
      different.</li>
	</ul></li>
	<li>Higher-level processes that transform or compare strings, or that perform other higher-level functions, must respect canonical equivalence or problems will result.</li>
	</ol> 	
  <p>The canonically equivalent inputs or outputs are not just limited to strings, but are also 
  relevant to the <i>offsets</i> within strings, because those play a fundamental role in Unicode 
  string processing.</p>
  <blockquote>
    <p>Offset P into string X is canonically equivalent to offset Q into string Y if and only if 
    both of the following conditions are true:</p>
    <ul class="nobullet">
      <li>X[0, P] ≈ Y[0, Q], and</li>
      <li>X[P, len(X)] ≈ Y[Q, len(Y)]</li>
    </ul>
  </blockquote>
  <p>This can be written as P<sub>X</sub> ≈ Q<sub>Y</sub>. Note that whenever X and Y are 
  canonically equivalent, it follows that 0<sub>X</sub> ≈ 0<sub>Y</sub> and len(X)<sub>X</sub> ≈ 
  len(Y)<sub>Y</sub>.</p>
  <p><i><b>Example 1.</b></i> Given X = &lt;<i>angstrom sign, semicolon&gt;</i> and Y = &lt;<i>A, 
    combining ring above, greek question mark</i><i>&gt;</i>,
    </p>
	<ul class="nobullet">
		<li>0<sub>X</sub> ≈ 0<sub>Y</sub></li>
		<li>1<sub>X</sub> ≈ 2<sub>Y</sub></li>
		<li>2<sub>X</sub> ≈ 3<sub>Y</sub></li>
		<li>1<sub>Y</sub> has no canonically equivalent offset in X</li>
	</ul>
	<p>The following are examples of processes that involve canonically equivalent strings 
	<i>and/or</i> 
  offsets.</p>
	<p><i><b>Example 2.</b></i> When <code>isWordBreak(string, offset)</code> respects canonical equivalence, then
    </p>
	<ul class="nobullet">
		<li><code>isWordBreak(</code>&lt;<i>A-ring, semicolon</i>&gt;, 1<code>)</code> = 
		<code>isWordBreak(</code>&lt;<i>A, 
      ring, semicolon</i>&gt;, 2<code>)</code></li>
	</ul>
	<p><i><b>Example 3.</b></i> When <code>nextWordBreak(string, offset)</code> respects canonical equivalence, then
    </p>
	<ul class="nobullet">
		<li><code>nextWordBreak(</code>&lt;<i>A-ring, semicolon</i>&gt;, 0<code>)</code> = 1 if and only if
      	<code>nextWordBreak(</code>&lt;<i>A, ring, semicolon</i>&gt;, 0<code>)</code> 
		= 2</li>
	</ul>
  <p>Respecting canonical equivalence is related to, but different from, 
	preserving a canonical Normalization Form NFx (where NFx means either NFD or 
	NFC). In a process that preserves a Normalization Form, whenever any input 
	string is normalized according to that Normalization Form, then every output 
	string is also normalized according to that form. A process that preserves a 
	canonical Normalization Form respects canonical equivalence, but the reverse 
	is not necessarily true.</p>
  <p>In building a system that as a whole respects canonical equivalence, there 
	are two basic strategies, with some variations on the second strategy.</p>
  <ol type="A">
    <li>Ensure that each system component respects canonical equivalence.</li>
    <li>Ensure that each system component preserves NFx, and one of the following:
    <ol>
      <li>Reject any non-NFx text on input to the whole system.</li>
      <li>Reject any non-NFx text on input to each component.</li>
      <li>Normalize to NFx all text on input to the whole system.</li>
      <li>Normalize to NFx all text on input to each component.</li>
      <li>All three of the following:
      <ol type="a">
        <li>Allow text to be marked as NFx when generated.</li>
        <li>Normalize any unmarked text on input to each component to NFx.</li>
        <li>Reject any marked text that is not NFx.</li>
      </ol>
      </li>
    </ol>
    </li>
  </ol>
  <p>There are trade-offs for each of these strategies. The best choice or mixture of strategies 
  will depend on the structure of the components and their interrelations, and how fine-grained or 
  low-level those components are. One key piece of information is that it is much faster to check 
  that text is NFx than it is to convert it. This is especially true in the case of NFC. So even 
  where it says “normalize” above, a good technique is to first check if normalization is required, 
  and perform the extra processing only if necessary.</p>
  <ul>
    <li>Strategy A is the most robust, but may be less efficient.</li>
    <li>Strategies B1 and B2 are the most efficient, but would reject some data, including that 
    converted 1:1 from some legacy code pages.</li>
    <li>Strategy B3 does not have the problem of rejecting data. It can be more efficient than A: 
    because each component is assured that all of its input is in a particular 
	Normalization Form, 
    it does not need to normalize, except internally. But it is less robust: any component that 
    fails can “leak” unnormalized text into the rest of the system.</li>
    <li>Strategy B4 is more robust than B1 but less efficient, because there are multiple points 
    where text needs to be checked.</li>
    <li>Strategy B5 can be a reasonable compromise; it is robust but allows for all text input.</li>
  </ul>
  <h2 class="section">20 <a name="Corrigendum_5_Sequences">Corrigendum 5 
  Sequences</a></h2>
  <p><i>Table 11</i> shows all of the problem sequences relevant to Corrigendum 5. <i>It is important to emphasize that none of these sequences will occur in any 
  meaningful text, because none of the intervening characters shown in the sequences occur in the 
  contexts shown in the table.</i></p>
	<div class="book-only"><p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p></div>

  <div class="center">
  <center>
     <p class="caption">Table 11.<span style="font-weight: 400"> Problem Sequences</span></p>
 <table cellSpacing="0" cellPadding="4" border="1">
    <tr>
      <th align="left" width="38%">First Character
      </th>
      <th align="left" width="15%" nowrap>
      Intervening<br>
		Character(s) </th>
      <th align="left" width="41%">Last Character</th>
    </tr>
    <tr>
      <td>09C7<span class="name"> BENGALI VOWEL SIGN E</span></td>
      <td rowspan="13" style="text-align: center; vertical-align:middle; border-bottom:hidden"><table class="noborder"><tr><td class="noborder">One or more characters 
      with a non-zero
      Canonical Combining Class property value—for example, an acute accent.</td></tr></table></td>
      <td>09BE<span class="name"> BENGALI VOWEL SIGN AA<b> </b></span><b>or</b><span class="name"><br>
      </span>09D7<span class="name"> BENGALI AU LENGTH MARK</span></td>
    </tr>
    <tr>
      <td>0B47<span class="name"> ORIYA VOWEL SIGN E</span></td>
      <td>0B3E<span class="name"> ORIYA VOWEL SIGN AA<b> </b></span><b>or</b><span class="name"><br>
      </span>0B56<span class="name"> ORIYA AI LENGTH MARK<b> </b></span><b>or</b><span class="name"><br>
      </span>0B57<span class="name"> ORIYA AU LENGTH MARK</span></td>
    </tr>
    <tr>
      <td>0BC6<span class="name"> TAMIL VOWEL SIGN E</span></td>
      <td>0BBE<span class="name"> TAMIL VOWEL SIGN AA<b> </b></span><b>or</b><span class="name"><br>
      </span>0BD7<span class="name"> TAMIL AU LENGTH MARK</span></td>
    </tr>
    <tr>
      <td>0BC7<span class="name"> TAMIL VOWEL SIGN EE </span> </td>
      <td>0BBE<span class="name"> TAMIL VOWEL SIGN AA</span></td>
    </tr>
    <tr>
      <td>0B92<span class="name"> TAMIL LETTER O</span></td>
      <td>0BD7<span class="name"> TAMIL AU LENGTH MARK</span></td>
    </tr>
    <tr>
      <td>0CC6<span class="name"> KANNADA VOWEL SIGN E</span></td>
      <td>0CC2<span class="name"> KANNADA VOWEL SIGN UU<b> </b></span><b>or</b><span class="name"><br>
      </span>0CD5<span class="name"> KANNADA LENGTH MARK<b> </b></span><b>or</b><span class="name"><br>
      </span>0CD6<span class="name"> KANNADA AI LENGTH MARK</span></td>
    </tr>
    <tr>
      <td>0CBF<span class="name"> KANNADA VOWEL SIGN I or<br>
      </span>0CCA<span class="name"> KANNADA VOWEL SIGN O</span></td>
      <td>0CD5<span class="name"> KANNADA LENGTH MARK</span></td>
    </tr>
    <tr>
      <td>0D47<span class="name"> MALAYALAM VOWEL SIGN EE</span></td>
      <td>0D3E<span class="name"> MALAYALAM VOWEL SIGN AA</span></td>
    </tr>
    <tr>
      <td>0D46<span class="name"> MALAYALAM VOWEL SIGN E</span></td>
      <td>0D3E<span class="name"> MALAYALAM VOWEL SIGN AA<b> </b></span><b>or</b><span class="name"><br>
      </span>0D57<span class="name"> MALAYALAM AU LENGTH MARK</span></td>
    </tr>
    <tr>
      <td>1025<span class="name"> MYANMAR LETTER U</span></td>
      <td>102E<span class="name"> MYANMAR VOWEL SIGN II</span></td>
    </tr>
    <tr>
      <td>0DD9<span class="name"> SINHALA VOWEL SIGN KOMBUVA</span></td>
      <td>0DCF<span class="name"> SINHALA VOWEL SIGN AELA-PILLA<b> </b></span>
		<b>or</b><span class="name"> </span>0DDF<span class="name"> SINHALA VOWEL SIGN GAYANUKITTA</span></td>
    </tr>
    <tr>
      <td>1100..1112<span class="name"> HANGUL CHOSEONG KIYEOK..HIEUH
		</span>[19 
      instances]</td>
      <td>1161..1175<span class="name"> HANGUL JUNGSEONG A..I </span>[21 instances]</td>
    </tr>
    <tr>
      <td>[:HangulSyllableType=LV:]</td>
      <td>11A8..11C2 <span class="name">HANGUL JONGSEONG KIYEOK..HIEUH </span>[27 
      instances]</td>
    </tr>
  </table>
  </center>
  </div>
  <br>
  <h2 class="section">21 <a name="Stream_Safe_Text_Format">Stream-Safe Text Format</a></h2>
	<p>There are certain protocols that would benefit from using normalization, but 
	that have 
	implementation constraints. For example, a protocol may require buffered serialization, 	
	in which only a portion of a string may be available at a given time. Consider the 
	extreme case of a string containing a <i>
	digit
	2</i> 
	followed by 10,000 <i>umlauts</i> 
	followed by one <i>dot-below</i>, 
	then a <i>digit 3</i>. 
	As part of normalization, the <i>
	dot-below</i> 
	at the end must be reordered to immediately after the <i>
	digit
	2</i>, 
	which means that 10,003 characters need to be considered before 
	the result can be output. </p>
	<p>Such extremely long sequences of combining marks are not illegal, even 
	though for all practical purposes they are not meaningful. However, the 
	possibility of encountering such sequences 
	forces a conformant, serializing implementation to provide large buffer 
	capacity or to provide a special exception mechanism just for such degenerate 
	cases. The Stream-Safe Text Format specification addresses this situation.</p>
	<p><b>D5.</b>  <i>Stream-Safe Text Format:</i>  
	A Unicode string is said to be 
	in Stream-Safe Text Format 
	if it would not contain any sequences of non-starters longer than 30 
	characters in length when normalized to NFKD.</p>
	<ul>
		<li>Such a string can be normalized in buffered serialization with 	
		a buffer size of 32 characters, which would require no more than 128 bytes 
		in any Unicode Encoding Form.</li>
		<li>Incorrect buffer handling can introduce subtle errors in the 
		results. Any buffered implementation should be carefully checked against 
		the normalization test data.</li>
		<li>The value of 30 is chosen to 
		be significantly beyond what is required for any linguistic or technical 
		usage. While it would have been feasible to chose a smaller number, this 
		value provides a very wide margin, yet is well within the buffer size 
		limits of practical implementations.</li>
	</ul>
	<p><b>D6.</b> <i>
	Stream-Safe Text Process</i> is the process of producing a 
	Unicode string in Stream-Safe Text Format by processing that string from 
	start to finish, inserting U+034F <span class="name">COMBINING GRAPHEME 
	JOINER (CGJ)</span> within long sequences of non-starters. 
	The exact position of the inserted CGJs are determined according to the 
	following algorithm, which describes the generation of an output string from 
	an input string:</p>
	<ol>
		<li>If the input string is 
		empty, return an empty output string. </li>
		<li>Set nonStarterCount to zero.
		</li>
		<li>For each code point C in the 
		input string:<ol type="a">
			<li>Produce the NFKD 
			decomposition S.</li>
			<li>If nonStarterCount plus 
			the number of initial non-starters in S is greater than 30, append a 
			CGJ to the output string and set the nonStarterCount to zero.</li>
			<li>Append C to the output 
			string. </li>
			<li>If there are no starters in S, increment nonStarterCount by the 
			number of code points in S; otherwise, set nonStarterCount to the number of trailing non-starters in S (which 
			may be zero). 
			</li>
		</ol>
		</li>
		<li>Return the output string.
		</li>
	</ol>
	<p>The Stream-Safe Text Process ensures not only that the resulting text is in Stream-Safe Text Format, 
		but that any normalization of the result is also in Stream-Safe Text Format. 
		This is true for any input string that does not contain unassigned code 
		points.</p>
	<p>It is important to realize that if the Stream-Safe Text Process modifies 
	the input text by insertion of CGJs, the result will <i>not</i> 
	be canonically equivalent to the original. The Stream-Safe Text Format is designed for use in 
	protocols and systems that accept the limitations on the text imposed by the 	format, 
	just as they may impose their own limitations, such as removing certain control 
	codes.</p>
	<p>Implementations can optimize this specification as long as they produce the same results. In particular, 
	the information used in Step 3 can be precomputed: it does not require the 
	actual normalization of the character. </p>
	<p>The Stream-Safe Text Format 
	will not modify ordinary texts. Where it modifies an exceptional text, the 	resulting string would no 
	longer be canonically equivalent to the original, but the modifications are 
	minor and do not disturb any meaningful content. The modified text contains 
	all of the content of the original, with the only difference being that 
	reordering is blocked across long groups of non-starters. Any text in Stream-Safe Text Format can be normalized with very small buffers 	using any of the standard 
	Normalization Forms.</p>
	<p>For efficient processing, the Stream-Safe Text Process can be 
	implemented in the same implementation pass as normalization. In such a case, the choice of whether to 	apply the 
	Stream-Safe Text Process can be controlled by an input parameter.</p>  
	  <h2 class="nonumber"><a name="Acknowledgments">Acknowledgments</a></h2>  
	  <div class="book-only">
	  <p>Mark Davis and Martin Dürst created the initial versions of this annex. 
		Mark Davis has added to and maintains the text.</p></div>
	<p>Thanks to Kent Karlsson, Marcin Kowalczyk, Rick Kunst, Sadahiro Tomoyuki, Markus   
	  Scherer, Dick Sites, and Ken Whistler for feedback on this annex, 
	including earlier versions. Asmus Freytag extensively reformatted the text 
	for publication as part of the book.</p>  
	<h2 class="nonumber"><a name="References">References</a></h2>
	<p>For references for this annex, see Unicode Standard Annex #41, “<a href="../tr41/tr41-1.html">Common 
	References for Unicode Standard Annexes</a>.”</p>  <h2 class="nonumber"><a name="Modifications">Modifications</a></h2>
    <div class="book-only">
	<p>For details of the change history, see the online copy of this annex at http://www.unicode.org/reports/tr9/.</p></div>
  	<!-- START WEB ONLY -->
	<div class="web-only">
  <p>The following summarizes modifications from previous revisions of this 
	annex.</p>
  <h3>Revision 27</h3>
  <ul>
	<li>Replaced Figure 3 with 4 modified figures, added commentary, renumbered 
	figures</li>
	<li>Changed “document” to “annex” as appropriate</li>
	<li>Changed Annexes to Sections and renumbered</li>
	<li>Clarified the definition and use of the QuickTest property</li>
	<li>Added Section 21, <i> <a href="tr15-27.html#Stream_Safe_Text_Format">Stream-Safe Text 
	Format</a></i></li>
	<li>Added examples of composition exclusions</li>
	<li>Changed C1..C3 to UAX15-C1..UAX15-C1.</li>
	<li>Added clarifications of stability:<ul>
		<li><span class="section">Section </span><span class="secno">3.1,</span><i>
		<a href="tr15-27.html#Stability_of_Normalized_Forms">Stability of Normalized Forms</a></i></li>
		<li><span class="section">Section </span><span class="secno">3.2,</span><i>
		<a href="tr15-27.html#Stability_of_the_Normalization_Process">Stability of the_Normalization Process</a></i></li>
		<li><span class="section">Section </span><span class="secno">3.3,</span><i>
		<a href="tr15-27.html#Guaranteeing_Process_Stability">Guaranteeing Process Stability</a></i></li>
		<li><span class="section">Section </span><span class="secno">20,</span><i>
		<a href="tr15-27.html#Corrigendum_5_Sequences">Corrigendum 5 
      Sequences</a></i></li>
	</ul></li>
	<li>Major reformatting to better follow the style in The Unicode Standard</li>
	<li>Extensive copy-editing and minor editing for clarity</li>
  </ul>
	<p>Revision 26 being a proposed update, only changes between versions 27 and 
	25 are noted here.</p>
  <h3>Revision 25</h3>
  <ul>
    <li>Minor editing</li>
    <li>Added note in Section 18, <i> <a href="tr15-27.html#Corrigenda">Corrigenda</a></i> about PRI #29</li>
    <li>Changed “Tracking Number” to Revision</li>
    <li>Added note that D2 is only to be applied to strings that are already canonically decomposed.</li>
  </ul>
  <h3>Revision 24</h3>
  <ul>
    <li>As per <a href="http://www.unicode.org/review/pr-29.html">PRI-29,</a><ul>
      <li>changed D2 to add “or higher”</li>
      <li>Changed Goal 1 to clarify that it is a conformance requirement.</li>
    </ul>
    </li>
    <li>Added to section 10 to explain Hangul decomposition mappings.</li>
    <li>Numerous editorial changes</li>
  </ul>
  <h3>Revision <a name="TrackingNumber23">23</a></h3>
  <ul>
    <li>Updated <a href="tr15-27.html#References">References</a>.</li>
    <li>Added description of <a href="tr15-27.html#Stable_Code_Points">Stable Code Points</a>.</li>
    <li>Described notation toNFC(x) and isNFC(x), in <a href="tr15-27.html#Notation">Notation</a>.</li>
    <li>Clarified the section on <a href="tr15-27.html#Concatenation">Concatenation</a>.</li>
    <li>Copied reference to charts in the <a href="tr15-27.html#Introduction">Introduction</a>.</li>
    <li>Added pointer to <a href="../../notes/tn5.1">UTN #5 Canonical Equivalences in 
    Applications</a> in <a href="tr15-27.html#Implementation_Notes">Implementation Notes</a>.</li>
    <li>Rewrote Section 18, <i> <a href="tr15-27.html#Corrigenda">Corrigenda</a></i> for clarity, and to describe the use 
    of Normalization Corrections.</li>
    <li>Added Section 19, <a href="tr15-27.html#Canonical_Equivalence">Canonical Equivalence</a>.</li>
    <li>Added <a href="tr15-27.html#Acknowledgments">Acknowledgments</a>.
    <ul>
      <li>Note: this does not include people who contributed feedback to previous versions.</li>
    </ul>
    </li>
    <li>Minor editing</li>
  </ul>
  <h3>Revision <a name="TrackingNumber22">22</a></h3>
  <ul>
    <li>Added reference to <i>Corrigendum #3, “U+F951 Normalization,</i>” changing the title of
    <a href="tr15-27.html#Corrigenda">Section 18</a></li>
    <li>Changed references to Unicode 3.1</li>
    <li>Cleaned up links to versioned files</li>
  </ul>
  </div>
  <div class="web-only">
  <hr width="50%">
  <p class="copyright">Copyright © 1998-2006 Unicode, Inc. All 
  Rights Reserved. The Unicode Consortium makes no expressed or implied warranty of any kind, and 
  assumes no liability for errors or omissions. No liability is assumed for incidental and 
  consequential damages in connection with or arising out of the use of the information or programs 
  contained or accompanying this technical report. The Unicode
  <a href="http://www.unicode.org/copyright.html">Terms of Use</a> apply.</p>
  <p class="copyright">Unicode and the Unicode logo are trademarks of Unicode, Inc., and are 
  registered in some jurisdictions.
  </div> <!-- WEB ONLY -->
  </div> <!-- BODY -->
  </div> <!-- BOOK -->
</body>
</html>