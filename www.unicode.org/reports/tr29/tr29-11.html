<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"

       "http://www.w3.org/TR/REC-html40/loose.dtd"> 

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<title>UAX #29: Text Boundaries</title>
<!-- <link rel="stylesheet" href="http://www.unicode.org/reports/reports.css" type="text/css"> -->

<!-- WEB ONLY -->
<link rel="stylesheet" type="text/css" href="../reports-web.css">
<!-- BOOK ONLY 
<link rel="stylesheet" type="text/css" href="../reports-book.css"> -->

</head>
<body><div class="book"><!-- WEB ONLY--><div class="web-only">
<table class="header" width="100%">
  <tr>
    <td class="icon"><a href="http://www.unicode.org">
    <img align="middle" alt="[Unicode]" border="0" src="../logo60s2.gif" width="34" height="33"></a>&nbsp;&nbsp;<a class="bar" href="../index.html">Technical 
    Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>
</table>
</div>
<!-- END WEB ONLY-->
<div class="body">
  <h2 class="uaxtitle"></h2>
	<h2 class="uaxtitle">Unicode Standard Annex&nbsp;#29</h2>
  <h1>Text Boundaries</h1>
  <!-- START WEB ONLY -->
  <div class="web-only">
  <table class="wide" border="1">
    <tr>
      <td valign="top">Version</td>
      <td valign="top">Unicode 5.0.0</td>
    </tr>
    <tr>
      <td valign="top">Authors</td>
      <td valign="top">Mark Davis (<a href="mailto:mark.davis@google.com">mark.davis@google.com</a>)</td>
    </tr>
    <tr>
      <td valign="top">Date</td>
      <td valign="top">2006-10-12</td>
    </tr>
    <tr>
      <td valign="top">This Version</td>
      <td valign="top">
      <a href="tr29-11.html">
		http://www.unicode.org/reports/tr29/tr29-11.html</a></td>
    </tr>
    <tr>
      <td valign="top">Previous Version</td>
      <td valign="top">
      <a href="tr29-9.html">
      http://www.unicode.org/reports/tr29/tr29-9.html</a></td>
    </tr>
    <tr>
      <td valign="top">Latest Version</td>
      <td valign="top"><a href="../tr29.1">http://www.unicode.org/reports/tr29/</a></td>
    </tr>
    <tr>
      <td valign="top">Revision</td>
      <td valign="top"><a href="tr29-11.html#Modifications">11</a></td>
    </tr>
  </table>
  </div>
  <!-- END WEB ONLY -->
  <h4 class="summary">Summary</h4>
  <p><i>This annex describes guidelines for determining default boundaries between certain 
  significant text elements: grapheme clusters (“user-perceived characters”), words, and sentences. 
  For line break boundaries, see UAX #14, “<a href="../tr14/index.html">Line 
  Breaking Properties</a>.”</i></p>
	<div class="web-only"> 
 <h4 class="status">Status</h4>
  <p><i>This document has been reviewed by Unicode members and other interested 
	parties, and has been approved for publication by the Unicode Consortium. 
	This is a stable document and may be used as reference material or cited as 
	a normative reference by other specifications.</i></p>
  <blockquote>
    <p><i><b>A Unicode Standard Annex (UAX)</b> forms an integral part of the 
	Unicode Standard, but is published online as a separate document. The 
	Unicode Standard may require conformance to normative content in a Unicode 
	Standard Annex, if so specified in the Conformance chapter of that version 
	of the Unicode Standard. The version number of a UAX document corresponds to 
	the version of the Unicode Standard of which it forms a part.</i></p>
  </blockquote>
  <p><i>Please submit corrigenda and other comments with the online reporting form [<a href="../tr41/tr41-1.html#Feedback">Feedback</a>]. 
  Related information that is useful in understanding this annex is found in
  Unicode Standard Annex #41, “<a href="../tr41/tr41-1.html">Common References for Unicode Standard Annexes</a>.” For the latest version of the Unicode Standard, see [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]. 
  For a list of current Unicode Technical Reports, see [<a href="../tr41/tr41-1.html#Reports">Reports</a>]. For more 
  information about versions of the Unicode Standard, see [<a href="../tr41/tr41-1.html#Versions">Versions</a>].</i></p>
  </div>
  <h4 class="contents">Contents</h4>
  <ul class="toc">
    <li>1&nbsp;<a href="tr29-11.html#Introduction">Introduction</a>
    <ul class="toc">
      <li>1.1&nbsp;<a href="tr29-11.html#Notation">Notation</a></li>
    </ul>
    </li>
    <li>2&nbsp;<a href="tr29-11.html#Conformance">Conformance</a></li>
    <li>3&nbsp;<a href="tr29-11.html#Grapheme_Cluster_Boundaries">Grapheme Cluster Boundaries</a><ul class="toc">
    <li>3.1&nbsp; <a href="tr29-11.html#Default_Grapheme_Cluster_Table">Default Grapheme Cluster Boundary Specification</a></li>
    </ul></li>
    <li>4&nbsp;<a href="tr29-11.html#Word_Boundaries">Word Boundaries</a><ul class="toc">
    <li>4.1&nbsp; <a href="tr29-11.html#Default_Word_Boundaries">Default Word Boundary Specification</a></li>
    </ul></li>
    <li>5&nbsp;<a href="tr29-11.html#Sentence_Boundaries">Sentence Boundaries</a><ul class="toc">
    <li>5.1&nbsp; <a href="tr29-11.html#Default_Sentence_Boundaries">Default Sentence Boundary Specification</a></li>
    </ul></li>
    <li>6&nbsp;<a href="tr29-11.html#Implementation_Notes">Implementation Notes</a>
    <ul class="toc">
      <li>6.1&nbsp;<a href="tr29-11.html#Normalization">Normalization</a></li>
      <li>6.2&nbsp;<a href="tr29-11.html#Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a></li>
      <li>6.3&nbsp;<a href="tr29-11.html#Regular_Expressions">Regular Expressions</a></li>
      <li>6.4&nbsp;<a href="tr29-11.html#Random_Access">Random Access</a></li>
      <li>6.5&nbsp;<a href="tr29-11.html#Tailoring">Tailoring</a></li>
    </ul>
    </li>
    <li>7&nbsp;<a href="tr29-11.html#Testing">Testing</a></li>
    <li><a href="tr29-11.html#Acknowledgments">Acknowledgments</a></li>
    <li><a href="tr29-11.html#References">References</a></li>
    <li><a href="tr29-11.html#Modifications">Modifications</a></li>
  </ul>
  <hr>
  <h2 class="section">1 <a name="Introduction">Introduction</a></h2>
  <p>This annex describes guidelines for determining default boundaries between 
	certain significant text elements: grapheme clusters (“user-perceived 
	characters”), words, and sentences. The process of boundary determination is 
	also called <i>segmentation</i>.</p>
  <p>A string of Unicode-encoded text often needs to be broken up into text elements 
  programmatically. Common examples of text elements include what users think of as characters, 
  words, lines (more precisely, where line breaks are allowed), and sentences. The precise 
  determination of text elements may vary according to orthographic conventions for a given script 
  or language. The goal of matching user perceptions cannot always be met exactly because the text 
  alone does not always contain enough information to unambiguously decide boundaries. For example, 
  the <em>period</em> (U+002E <span class="name">FULL STOP</span>) 
	is used ambiguously, sometimes for end-of-sentence purposes, sometimes for 
	abbreviations, and sometimes for numbers. In most cases, however, 
	programmatic text boundaries can match user perceptions quite closely, 
	although sometimes the best that can be done is not to surprise the user. </p>
  <p>Rather than concentrate on algorithmically searching for text elements 
	(often called <i>segments</i>), a simpler 
  and more useful computation instead detects the <i>boundaries</i> (or <i>breaks</i>) 
  between those text elements. The determination of those boundaries is often critical to performance, so it is important to be able to make such a determination as 
  quickly as possible. (For a general discussion of text elements, see <i>Chapter 
	2, General Structure</i>, of [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>].)</p>
  <p>The default boundary determination mechanism specified in this annex provides a 
  straightforward and efficient way to determine some of the most significant boundaries in text: 
  grapheme clusters (what end users usually think of as characters), words, and sentences. 
	Boundaries used in line breaking (also called word wrapping) are to be found in 
	[<a href="../tr41/tr41-1.html#LineBreak">LineBreak</a>].</p>
  <p>The sheer number of characters in the Unicode Standard, together with 
	its representational power, place 
  requirements on both the specification of text element boundaries and the underlying 
  implementation. The specification needs to allow for the designation of large sets of characters 
  sharing the same characteristics (for example, uppercase letters), while the implementation must 
  provide quick access and matches to those large sets. The mechanism also must handle special 
  features of the Unicode Standard, such as nonspacing marks and conjoining jamo.</p>
  <p>The default boundary determination builds upon the uniform character representation of the 
  Unicode Standard, while handling the large number of characters and special features such as 
  nonspacing marks and conjoining jamo in an effective manner. As this mechanism lends itself to a 
  completely data-driven implementation, it can be tailored to particular orthographic conventions 
  or user preferences without recoding.</p>
  <p>As in other Unicode algorithms, these specifications provide a <i>logical</i> description of the 
  processes: implementations can achieve the same results without using code or data that follows 
  these rules step-by-step. In particular, many production-grade implementations will use a 
  state-table approach. In that case, the performance does not depend on the complexity or number of 
  rules. Rather, the only feature affecting performance is the number of characters that may match <i>
  after</i> the boundary position in a rule that applies. </p>
  <h3 class="section">1.1 <a name="Notation">Notation</a></h3>
  <p>A boundary specification summarizes boundary property values used in that 
	specification, then lists the rules for boundary determinations in terms of 
	those property values. The summary is provided as a list, where each element 
	of the list is one of the following:</p>
  <ul>
    <li>A literal character</li>
    <li>A range of literal characters</li>
    <li>All characters satisfying a given condition, using properties defined in the Unicode 
    Character Database [<a href="../tr41/tr41-1.html#UCD">UCD</a>]:
    <ul style="list-style-type:none">
      <li>Non-Boolean property values are given as <i>&lt;property&gt;=&lt;property value&gt;</i>, such as 
      General_Category = Titlecase_Letter.</li>
      <li>Boolean properties are given as <i>&lt;property&gt;=true</i>, such as
      Uppercase = true.</li>
      <li>Other conditions are specified textually in terms of UCD properties.</li>
    </ul>
    </li>
    <li>Boolean combinations of the above</li>
    <li>The two special identifiers <i>sot</i> and <i>eot</i> stand for start and end of text, 
	respectively</li>
  </ul>
  <p>For example, the following is such a list:</p>
	<blockquote>
		<blockquote>
			<p>General_Category = Line Separator (Zl), or<br>General_Category = Paragraph Separator (Zp), or<br>General_Category = Control (Cc), or<br>General_Category = Format (Cf)<br>
			<i>and not</i> <span class="charlist">U+000D CARRIAGE RETURN (CR)<]</span><br>
			<i>and not</i> <span class="charlist">U+000A LINE FEED (LF)</span><br>
			<i>and not</i> <span class="charlist">U+200C ZERO WIDTH NON-JOINER 
      (ZWNJ)</span> <br><i>and not</i> <span class="charlist">U+200D ZERO WIDTH JOINER (ZWJ)</span></p>
		</blockquote>
	</blockquote>
  <p>In the table assigning the boundary property values, all of the values are intended to be 
  disjoint except for the special value <b>Any</b>. In case of conflict, rows higher in the table 
  have precedence in terms of assigning property values to characters. Data files containing 
  explicit assignments of the property values are found in [<a href="../tr41/tr41-1.html#Props">Props</a>].</p>
  <p>Boundary determination is specified in terms of an ordered list of rules, 
	indicating the status of a boundary position. The rules are numbered for reference and are applied in sequence to determine whether 
  there is a boundary at a given offset. That is, there is an implicit “otherwise” at the front of 
  each rule following the first. The rules are processed from top to bottom. As soon as 
  a rule matches and produces a boundary status (boundary or no boundary) for that offset, the 
  process is terminated. </p>
  <p>Each rule consists of a left side, a boundary symbol (see <i>Table 1</i>), and a right side. Either of the sides can 
  be empty. The left and right sides use the boundary property values in regular expressions. 
	The regular expression syntax used is a simplified version of the format 
	supplied in Unicode Technical Standard #18, &#x201C;Unicode Regular Expressions&#x201D;
	[<a href="../tr41/tr41-1.html#RegEx">RegEx</a>].</p>
  <div align="center">
<center>
  <p class="caption">Table 1. <span style="font-weight:400">Boundary Symbols</span></p>
  <table border="0" class="syntax">
    <tr>
      <td>÷</td>
      <td>Boundary (allow break here)</td>
    </tr>
    <tr>
      <td>×</td>
      <td>No boundary (do not allow break here)</td>
    </tr>
    <tr>
      <td>→</td>
      <td>Treat whatever on the left side as if it were what is on the right 
		side&nbsp;</td>
    </tr>
  </table>
  </center>
  </div>
  <p>An <i>underscore</i> (“_”) is used to indicate a space in examples.</p>
  <p>These rules are constrained in three ways, to make implementations significantly simpler and more efficient. 
	These constraints have not been found to be limitations for natural language use. In 
  particular, the rules are formulated so that they can be 
  efficiently implemented, such as 
  with a deterministic finite-state machine based on a small number of property values.</p>
  <ol>
    <li><i>Single boundaries.</i> Each rule has exactly one boundary position. This restriction is 
    more a limitation on the specification methods, because a rule with multiple boundaries could 
    be expressed instead as multiple rules. For example:<ul style="list-style-type:none">
      <li>“a b ÷ c d ÷ e f” could be broken into two rules “a b ÷ c d e f” and “a b c d ÷ e f”</li>
      <li>“a b × c d × e f” could be broken into two rules “a b × c d e f” and “a b c d × e f”</li>
    </ul>
    </li>
    <li><i>Ignore degenerates.</i> No special provisions are made to get marginally better behavior 
    for degenerate cases that never occur in practice, such as an <i>A</i> followed by an Indic 
    combining mark.</li>
	<li><i>Limited negation.</i> Negation of expressions is limited to instances 
	that resolve to a match against single characters, such as “¬(OLetter | 
	Upper | Lower | Sep)”.</li>
  </ol>
  <h2 class="section">2 <a name="Conformance">Conformance</a></h2>
  <p>There are many different ways to divide text elements 
  corresponding to grapheme clusters, words, and sentences, and the Unicode Standard 
	does not restrict the ways in which implementations can produce these 
	divisions.</p>
  <p>This specification defines a <i>default</i> mechanism; more sophisticated 
  implementations can <i>and should</i> tailor it for particular locales or environments. For 
  example, reliable detection of Thai, Lao, Chinese, or Japanese word break boundaries requires the use of dictionary 
  lookup, analogous to English hyphenation. An implementation therefore may need to provide means to 
  override or subclass the default mechanism described in this annex. Note that tailoring can <i>
  either</i> add boundary positions <i>or</i> remove boundary positions, compared to the default 
  specified here.</p>
  <blockquote>
    <p><span class="note">Note:</span> Locale-sensitive boundary 
	specifications can be expressed in LDML [<a href="../tr41/tr41-1.html#UTS35">UTS35</a>] 
    and be contained in the Common Locale Data Repository [<a href="../tr41/tr41-1.html#CLDR">CLDR</a>]. 
	The repository already contains some tailorings, with more to follow.</p>
  </blockquote>
  <p>To maintain canonical equivalence, all of the following specifications are defined on NFD text, 
  as defined in Unicode Standard Annex #15, &#x201C;Unicode Normalization Forms&#x201D; 
  [<a href="../tr41/tr41-1.html#UAX15">UAX15</a>]. A boundary exists in non-NFD text if and only if it would occur at 
  the corresponding position in NFD text. However, the default rules have 
  been written to provide equivalent results for non-NFD text and can be applied directly. Even in 
  the case of tailored rules, the requirement to use NFD is only a logical specification; in 
  practice, implementations can avoid normalization and achieve the same results. For more 
  information, see <span class="section">Section </span><span class="secno">6,</span> <a href="tr29-11.html#Implementation_Notes"><i>Implementation Notes</i></a>.</p>
  <h2 class="section"><a name="Grapheme_Cluster_Boundaries">3 Grapheme Cluster Boundaries</a></h2>
  <p>One or more Unicode characters may make up what the user thinks of as a character or basic unit 
  of the language. To avoid ambiguity with the computer use of the term <i>character,</i> this is 
  called a <i>grapheme cluster</i>. For example, “G” + <i>acute-accent</i> is a 
	grapheme cluster: it is thought of as a single character by users, yet is 
	actually represented by two Unicode code points.</p>
  <p>There are many types of Grapheme clusters. Examples include: combining character sequences, such as (g + 
	ring above); 
  digraphs, such as Slovak “ch”, and sequences with letter modifiers, such as k<sup>w</sup>. Grapheme 
  cluster boundaries are important for collation, regular expressions, and counting “character” 
  positions within text. Word boundaries, line boundaries, and sentence boundaries do not occur 
  within a grapheme cluster. In this section, the Unicode Standard provides a determination of where 
  the default grapheme boundaries fall in a string of characters. This algorithm can be tailored for 
  specific locales or other customizations, which is what is done in providing contracting 
  characters in collation tailoring tables.</p>
  <blockquote>
    <p><span class="note">Note:</span> Default grapheme clusters have been referred to 
    as “locale-independent graphemes.” The term <i>cluster</i> is used to emphasize that the 
    term <i>grapheme</i> is used differently in linguistics. For simplicity and 
	to align terminology with Unicode Technical Standard #10, &#x201C;Unicode Collation Algorithm&#x201D; 
	[<a href="../tr41/tr41-1.html#UTS10">UTS10</a>], 
    the terms <i>default</i> and <i>tailored</i> are used in preference to <i>locale-independent</i> 
    and <i>locale-dependent</i>, respectively.</p>
  </blockquote>
  <p>As far as a user is concerned, the underlying representation of text is not important, but it 
  is important that an editing interface present a uniform implementation of what the user thinks of 
  as characters. Grapheme clusters commonly behave as units in terms of mouse 
	selection, arrow key movement, backspacing, and so on. For example, when an accented 
  character is represented by a character sequence, then using the right arrow key would skip from 
  the start of the base character to the end of the last character of the cluster.</p>
  <p>However, in some cases editing a grapheme cluster element by element may be 
	preferable. 
  For example, on a given system the <i>backspace key</i> might delete by code point, while the <i>delete 
  key</i>
  may delete an entire cluster. Moreover, there is not a one-to-one relationship between 
  grapheme clusters and keys on a keyboard. A single key on a keyboard may correspond to a whole 
  grapheme cluster, a part of a grapheme clusters, or a sequence of more than one grapheme clusters.</p>
  <p>In those relatively rare circumstances where programmers need to supply end 
	users 
	with character counts, the counts should correspond 
  to the number of segments delimited by grapheme cluster boundaries. Grapheme clusters are also used in searching and matching; for 
  more information, see Unicode Technical Standard #10, &#x201C;Unicode Collation Algorithm&#x201D; 
	[<a href="../tr41/tr41-1.html#UTS10">UTS10</a>], and Unicode Technical Standard #18, &#x201C;Unicode 
	Regular Expressions&#x201D; 
	[<a href="../tr41/tr41-1.html#UTS18">UTS18</a>].</p>
  <p>The principal requirements for default grapheme cluster boundaries are the handling of 
  nonspacing marks and Hangul conjoining jamo. Boundaries may be further tailored for requirements 
  of different languages, such as the addition of Indic, Thai, or Tibetan 
  character clusters.</p>
  <p>A default grapheme cluster begins with a base character, except when a 
  nonspacing mark is at the start of text, or when it is preceded by a control or format character.
  In place of a single base character, a Hangul syllable composed of one 
  or more characters may serve as the base. For the rules defining the default boundaries, 
  see <i><a href="tr29-11.html#Default_Grapheme_Cluster_Table">Table 2</a></i>. For more information on the composition of Hangul 
	syllables, 
  see <i>Chapter 3, Conformance</i>, of [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>].</p>
  <blockquote>
    <p><span class="note">Note:</span> The boundary between default grapheme clusters can be 
    determined by just the two adjacent characters. See <span class="section">Section </span><span class="secno">7,</span> <i> <a href="tr29-11.html#Testing">Testing</a></i>, 
    for a chart showing the interactions of pairs of characters.</p>
  </blockquote>
  <p><b><i>Degenerate Cases.</i></b> These 
  definitions are designed to be simple to implement. They need to provide an algorithmic 
  determination of the valid, default grapheme clusters and to exclude sequences that are normally not 
  considered default grapheme clusters. However, they do <i>not</i> have to 
	cover edge cases that 
  will not occur in practice.</p>
  <p>The definition of default grapheme clusters is not meant to exclude the use of more 
  sophisticated definitions of tailored grapheme clusters where appropriate: definitions that more 
  precisely match the user expectations within individual languages for given 
	processes. For example, “ch” may be 
  considered a grapheme cluster in Slovak, for processes such as collation. The default definition is, however, designed to provide a much more accurate 
  match to overall user expectations for what the user perceives of as <i>characters</i> than is provided by individual Unicode 
  code points.</p>
  <p><b><i>Display of Grapheme Clusters.</i></b> Grapheme clusters are not the same as ligatures. 
  For example, the grapheme cluster “ch” in Slovak is not normally a ligature and, conversely, the 
  ligature “fi” is not a grapheme cluster. Default grapheme clusters do not necessarily reflect text 
  display. For example, the sequence &lt;f, i&gt; may be displayed as a single glyph on the screen, but 
  would still be two grapheme clusters.</p>
  <p>For more information on the matching of grapheme clusters with regular 
	expressions, see
  Unicode Techncial Standard #18, &#x201C;Unicode 
	Regular Expressions&#x201D; 
	[<a href="../tr41/tr41-1.html#UTS18">UTS18</a>].</p>
  <blockquote>
    <p><span class="note">Note:</span> As with the other default specifications, implementations 
	may override (tailor) the results to meet the requirements of different 
	environments or particular languages.</p>
  </blockquote>
  <h3 class="section">3.1 <a name="Default_Grapheme_Cluster_Table">Default Grapheme Cluster 
	Boundary Specification</a></h3>
	<p>The Grapheme_Cluster_Break property value assignments are explicitly 
	listed in the corresponding data file; 
	see [<a href="../tr41/tr41-1.html#Props">Props</a>]. The contents of this data file are summarized in <i>Table 2</i>.</p>
	<div align="center">
<center>
   <p class="caption">Table 2. <span style="font-weight: 400">
	Grapheme_Cluster_Break Property Values</span></p>   
  <table cellspacing="0" cellpadding="4" border="0"> <tr>
      <th valign="top">Value</th>
      <th valign="top">Summary List of Characters</th>
    </tr>
    <tr>
      <td valign="top"><b><a name="CR">CR</a></b></td>
      <td><span class="charlist">U+000D CARRIAGE RETURN (CR)</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="LF">LF</a></b></td>
      <td><span class="charlist">U+000A LINE FEED (LF)</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Control">Control</a></b></td>
      <td>General_Category = Line Separator (Zl), or<br>
      General_Category = Paragraph Separator (Zp), or<br>
      General_Category = Control (Cc), or<br>
      General_Category = Format (Cf)<br>
      <i>and not</i> <span class="charlist">U+000D CARRIAGE RETURN (CR)</span><br>
      <i>and not</i> <span class="charlist">U+000A LINE FEED (LF)</span><br>
      <i>and not</i> <span class="charlist">U+200C ZERO WIDTH NON-JOINER 
      (ZWNJ)</span> <br>
      <i>and not</i> <span class="charlist">U+200D ZERO WIDTH JOINER (ZWJ) </span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Extend">Extend</a></b></td>
      <td>
      <p>Grapheme_Extend = true</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="L">L</a></b></td>
      <td>Hangul_Syllable_Type=L, that is:<span class="charlist"><br>
      U+1100 (</span><span class="symbol">ᄀ</span><span class="charlist">) HANGUL CHOSEONG KIYEOK<br>
      ..U+1159 (ᅙ) HANGUL CHOSEONG YEORINHIEUH<br>
      U+115F (</span><span class="specials-book"></span><span class="specials-web">HCF</span><span class="charlist">) 
		HANGUL CHOSEONG FILLER</span></td>
    </tr>
    <tr>
      <td valign="top" style="border-top:solid"><b><a name="V">V</a></b></td>
      <td style="border-top:solid">Hangul_Syllable_Type=V, that is:<br>
      <span class="charlist">U+1160 (</span><span class="specials-book">></span><span class="specials-web">HJF</span><span class="charlist">) 
      HANGUL JUNGSEONG FILLER<br>
      ..U+11A2 (</span><span class="symbol">ᆢ</span><span class="charlist">) HANGUL JUNGSEONG 
      SSANGARAEA</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="T">T</a></b></td>
      <td>Hangul_Syllable_Type=T, that is:<br>
      <span class="charlist">U+11A8 (</span><span class="symbol">ᆨ</span><span class="charlist">) 
      HANGUL JONGSEONG KIYEOK<br>
      ..U+11F9 (</span><span class="symbol">ᇹ</span><span class="charlist">) HANGUL JONGSEONG 
      YEORINHIEUH</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="LV">LV</a></b></td>
      <td>Hangul_Syllable_Type=LV, that is:<br>
      <span class="charlist">U+AC00 (</span><span class="symbol">가</span><span class="charlist">) 
      HANGUL SYLLABLE GA<br>
      U+AC1C (</span><span class="symbol">개</span><span class="charlist">) HANGUL SYLLABLE GAE<br>
      U+AC38 (</span><span class="symbol">갸</span><span class="charlist">) HANGUL SYLLABLE GYA<br>
      ...</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="LVT">LVT</a></b></td>
      <td>Hangul_Syllable_Type=LVT, that is:<br>
      <span class="charlist">U+AC01 (</span><span class="symbol">각</span><span class="charlist">) 
      HANGUL SYLLABLE GAG<br>
      U+AC02 (</span><span class="symbol">갂</span><span class="charlist">) HANGUL SYLLABLE GAGG<br>
      U+AC03 (</span><span class="symbol">갃</span><span class="charlist">) HANGUL SYLLABLE GAGS<br>
      U+AC04 (</span><span class="symbol">간</span><span class="charlist">) HANGUL SYLLABLE GAN<br>
      ...</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="AnyGC">Any</a></b></td>
      <td>Any character (includes all of the above)</td>
    </tr>
  </table>
  </center>
  </div>
  <div class="web-only"><p>&nbsp;</p></div>
  <h4>Grapheme Cluster Boundary Rules</h4>
  <table cellspacing="0" cellpadding="4" border="0" class="nb">
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Break at the start and end of text.</i></td>
    </tr>
    <tr>
      <td class="nb" width="1%">
		GB1.</td>
      <td class="nb" style="text-align:right" width="45%">sot</td>
      <td class="nb" style="text-align:center" width="2%">÷</td>
      <td class="nb" width="40%"></td>
    </tr>
    <tr>
      <td class="nb">GB2.</td>
      <td class="nb" style="text-align:right"></td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">eot</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break between a CR and LF. Otherwise, break before and after 
      controls.</i></td>
    </tr>
    <tr>
      <td class="nb">GB3.</td>
      <td class="nb" style="text-align:right">CR</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">LF</td>
    </tr>
    <tr>
      <td class="nb">GB4.</td>
      <td class="nb" style="text-align:right">( Control | CR | LF )</td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">&nbsp;</td>
    </tr>
    <tr>
      <td class="nb">GB5.</td>
      <td class="nb" style="text-align:right"></td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">( Control | CR | LF )</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break Hangul syllable sequences.</i></td>
    </tr>
    <tr>
      <td class="nb">GB6.</td>
      <td class="nb" style="text-align:right">L</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">( L | V | LV | LVT )</td>
    </tr>
    <tr>
      <td class="nb">GB7.</td>
      <td class="nb" style="text-align:right">( LV | V )</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">( V | T )</td>
    </tr>
    <tr>
      <td class="nb">GB8.</td>
      <td class="nb" style="text-align:right">( LVT | T)</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">T</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break before extending characters.</i></td>
    </tr>
    <tr>
      <td class="nb">GB9.</td>
      <td class="nb" style="text-align:right">&nbsp;</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Extend</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Otherwise, break everywhere.</i></td>
    </tr>
    <tr>
      <td class="nb">GB10.</td>
      <td class="nb" style="text-align:right">Any</td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">Any</td>
    </tr>
  </table>
  <p>&nbsp; </p>
  <h2 class="section"><a name="Word_Boundaries">4 Word Boundaries</a></h2>
  <p>Word boundaries are used in a number of different contexts. The most familiar ones are 
  selection (double-click mouse selection or “move to next word” control-arrow keys) 
  and the dialog option “Whole Word Search” for search and replace. They are also used in database queries, to 
  determine whether elements are within a certain number of words of one another.</p>
  <p>Word boundaries can also be used in <i>intelligent cut and paste</i>. With this 
  feature, if the user cuts a selection of text on word boundaries, adjacent spaces are collapsed to a 
  single space. For example, cutting “quick” from “The_quick_fox” would leave “The_&nbsp;_fox”. 
  Intelligent cut and paste collapses this text to “The_fox”.<i> Figure 1</i> gives an example of word boundaries.</p>
  <div align="center">
<center>
   <p class="caption">Figure 1. <span style="font-weight: 400">Word Boundaries</span></p>
     <table cellspacing="0" cellpadding="0" border="1">
      <tr>
        <td>The</td>
        <td>&nbsp;</td>
        <td>quick</td>
        <td>&nbsp;</td>
        <td>(</td>
        <td>“</td>
        <td>brown</td>
        <td>”</td>
        <td>)</td>
        <td>&nbsp;</td>
        <td>fox</td>
        <td>&nbsp;</td>
        <td>can’t</td>
        <td>&nbsp;</td>
        <td>jump</td>
        <td>&nbsp;</td>
        <td>32.3</td>
        <td>&nbsp;</td>
        <td>feet</td>
        <td>,</td>
        <td>&nbsp;</td>
        <td>right</td>
        <td>?</td>
      </tr>
    </table>
    </center>
  </div>
  <p>There is a boundary, for example, on either side of the word <i>brown</i>. These are the 
  boundaries that users would expect, for example, if they chose Whole Word Search. Matching <i>
  brown</i> with Whole Word Search works because there is a boundary on either side. Matching <i>brow</i> 
  does not. Matching <i>“brown”</i> also works because there are boundaries between the parentheses 
  and the quotation marks.</p>
  <p>Proximity tests in searching determines whether, for example, “quick” is within 
	three words of “fox”. 
  That is done with the above boundaries by ignoring any words that do not contain a letter, as in 
  <i>Figure 2</i>. Thus, for proximity, “fox” is within three words of “quick”. This same technique 
  can be used for “get next/previous word” commands or keyboard arrow keys. Letters are not the only 
  characters that can be used to determine the “significant” words; different implementations may 
  include other types of characters such as digits or perform other analysis of the characters.</p>
  <div align="center">
<center>
    <p class="caption">Figure 2. <span style="font-weight: 400">Extracted Words</span></p>
    <table cellspacing="0" cellpadding="0" border="1">
      <tr>
        <td>The</td>
        <td>quick</td>
        <td>brown</td>
        <td>fox</td>
        <td>can’t</td>
        <td>jump</td>
        <td>32.3</td>
        <td>feet</td>
        <td>right</td>
      </tr>
    </table>
    </center>
  </div>
  <p>Word boundaries are related to line boundaries, but are distinct: there are some 
  word break boundaries that are not line break boundaries, and vice versa. A 
	line break boundary is usually a word break boundary, but there are 
	exceptions such as a word containing a 
  SHY (soft hyphen): it will break across lines, yet is a single word.</p>
  <blockquote>
    <p><span class="note">Note:</span> As with the other default specifications, implementations 
	may override 
    (tailor) the results to meet the requirements of different environments or particular languages. 
    For some languages, it may also be necessary to have different tailored word break 
    rules for selection versus Whole Word Search.</p>
    <p>In particular, the characters with the Line_Break property values of Contingent_Break 
    (CB), Complex_Context (SA/South East Asian), and XX (Unknown) are assigned word boundary 
    property values based on criteria outside of the scope of this annex. </p>
  </blockquote>  
  <div class="book-only"><p>&nbsp;</p></div>
  <h3 class="section">4.1 <b><a name="Default_Word_Boundaries">Default Word Boundary 
	Specification</a></b></h3>
	<p>The Word_Break property value assignments are explicitly listed in the 
	corresponding data file; 
	see [<a href="../tr41/tr41-1.html#Props">Props</a>]. The contents of this data file are summarized in <i>Table 3</i>.</p>
	<div align="center">
<center>
  <p class="caption">Table 3. <span style="font-weight: 400">Word_Break Property Values</span></p>
  <table cellspacing="0" cellpadding="4" border="0">
       <tr>
  <th valign="top">Value</th>
  <th valign="top">Summary List of Characters</th>
    	</tr>
    <tr>
      <td valign="top"><b><a name="Format">Format</a></b></td>
      <td>General_Category = Format (Cf)<i><br>
      and not</i> <span class="charlist">U+200C ZERO WIDTH NON-JOINER (ZWNJ)
      </span><br>
      <i>and not</i> <span class="charlist">U+200D ZERO WIDTH JOINER (ZWJ) </span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Katakana">Katakana</a></b></td>
      <td>Script = KATAKANA, <i>or<br>
     </i> any of the following:<br>
      <span class="charlist">U+3031 (〱) VERTICAL KANA REPEAT MARK<br>
      U+3032 (〲) VERTICAL KANA REPEAT WITH VOICED SOUND MARK<br>
      U+3033 (〳) VERTICAL KANA REPEAT MARK UPPER HALF<br>
      U+3034 (〴) VERTICAL KANA REPEAT WITH VOICED SOUND MARK UPPER HALF<br>
      U+3035 (〵) VERTICAL KANA REPEAT MARK LOWER HALF<br>
      U+309B (゛) KATAKANA-HIRAGANA VOICED SOUND MARK<br>
      U+309C (゜) KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK<br>
      U+30A0 (<span class="glyphs-book"></span><span class="symbol-web">゠</span>) KATAKANA-HIRAGANA DOUBLE HYPHEN<br>
      U+30FC (</span><span class="symbol">ー</span><span class="charlist">) KATAKANA-HIRAGANA 
      PROLONGED SOUND MARK<br>
      U+FF70 (</span><span class="symbol">ｰ</span><span class="charlist">) HALFWIDTH 
      KATAKANA-HIRAGANA PROLONGED SOUND MARK<br>
      U+FF9E (</span><span class="symbol">ﾞ</span><span class="charlist">) HALFWIDTH KATAKANA VOICED 
      SOUND MARK<br>
      U+FF9F (</span><span class="symbol">ﾟ</span><span class="charlist">) HALFWIDTH KATAKANA 
      SEMI-</span><span class="name">VOICED SOUND MARK</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="ALetter">ALetter</a></b></td>
      <td>Alphabetic = true, <i>or<br>
     </i><span class="charlist">U+05F3 (</span><span class="symbol">׳</span><span class="charlist">) </span><span class="name">HEBREW PUNCTUATION GERESH</span><br>
      <i>and</i> Ideographic = false<br>
      <i>and</i> Word_Break <span class="mathsym2">≠</span>Katakana<br>
      <i>and</i> LineBreak <span class="mathsym2">≠</span>Complex_Context (SA)<br>
      <i>and</i> Script <span class="mathsym2">≠</span> Hiragana<br>
      <i>and</i> Grapheme_Extend = false</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="MidLetter">MidLetter</a></b></td>
      <td>Any of the following:<br>
      <span class="charlist">U+0027 (</span><span class="symbol">&#39;</span><span class="charlist">) 
      APOSTROPHE<br>
      U+00B7 (</span><span class="symbol">·</span><span class="charlist">) MIDDLE DOT<br>
      U+05F4 (<span class="symbol">״</span>) </span><span class="name">HEBREW PUNCTUATION GERSHAYIM</span><br>
      <span class="charlist">U+2019 (</span><span class="symbol">’</span><span class="charlist">) 
      RIGHT SINGLE QUOTATION MARK (curly apostrophe)<br>
      U+2027 (</span><span class="symbol">‧</span><span class="charlist">) HYPHENATION POINT<br>
      U+003A (:) COLON (used in Swedish)</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="MidNum">MidNum</a></b></td>
      <td>Line_Break = Infix_Numeric
      <i>and not</i> <span class="charlist">U+003A (:) </span><span class="name">COLON</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Numeric">Numeric</a></b></td>
      <td>Line_Break = Numeric</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="ExtendNumLetWB">ExtendNumLet</a></b></td>
      <td>General_Category = Connector_Punctuation</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="AnyWB">Any</a></b></td>
      <td>Any character (includes all of the above)</td>
    </tr>
  </table>
  </center>
  </div>
  <p>&nbsp;</p>
  <h4>Word Boundary Rules</h4>
  <table cellspacing="0" cellpadding="4" border="0" class ="nbwide">
    <tr>
      <td colspan="4" class="nb">
      <p class="rule"><i>Break at the start and end of text.</i></td>
    </tr>
    <tr>
      <td class="nb">
		WB1.</td>
      <td width="45%"class="nb" style="text-align: right">sot</td>
      <td class="nb" style="text-align:center" width="2%">÷</td>
      <td width="40%" class="nb"></td>
    </tr>
    <tr>
      <td class="nb" style="text-align:left">
		WB2.</td>
      <td class="nb"></td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">eot</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break within CRLF.</i></td>
    </tr>
    <tr>
      <td class="nb">
		WB3.</td>
      <td class="nb" style="text-align:right">CR</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">LF</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Ignore Format and Extend characters, except when they appear at the beginning of a region of 
      text.<br>
		(See <span class="section">Section </span><span class="secno">6.2,</span>&nbsp;<a href="tr29-11.html#Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a>.)</i></td>
    </tr>
    <tr>
      <td class="nb">
		WB4.</td>
      <td class="nb" style="text-align:right">X (Extend | Format)*</td>
      <td class="nb" style="text-align:center">→</td>
      <td class="nb">X</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break between most letters.</i></td>
    </tr>
    <tr>
      <td class="nb">
		WB5.</td>
      <td class="nb" style="text-align: right">
		ALetter</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">ALetter</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break letters across certain punctuation.</i></td>
    </tr>
    <tr>
      <td class="nb">
		WB6.</td>
      <td class="nb" style="text-align:right">ALetter</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">MidLetter ALetter</td>
    </tr>
    <tr>
      <td class="nb">
		WB7.</td>
      <td class="nb" style="text-align:right">ALetter MidLetter</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">ALetter</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break within sequences of digits, or digits adjacent to letters 
      (“3a”, or “A3”).</i></td>
    </tr>
    <tr>
      <td class="nb">
		WB8.</td>
      <td class="nb" style="text-align:right">Numeric</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Numeric</td>
    </tr>
    <tr>
      <td class="nb">
		WB9.</td>
      <td class="nb" style="text-align:right">ALetter</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Numeric</td>
    </tr>
    <tr>
      <td class="nb">
		WB10.</td>
      <td class="nb" style="text-align:right">Numeric</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">ALetter</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break within sequences, such as “3.2” or “3,456.789”.</i></td>
    </tr>
    <tr>
      <td class="nb">
		WB11.</td>
      <td class="nb" style="text-align:right">Numeric MidNum</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Numeric</td>
    </tr>
    <tr>
      <td class="nb">
		WB12.</td>
      <td class="nb" style="text-align:right">Numeric</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">MidNum Numeric</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break between Katakana.</i></td>
    </tr>
    <tr>
      <td class="nb">
		WB13.</td>
      <td class="nb" style="text-align:right">Katakana</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Katakana</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
		<p class="rule"><i>Do not break from extenders.</i></td>
    </tr>
    <tr>
      <td class="nb">
		WB13a.</td>
      <td class="nb" style="text-align:right">(ALetter | Numeric | Katakana | ExtendNumLet) </td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">ExtendNumLet</td>
    </tr>
    <tr>
      <td class="nb">
		WB13b.</td>
      <td class="nb" style="text-align:right">ExtendNumLet</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">(ALetter | Numeric | Katakana) </td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Otherwise, break everywhere (including around ideographs).</i></td>
    </tr>
    <tr>
      <td class="nb">
		WB14.</td>
      <td class="nb" style="text-align:right">Any</td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">Any</td>
    </tr>
  </table>
  <p><br>
  <span class="note">Notes:</span> </p>
  <ul>
    <li>
    <p>It is not possible to provide a uniform set of rules that 
	resolves all issues across languages or that handles all ambiguous 
	situations within a given 
    language. The goal for the specification presented in this annex is to 
	provide a workable default; 
    tailored implementations can be more sophisticated.</li>
    <li>
    <p>For Thai, Lao, Khmer, Myanmar, and other scripts that do not use typically use 
    spaces between words, a good implementation should not just depend on the default word boundary 
    specification, but should use a more sophisticated mechanism, as is also 
	required for line breaking. Ideographic 
    scripts such as Japanese and Chinese are even more complex. Where Hangul text is written without 
    spaces, the same applies. However, in the absence of such a more sophisticated mechanism, the 
    rules specified in this annex at least supply a well-defined default.</li>
    <li>
    <p>The correct interpretation of hyphens in the context of word 
	boundaries is challenging. It is quite common for separate words to be 
	connected with a hyphen: “out-of-the-box,” “under-the-table,” “Italian-American,” 
	and so on. A significant number are hyphenated names, such as “Smith-Hawkins.” 
	When doing a Whole Word Search or query, users expect to find the word 
	within those hyphens. While there are some cases where they are separate 
	words (usually to resolve some ambiguity such as “re-sort” as opposed to “resort”), it 
	is better 
    overall to keep the hyphen out of the default definition. Hyphens include 
	U+002D <span class="name">HYPHEN-MINUS</span>, U+2010 <span class="name">HYPHEN</span>, possibly also
    U+058A (<span class="charlist"> ֊ </span>) <span class="name">ARMENIAN HYPHEN</span>, and U+30A0<span class="charlist">
	</span><span class="name">KATAKANA-HIRAGANA DOUBLE HYPHEN</span>.</li>
    <li>
    <p>Implementations may, however, build on the information 
	supplied by word boundaries. For example, a spell-checker would first check 
	that each word according to the above definition was valid, checking four 
	words in “out-of-the-box.” However, if that failed, it could build the 
	compound word and check if it as a whole was in the dictionary (even if all 
	the components were not in the dictionary), such as with “re-iterate.” Of 
	course, spell-checkers for highly inflected or agglutinative languages will 
	need much more sophisticated algorithms.</li>
    <li>
    <p>The use of the apostrophe is ambiguous. It is usually considered part of one word (“can’t” 
	or 
    “aujourd’hui”) but it may also be considered as part of two words (“l’objectif”). 
	A further complication is the use of the same character as an apostrophe and 
	as a quotation mark. Therefore leading or trailing apostrophes are 
	best excluded from the default definition of a word. In some languages, such 
	as French and Italian, tailoring to break words when the character after the 
	apostrophe is a vowel may yield better results in more cases. This can be 
	done by adding a rule WB5a.</p>
    <table cellspacing="0" cellpadding="4" border="0" style="border:none">
      <tr>
        <td class="nb" colspan="4">
        <p class="rule"><i>Break between apostrophe and vowels (French, Italian).</i></td>
      </tr>
      <tr>
        <td class="nb">
			WB5a.</td>
        <td class="nb" style="text-align:right" width="45%"><i>apostrophe</i> </td>
        <td class="nb" style="text-align:center">÷</td>
        <td class="nb" width="40%">vowels</td>
      </tr>
    </table>
    <p>and defining appropriate property values for apostrophe and vowels. Apostrophe includes
    U+0027 (<span class="symbol">&#39;</span>) 
    <span class="name">APOSTROPHE</span> and U+2019 (<span class="symbol">’</span>) 
	<span class="name">RIGHT SINGLE QUOTATION MARK</span><span class="charlist"> </span>(curly apostrophe<span class="charlist">)</span>. Finally, in some transliteration schemes, apostrophe is 
    used at the beginning of words, requiring special tailoring.<br>
    </li>
    <li>
    <p>To allow acronyms like “U.S.A.”, a tailoring may include U+002E
	<span class="name">FULL STOP</span>
    in <a name="ExtendNumLetSB">ExtendNumLet</a>.</li>
    <li>
    <p>Certain cases such as colons in words (c:a) are included in the default 
    even though they may be specific to relatively small user communities (Swedish) because they do 
    not occur otherwise, in normal text, and so do not cause a problem for other languages.</li>
    <li>
    <p>For Hebrew, a tailoring may include a double quotation mark between letters, 
    because legacy data may contain that in place of <span class="charlist">U+05F4 (״) gershayim</span>. 
    This can be done by adding double quotation mark to MidLetter. <span class="charlist">U+05F3 (׳) 
    </span><span class="name">HEBREW PUNCTUATION GERESH</span> may also be included in a tailoring.</li>
    <li>
    <p>Format characters are included if they are not initial. Thus &lt;LRM&gt;&lt;ALetter&gt; will 
    break before the &lt;letter&gt;, but there is no break in &lt;ALetter&gt;&lt;LRM&gt;&lt;ALetter&gt; or &lt;ALetter&gt;&lt;LRM&gt;.</li>
    <li>
    <p>Characters such as hyphens, apostrophes, quotation 
    marks, and colon should be taken into account when using identifiers that are intended to 
    represent words of one or more natural languages. See <span class="section">Section </span><span class="secno">2.3,</span> <i>Specific 
    Character Adjustments</i>, of [<a href="../tr41/tr41-1.html#UAX31">UAX31</a>]. 
    Treatment of hyphens, in particular, may be different in the case of processing identifiers than 
    when using word break analysis for a Whole Word Search or query, because when handling 
    identifiers the goal will be to parse maximal units corresponding to natural language “words,” 
    rather than to find smaller word units within longer lexical units connected by hyphens.</li>
  </ul>
  <h2 class="section"><a name="Sentence_Boundaries">5 Sentence Boundaries</a></h2>
  <p>Sentence boundaries are often used for triple-click or some other method of selecting or 
  iterating through blocks of text that are larger than single words. They are also used to 
  determine whether words occur within the same sentence in database queries.</p>
  <p>Plain text provides inadequate information for determining good sentence boundaries. Periods can signal the end of a sentence, indicate abbreviations, or be used for 
  decimal points, for example. Without much more sophisticated analysis, one 
	cannot distinguish between the two 
  following examples of the sequence &lt;?, ”, space, uppercase-letter&gt;:</p>
  <blockquote>
    <table cellspacing="0" cellpadding="0" border="1">
      <tr>
        <td>He said, “Are you going?”&nbsp;</td>
        <td>John shook his head.</td>
      </tr>
    </table><br>
<table cellspacing="0" cellpadding="0" border="1">
      <tr>
        <td>“Are you going?” John asked.</td>
      </tr>
    </table>
  </blockquote>
  <p>Without analyzing the text 
  semantically, it is impossible to be certain which of these usages is intended (and sometimes 
  ambiguities still remain). However, in most cases a straightforward mechanism 
  works well.</p>
  <blockquote>
    <p><span class="note">Note:</span> As with the other default specifications, implementations are free to override 
    (tailor) the results to meet the requirements of different environments or particular languages.</p>
  </blockquote>
  <div class="book-only"><p>&nbsp;</p></div>
  <h3 class="section">5.1 <a name="Default_Sentence_Boundaries">Default Sentence Boundary 
	Specification</a></h3>
	<p>The Sentence_Break property value assignments are explicitly listed in 
	the corresponding data file; see [<a href="../tr41/tr41-1.html#Props">Props</a>]. The contents of this data file are summarized in <i>Table 4</i>.</p>
	<div align="center">
<center>
   <p class="caption">Table 4. <span style="font-weight: 400">Sentence_Break Property Values</span></p>    
  <table cellspacing="0" cellpadding="4" border="0" class="nbwide">
  <tr>    
  <th valign="top">Value</th>
  <th valign="top">Summary List of Characters</th>
    </tr>
    <tr>
      <td valign="top"><b><a name="Sep">Sep</a></b></td>
      <td>Any of the following characters:<br>
      <span class="charlist">U+000A LINE FEED (LF)<br>
      U+000D CARRIAGE RETURN (CR)<br>
      U+0085 NEXT LINE (NEL)<br>
      U+2028 LINE SEPARATOR (LS)<br>
      U+2029 PARAGRAPH SEPARATOR (PS)</span></td>
    </tr>
    <tr>
      <td valign="top"><b>Format</b></td>
      <td>General_Category = Format (Cf)<i><br>
      and not</i> <span class="charlist">U+200C ZERO WIDTH NON-JOINER (ZWNJ)
      </span><br>
      <i>and not</i> <span class="charlist">U+200D ZERO WIDTH JOINER (ZWJ) </span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Sp">Sp</a></b></td>
      <td>Whitespace = true<br>
      <i>and</i> Sentence_Break<span class="mathsym2">≠</span> Sep<br>
      <i>and not</i><span class="charlist"> U+00A0 (<span class="specials-book"></span><span class="specials-web">NBSP</span>) NO-BREAK SPACE (NBSP)</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Lower">Lower</a></b></td>
      <td>Lowercase = true<br>
      <i>and</i> GRAPHEME EXTEND = false</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Upper">Upper</a></b></td>
      <td>General_Category = Titlecase_Letter (Lt), <i>or</i><br>
      Uppercase = true</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="OLetter">OLetter</a></b></td>
      <td>Alphabetic = true, <i>or<br>
     </i> <span class="charlist">U+00A0 (<span class="specials-book"></span><span class="specials-web">NBSP</span>) NO-BREAK SPACE (NBSP)</span>,<i>
      or</i><br>
      <span class="charlist">U+05F3 (׳) HEBREW PUNCTUATION GERESH<br>
      </span><i>and</i> Lower = false<br>
      <i>and</i> Upper = false<br>
      <i>and</i> Grapheme_Extend = false</td>
    </tr>
    <tr>
      <td valign="top"><b>Numeric</b></td>
      <td>Linebreak = Numeric (NU)</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="ATerm">ATerm</a></b></td>
      <td><span class="charlist">U+002E (</span><span class="symbol">.</span><span class="charlist">) 
      F</span><span class="name">ULL STOP</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="STerm">STerm</a></b></td>
      <td>STerm = true</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Close">Close</a></b></td>
      <td>General_Category = Open_Punctuation (Po), <i>or</i><br>
      General_Category = Close_Punctuation (Pe), <i>or</i><br>
      Linebreak = Quotation (QU)<br>
      <i>and not</i> <span class="charlist">U+05F3 (׳) HEBREW PUNCTUATION 
      GERESH<br>
      </span><i>and</i> ATerm = false<br>
      <i>and</i> STerm = false</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="AnySB">Any</a></b></td>
      <td>Any character (includes all of the above)</td>
    </tr>
  </table></center>
  </div>
  <p>&nbsp;</p>
  <h4>Sentence Boundary Rules</h4>
  <table cellspacing="0" cellpadding="4" border="0" class="nb">
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Break at the start and end of text.</i></td>
    </tr>
    <tr>
      <td class="nb" width="1%">
		SB1.</td>
      <td class="nb" style="text-align:right" width="45%">sot</td>
      <td class="nb" style="text-align:center" width="2%">÷</td>
      <td class="nb" width="40%"></td>
    </tr>
    <tr>
      <td class="nb">SB2.</td>
      <td class="nb" style="text-align:right"></td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">eot</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break within CRLF.</i></td>
    </tr>
    <tr>
      <td class="nb">
		SB3.</td>
      <td class="nb" style="text-align:right">CR</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">LF</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Break after paragraph separators.</i></td>
    </tr>
    <tr>
      <td class="nb">
		SB4.</td>
      <td class="nb" style="text-align:right">Sep</td>
      <td class="nb" style="text-align:center">÷</td>
      <td  class="nb">&nbsp;</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Ignore Format and Extend characters, except when they appear at the beginning of a region of 
      text.
		(See <span class="section">Section </span><span class="secno">6.2,</span>&nbsp;<a href="tr29-11.html#Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a>.)</i></td>
    </tr>
    <tr>
      <td class="nb">
		SB5.</td>
      <td class="nb" style="text-align:right">X (Extend | Format)*</td>
      <td class="nb" style="text-align:center">→</td>
      <td  class="nb">X</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break after ambiguous terminators like period, if 
		they are immediately 
      followed by a number or lowercase letter, if they are between uppercase letters, or if the first 
      following letter (optionally after certain punctuation) is lowercase. For example, a period 
      may be an abbreviation or numeric period, and thus may not mark the end of a sentence.</i></td>
    </tr>
    <tr>
      <td class="nb">SB6.</td>
      <td class="nb" style="text-align:right">ATerm</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Numeric</td>
    </tr>
    <tr>
      <td class="nb">SB7.</td>
      <td class="nb" style="text-align:right">Upper ATerm</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Upper</td>
    </tr>
    <tr>
      <td class="nb">SB8.</td>
      <td class="nb" style="text-align:right">ATerm Close* Sp*</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">( ¬(OLetter | Upper | Lower | Sep) )* Lower</td>
    </tr>
    <tr>
      <td class="nb">
		SB8a.</td>
      <td class="nb" style="text-align:right">(STerm | ATerm) Close* Sp*</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">(STerm | ATerm)</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Break after sentence terminators, but include closing punctuation, trailing 
      spaces, and a paragraph separator (if present). [See note below.]</i></td>
    </tr>
    <tr>
      <td class="nb">SB9.</td>
      <td class="nb" style="text-align:right">( STerm | ATerm ) Close*</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">( Close | Sp | Sep )</td>
    </tr>
    <tr>
      <td class="nb">SB10.</td>
      <td class="nb" style="text-align:right">( STerm | ATerm ) Close* Sp*</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">( Sp | Sep )</td>
    </tr>
    <tr>
      <td class="nb">SB11.</td>
      <td class="nb" style="text-align:right">( STerm | ATerm ) Close* Sp*</td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">&nbsp;</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Otherwise, do not break.</i></td>
    </tr>
    <tr>
      <td class="nb">SB12.</td>
      <td class="nb" style="text-align:right">Any</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Any</td>
    </tr>
  </table>
    <div class="book-only"><p style="font-size:50%">&nbsp;</p></div>
	<p><span class="note">Notes:</span></p>
  <ul>
    <li>
    <p>Note added in proof. NBSP should have been given the property Sp (to 
	match the updated&nbsp; Word_Break). Implementations are encouraged to 
	tailor Sp so as to include NBSP.</p>
  	</li>
	<li>
    <p>Note added in proof: The context required for determining a 
	break position should never extend beyond the surrounding break positions on 
	either side. Implementations are recommended to add Sterm and ATerm to the 
	righthand side of Rule SB8, which then becomes:</p>
  <table cellspacing="0" cellpadding="4" border="0" style="border:none" id="table6">
    <tr>
      <td class="nb" width="1%">SB8*</td>
      <td class="nb" style="text-align:right" width="40%">ATerm Close* Sp*</td>
      <td class="nb" style="text-align:center" width="2%">×</td>
      <td class="nb" width="40%">( ¬(OLetter | Upper | Lower | Sep | 
		STerm | ATerm) )* Lower</td>
    </tr>
  </table>
  	</li>
	<li>
    <p>Note added in proof: Rule SB11 has a typo. 
	Implementations are recommended to implement the following corrected 
	version which adds a Sep?:</p>
	<table cellspacing="0" cellpadding="4" border="0" class="nb" id="table1">
		<tr>
			<td class="nb" width="1%">SB11*</td>
			<td class="nb" style="text-align:right" width="40%">( STerm | ATerm ) Close* Sp* 
		Sep?</td>
			<td class="nb" style="text-align:center" width="2%">÷</td>
			<td class="nb" width="40%">&nbsp;</td>
		</tr>
	</table>
  	</li>
	<li>
    <p>Rules SB6-8 are designed to forbid breaks within strings like</p>
    <div align="center">
<center>
    <table cellspacing="0" cellpadding="0" border="1">
      <tr>
        <td class="nb" style="text-align:center">c.d&nbsp;</td>
      </tr>
      <tr>
        <td class="nb" style="text-align:center">3.4</td>
      </tr>
      <tr>
        <td class="nb" style="text-align:center">U.S.</td>
      </tr>
      <tr>
        <td class="nb" style="text-align:center">... the resp. leaders are ...</td>
      </tr>
      <tr>
        <td class="nb" style="text-align:center">... etc.)’&nbsp;‘(the ...</td>
      </tr>
    </table><p></p>
    </center>
    </div>
    <p>They permit breaks in strings like</p>
    <div align="center">
<center>
    <table cellspacing="0" cellpadding="0" border="1">
      <tr>
        <td class="nb" style="text-align:left">&nbsp;She said “See spot run.”&nbsp;</td>
        <td>John shook his head. ...</td>
      </tr>
      <tr>
        <td class="nb" style="text-align:left">... etc.</td>
        <td>它们指...</td>
      </tr>
      <tr>
        <td class="nb" style="text-align:left">...理数字.</td>
        <td>它们指...</td>
      </tr>
    </table>
    </center>
    </div>
    <p>They cannot detect cases like “...Mr. Jones...”; more 
    sophisticated tailoring would be required to detect such cases.</li>
  </ul>
  <h2 class="section"><a name="Implementation_Notes">6 Implementation Notes</a></h2>
  <h3 class="section">6.1 <a name="Normalization">Normalization</a></h3>
  <p>The boundary specifications are stated in terms of text normalized 
	according to Normalization Form NFD (see Unicode Standard Annex #15, &#x201C;Unicode 
	Normalization Forms&#x201D; [<a href="../tr41/tr41-1.html#UAX15">UAX15</a>]). In practice, normalization of the input is not 
  required. To ensure that the same results are returned for canonically equivalent text (that is, 
  the same boundary positions will be found, although those may be represented by different 
  offsets), the grapheme cluster boundary specification has the following features:</p>
  <ol type="a">
    <li>There is never a break within a sequence of nonspacing marks.</li>
    <li>There is never a break between a base character and subsequent 
	nonspacing marks. </li>
  </ol>
  <p>The specification also avoids certain problems by explicitly assigning the 
	Extend property value to certain characters, such as U+09BE (<span class="symbol">া</span>) 
  <span class="name">BENGALI VOWEL SIGN AA</span>, to deal with particular compositions.</p>
  <p>The other default boundary specifications never break within grapheme clusters, and 
	they always use 
  a consistent property value for each grapheme cluster as a whole.</p>
  <h3 class="section">6.2 <a name="Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a></h3>
  <p>An important rule for the default word and sentence specifications ignores 
	Extend and Format characters. The main purpose of this rule is to always 
	treat a grapheme cluster as a single character—that is, as if it were simply 
	the first character of the cluster. Both word and sentence specifications do 
	not distinguish between L, V, T, LV, and LVT: 
	thus it does not matter whether 
  there is a sequence of these or a single one. In addition, there is a specific 
  rule to disallow breaking within CRLF. Thus ignoring Extend is sufficient to disallow breaking 
  within a grapheme cluster. Format characters are also ignored by default, because these characters 
  are normally irrelevant to such boundaries.</p>
  <p>The “Ignore” rule is then equivalent to making the 
	following changes in the rules:</p>
  <table border="0" id="table4" class="nb" cellspacing="0" cellpadding="4" >
	<tr>
		<td class="nb" colspan="3">
		<p class="rule">Replace the “Ignore” rule by the following, to disallow 
	breaks within sequences (except after CRLF and related characters):</p></td>
	</tr>
	<tr>
		<th class="nb" style="text-align: right">Original</th>
		<th class="nb" style="text-align:center"><span class="transform">→</span></th>
		<th class="nb">Modified</th>
	</tr>
	<tr>
		<td class="nb" style="text-align: right">
		  X (Extend | Format)*→X</td>
		<td class="nb" style="text-align:center"><b><span class="transform">→</span></b></td>
		<td class="nb">(¬Sep) × <u>(Extend | Format)</u></td>
	</tr>
	<tr>
		<td class="nb" colspan="3">
		<p class="rule">In 
			<i>all</i> subsequent rules, insert (Extend | Format)* after every boundary property value. (It is not 
	necessary to do this after the final property, on the right side of the break symbol.) For example:</td>
	</tr>
	<tr>
		<th class="nb" style="text-align: right">Original</th>
		<th class="nb" style="text-align:center"><span class="transform">→</span></th>
		<th class="nb">Modified</th>
	</tr>
	<tr>
		<td class="nb" style="text-align: right">X Y × Z W</td>
		<td class="nb" style="text-align:center"><b><span class="transform">→</span></b></td>
		<td class="nb">X 
		<u>(Extend | Format)*</u> 
        Y <u>(Extend | Format)*</u>
		× Z <u>(Extend | 
        Format)*</u> W</td>
	</tr>
	<tr>
		<td class="nb" style="text-align: right">X Y ×</td>
		<td class="nb"  style="text-align:center"><b><span class="transform">→</span></b></td>
		<td class="nb">X 
		<u>(Extend | Format)*</u> 
        Y <u>(Extend | Format)*</u> 
        	×</td>
	</tr>
	<tr>
		<td class="nb" colspan="3">
		<p class="rule">An alternate expression that resolves to a single 
		character is treated as a 
    whole. For example:</td>
	</tr>
		<tr>
			<th class="nb" style="text-align: right">Original</th>
			<th class="nb" style="text-align:center"><span class="transform">→</span></th>
			<th class="nb">Modified</th>
		</tr>
		<tr>
			<td class="nb">
			<p style="text-align: right">(STerm | ATerm)</td>
			<td class="nb" style="text-align:center"><b><span class="transform">→</span></b></td>
			<td class="nb">(STerm | ATerm)
			<u>(Extend | 
      Format)*</u></td>
		</tr>
		<tr>
			<td class="nb">
			<p style="text-align: right"><i><b>not</b></i></td>
			<td class="nb" style="text-align:center"><b><span class="transform">→</span></b></td>
			<td class="nb">(STerm <u>(Extend | Format)*</u> 
			| ATerm <u>(Extend | Format)*</u>)</td>
		</tr>
	</table>
  <p>The Ignore rules should not be overridden by tailorings, with the 
  possible exception of remapping some of the Format characters to other classes.</p>
  <h3 class="section">6.3 <a name="Regular_Expressions">Regular Expressions</a></h3>
  <p>The preceding rules can be converted into a regular expression that will produce the same results. 
  The regular expression must be evaluated starting at a known boundary (such as the start of the 
  text) and take the longest match (except in the case of sentence boundaries, where the shortest 
  match needs to be used).</p>
  <p>The conversion into a regular expression is fairly straightforward, although it takes a little 
  thought. For example, the Default Grapheme Cluster 
  Boundaries&nbsp; of <i> <a href="tr29-11.html#Default_Grapheme_Cluster_Table">Table 1</a> 
	</i>can be transformed into the following regular expression:</p>
    <div class="book-only"><p>&nbsp;</p></div>
<blockquote>
    <p><span class="charlist">&nbsp; Control<br>
    | CR LF<br>
    | ( ¬Control? | L+ | T+ | L* ( LV? V+ | LV | LVT ) T* ) Extend*</span></p>
  </blockquote>
  <p>Such a regular expression can also be turned into a fast deterministic finite-state machine. 
  For more information on Unicode Regular Expressions, see
  Unicode Technical Standard #18, “Unicode Regular Expressions” [<a href="../tr41/tr41-1.html#UTS18">UTS18</a>].</p>
  <h3 class="section"><a name="Random_Access">6.4 Random Access</a></h3>
  <p>A further complication is introduced by random access. When iterating through a string from 
  beginning to end, a regular expression or state machine works well. From each boundary to find the 
  next boundary is very fast. By constructing a state table for the reverse direction from the same 
  specification of the rules, reverse iteration is possible.</p>
  <p>However, suppose that the user wants to iterate starting at a random point in the text, or 
  detect whether a random point in the text is a boundary. If the starting point does not provide 
  enough context to allow the correct set of rules to be applied, then one could fail to find a 
  valid boundary point. For example, suppose a user clicked after the first space after the question 
  mark in “Are_you_there? _ _ No,_I&#x2019;m_not”. On a forward iteration searching for a sentence 
  boundary, one would fail to find the boundary before the “N”, because the “?” had 
	not been seen 
  yet.</p>
  <p>A second set of rules to determine a “safe” starting point provides a solution. Iterate 
  backward with this second set of rules until a safe starting point is located, then iterate 
  forward from there. Iterate forward to find boundaries that were located between the safe point 
  and the starting point; discard these. The desired boundary is the first one that is not less than 
  the starting point. The safe rules must be designed so that they function correctly no matter what 
  the starting point is, so they have to be conservative in terms of finding boundaries, 
	and only find those boundaries that can be determined by a small context (a 
	few neighboring characters).</p>
  <p class="caption">Figure 3. <span style="font-weight: 400">Random Access</span></p>
  <div class="web-only">
  <p align="center" style="text-align: center"><img src="images/random_access.jpg" alt="random access diagram"></p>
  </div><div class="book-only">
  <p align="center" style="text-align: center"><img src="print-images/random_access.jpg" alt="random acces diagram" width="181" height="109"></p>
  </div>
  <p>This process would represent a significant performance cost if it had to be performed on every 
  search. However, this functionality can be wrapped up in an iterator object, which preserves the 
  information regarding whether it currently is at a valid boundary point. Only if it is reset to an 
  arbitrary location in the text is this extra backup processing performed. The iterator may even 
  cache local values that it has already traversed.</p>
  <h3 class="section">6.5 <a name="Tailoring">Tailoring</a></h3>
  <p>Rule-based implementation can also be combined with a 
  code-based or table-based tailoring mechanism. For typical state machine 
  implementations, for example, a Unicode character is 
  typically passed to a mapping table that maps characters to boundary property values. This mapping 
  can use an efficient mechanism such as a trie. Once a boundary property value is produced, it 
  is passed to the state machine.</p>
  <p>The simplest customization is to adjust the values coming out of the character mapping 
  table. For example, to mark the appropriate quotation marks for a given language as having the 
  sentence boundary property value Close, artificial property values can be introduced for different 
  quotation marks. A table can be applied after the main mapping table to map those artificial 
  character property values to the real ones. To change languages, a different small table is 
  substituted. The only real cost is then an extra array lookup.</p>
  <p>For code-based tailoring a different special range of property values can be added. The state 
  machine is set up so that any special property value causes the state machine to halt and return 
  a particular exception value. When this exception value is detected, the higher-level process can 
  call specialized code according to whatever the exceptional value is. This can all be encapsulated 
  so that it is transparent to the caller.</p>
  <p>For example, Thai characters can be mapped to a special property value. When the state machine 
  halts for one of these values, then a Thai word break implementation
  is invoked internally, to produce boundaries within the subsequent string of Thai 
  characters. These boundaries can then be cached so that subsequent calls for next 
	or previous 
  boundaries merely return the cached values. Similarly Lao characters can be mapped to a different 
  special property value, causing a different implementation to be 
  invoked.</p>
  <h2 class="section">7 <a name="Testing">Testing</a></h2>
  <p>There is no requirement that Unicode-conformant implementations implement these default 
  boundaries. As with the other default specifications, implementations are also free to override 
  (tailor) the results to meet the requirements of different environments or particular languages. 
  For those who do implement the default boundaries as specified in this annex, and wish to check that that 
  their implementation matches that specification, three test files have been made available 
  in [<a href="../tr41/tr41-1.html#Tests29">Tests29</a>].</p>
  <p>These tests cannot be exhaustive, because of the large number of possible 
	combinations; but they do provide 
  samples that test all pairs of property values, using a representative character for each value, 
  plus certain other sequences.</p>
  <p>A sample HTML file is also available for each that shows various combinations in chart form, 
  in [<a href="../tr41/tr41-1.html#Charts29">Charts29</a>]. The header cells of the chart consist of a property 
  value, followed by a representative code point number. The body cells in the chart show the <i>
  break status</i>: whether a break occurs between the row property value and the column property 
  value. If the browser supports tool-tips, then hovering the mouse over the code point number will 
  show the character name, General_Category, Line_Break, and Script property values. Hovering over 
  the break status will display the number of the rule responsible for that status.</p>
  <blockquote>
    <p><span class="note">Note:</span> To determine a boundary it is <i>not</i> sufficient to just 
    test the two adjacent characters, except for the case of the default grapheme clusters.</p>
  </blockquote>
  <p>The chart may be followed by some test cases. These test cases consist of various strings with 
  the break status between each pair of characters shown by blue lines for breaks and 
	by whitespace 
  for non-breaks. Hovering over each character (with tool-tips enabled) shows the character name and 
  property value; hovering over the break status shows the number of the rule responsible for that 
  status.</p>
	<p>Due to the way they have been mechanically processed for generation, the 
	test rules do not match the rules in this annex precisely. In particular:</p>
	<ol>
		<li>The rules are cast into a more regex-style.</li>
		<li>The rules “sot ÷”, “÷ eot”, and “÷ Any” are added mechanically and 
		have artificial numbers. </li>
		<li>The rules are given decimal numbers without prefix, so rules such as 
		WB13a are given 
		a number using tenths, such as 13.1.</li>
		<li>Where a rule has multiple parts (lines), each one is numbered using 
		hundredths, such as<ul>
			<li>21.01) × $BA</li>
			<li>21.02) × $HY</li>
			<li>...</li>
		</ul>
		</li>
		<li>Any “treat as” or “ignore” rules are handled as discussed in this annex, and thus 
		reflected in a transformation of the rules not visible in the tests.</li>
	</ol>
	<p>The mapping from the rule numbering in this annex to the numbering for 
	the test rules is 
	summarized in <i>Table 5.</i></p>	<div class="center"><center><p class="caption">Table 5.
	<span style="font-weight: 400">Numbering of Rules</span></p>    

	<table border="1" cellpadding="2" cellspacing="0" id="table5">
	<tr>
		<th>Rule in This Annex</th>
		<th>Test Rule</th>
		<th>Comment</th>
	</tr>
	<tr>
		<td align="right">xx1</td>
		<td align="right">0.1</td>
		<td>start of text</td>
	</tr>
	<tr>
		<td align="right">xx2</td>
		<td align="right">0.2</td>
		<td>end of text</td>
	</tr>
	<tr>
		<td align="right">SB8a</td>
		<td align="right">8.1</td>
		<td rowspan="3" style="vertical-align: middle">letter style</td>
	</tr>
	<tr>
		<td align="right">WB13a</td>
		<td align="right">13.1</td>
	</tr>
	<tr>
		<td align="right">WB13b</td>
		<td align="right">13.2</td>
	</tr>
	<tr>
		<td align="right">GB10</td>
		<td align="right" rowspan="2" style="vertical-align: middle">
		999</td>
		<td rowspan="2" style="vertical-align: middle">any&nbsp; </td>
	</tr>
	<tr>
		<td align="right">WB14</td>
	</tr>
	</table>
	</center></div><br>
  <h2 class="nonumber"><a name="Acknowledgments">Acknowledgments</a></h2>
  <div class="book-only">
  <p>Mark Davis is the author of the initial version and has added to and 
	maintained the text of this annex.</p></div>
	<p>Thanks to Julie Allen, Asmus Freytag, Ted Hopp, Andy Heninger, Michael Kaplan, Steve Tolkin, Ken Whistler, and Eric Mader 
  for their feedback on this annex, including earlier versions.</p>
  <h2 class="nonumber"><a name="References">References</a></h2>
    <p>For references for this annex, see Unicode Standard Annex #41, “<a href="../tr41/tr41-1.html">Common 
	References for Unicode Standard Annexes</a>.”</p>
  <h2 class="nonumber"><a name="Modifications">Modifications</a></h2>
	<!-- BOOK ONLY -->
	<div class="book-only">
	<p>For details of the change history, see the online copy of this annex at http://www.unicode.org/reports/tr29/.</p>
	</div>
  <!--START WEB ONLY></START-->
  <div class="web-only">
  <p>The following summarizes modifications from the previous versions of this 
	annex.</p>
  <h3>Revision 11.</h3>
  <ul>
	<li>Removed NBSP from ALetter.</li>
	<li>Added note on problem with Sentence Break rules SB8 and SB11.</li>
    <li>Changed table format, minor edits.</li>
	<li>Cleaned up description of how to handle Ignore Rules</li>
	<li>Added more details on the test file formats (for the html files).</li>
	<li>Added note about identifiers and natural language.</li>
	<li>Added reference to LDML/CLDR.</li>
	<li>Modified GC treatment to 
    use the equivalent (but more straightforward) use of Extend* in Section 4,&nbsp;<i><a href="tr29-11.html#Word_Boundaries">Word 
    Boundaries</a></i>, and Section 5,&nbsp;<i><a href="tr29-11.html#Sentence_Boundaries">Sentence 
    Boundaries</a></i>. (This is equivalent because breaks are 
    not allowed within Hangul syllables by the other rules anyway.) Also unify the application of 
    Extend*&nbsp; and Format*. This combines two rules into one in each set of rules (former 3 and 4 
    in Word Boundaries, 4 and 5 in Sentence Boundaries).</li>
	<li>Clarified how to apply “ignore” rules in Section 6.2,&nbsp;<i><a href="tr29-11.html#Grapheme_Cluster_and_Format_Rules">Grapheme 
    Cluster and Format Rules</a></i>, and combined Extend and Format</li>
	<li>Added “Do not break within CRLF” to Section 4,&nbsp;<i><a href="tr29-11.html#Word_Boundaries">Word 
    Boundaries</a></i>, and Section 5,&nbsp;<i><a href="tr29-11.html#Sentence_Boundaries">Sentence Boundaries</a></i>.</li>
	<li>Added 8a in Section 5,&nbsp;<i><a href="tr29-11.html#Sentence_Boundaries">Sentence Boundaries</a></i>, 
    to address an edge condition and fix a typo in #10.</li>
	<li>Replaced “user character” by “user-perceived character”.</li>
	<li>Reformed ALetter in Section 4,&nbsp;<i><a href="tr29-11.html#Word_Boundaries">Word 
    Boundaries</a></i>, to depend on LineBreak. Fixed references within properties.</li>
	<li>Removed Rule 0 of Section 4,&nbsp;<i><a href="tr29-11.html#Word_Boundaries">Word 
    Boundaries</a>.</i></li>
	<li>Clarified discussion of NFD, spelling checkers, and cleaned up 
    language around “engines” and “state machines” vs “implementations”.</li>
  </ul>
	<p>Revision 10 being a proposed update, only changes between versions 11 and 
	9 are noted here.</p>
  <h3>Revision 9.</h3>
  <ul>
    <li>Reworded introduction slightly, moved last half of Notation into the introduction.</li>
    <li>Added line above each boundary property value table pointing to the data files for the 
    precise definition of the properties.</li>
    <li>Added note to clarify that grapheme clusters are not broken in word or sentence boundaries.</li>
    <li>Clarified examples in <i>“1. Single boundaries”.</i></li>
    <li>Added pointer to UTS #10</li>
    <li>Change the “and not” formulation for clarity.<ul>
      <li>“and not X = true”<span class="mathsym3">→</span> “and X = false”</li>
      <li>“and not X = Y”<span class="mathsym3">→</span> “and X
      <span class="mathsym2">≠</span> Y”</li>
    </ul>
    </li>
  </ul>
  <p><b>Revision 8.</b></p>
  <ul>
    <li>Modified the tables so as to make the property values orthogonal.</li>
    <li>Added Joiner/Non-Joiner.</li>
    <li>Added additional katakana characters.</li>
    <li>Removed MidNumLet, and added ExtendedNumLet (with corresponding changes to the rules).</li>
    <li>Moved the test files to the references.</li>
    <li>Fixed up the property file references.</li>
  </ul>
  <p><b>Revision 7.</b></p>
  <ul>
    <li>Incorporated corrigendum for Hangul_Syllable_Type=L explanation, and adjusted for the 
    change in status of the Joiner characters.</li>
    <li>Added override for CB, SA, SG, and XX in wordbreak.</li>
    <li>Added “Any” entries, and note about precedence.</li>
    <li>Added NBSP, and removed GRAPHEME EXTEND = true from the “alphabetics”.</li>
    <li>Added data files with explicit property values.</li>
  </ul>
  <h3>Revision 6.</h3>
  <ul>
    <li>Changed <a href="tr29-11.html#STerm">Term</a> to be the 4.0.1 UCD property STerm. Note: the new property 
    provides minor corrections as well.</li>
  </ul>
  <h3>Revision 4.</h3>
  <ul>
    <li>
    <p>Updated boilerplate.</li>
    <li>
    <p>Use the Grapheme_Extend property. Dropped note on Other_Grapheme_Extend, 
    because those changes are in UCD 4.0.0</li>
    <li>
    <p>Deleted note on relation to 3.0 text. Replace reference to 3.2 with one 
    to 4.0.</li>
    <li>
    <p>Replaced the lists of Korean chars by reference to the 
    Hangul_Syllable_Type, with the lists kept as examples. Added reference to the UCD.</li>
    <li>
    <p>Simplified ALetter and OLetter, because some characters are changing from 
    Sk to Lm, and thus get included; other Sk are not really candidates for words.</li>
    <li>
    <p>Subtracted characters from certain classes so they wouldn&#x2019;t overlap:
    <ul>
      <li>
      <p>CR and LF from Control in Grapheme Break</li>
      <li>
      <p>Soft hyphen from MidLetter in Word Break (because it is Cf in 4.0)</li>
      <li>
      <p>ATerm, Term and <span class="charlist"></span><span class="name">GERESH</span> from Close in 
      Sentence Break</li>
    </ul>
    </li>
    <li>
    <p>Added note about finite-state machine; highlighted notes about adjacent 
    characters.</li>
    <li>
    <p>Fixed the term “interior” (didn&#x2019;t match the rules); and some character 
    names.</li>
  </ul>
  <h3>Revision 3.</h3>
  <ul>
    <li>Removal of two open issues, resolved by UTC</li>
    <li>Changed name of “character class” to “property value” for consistency</li>
    <li>Other_Grapheme_Extend now includes characters for canonical closure</li>
    <li>Minor changes to some other property values</li>
    <li>Some additional notes on tailoring words for French, Italian, and Hebrew</li>
    <li>Added Section 7, <i><a href="tr29-11.html#Testing">Testing</a>.</i></li>
    <li>Minor editing.</li>
  </ul>
  <h3>Revision 2.</h3>
  <ul>
    <li>Simplified grapheme cluster.</li>
    <li>Handled format characters appropriately.</li>
    <li>Removed Hiragana × Hiragana from word break, as well as prefix/posfix for numbers (because 
    they should not block Whole-Word Search).</li>
    <li>Modified sentence break to catch edge conditions.</li>
    <li>Added conformance section, with more warnings throughout that these specifications need to 
    be tailored for different languages/orthographic conventions.</li>
    <li>Tightened up the specifications of the character classes.</li>
    <li>Clarified the rule process.</li>
    <li>Added explanations of the interaction with normalization.</li>
    <li>Added an implementation section (incorporating the previous Random Access section).</li>
  </ul>
  <hr width="50%">
  <p class="copyright">Copyright © 2000-2006 Unicode, Inc. All Rights 
  Reserved. The Unicode Consortium makes no expressed or implied warranty of any kind, and assumes 
  no liability for errors or omissions. No liability is assumed for incidental and consequential 
  damages in connection with or arising out of the use of the information or programs contained or 
  accompanying this technical report. The Unicode <a href="http://www.unicode.org/copyright.html">
  Terms of Use</a> apply.</p>
  <p class="copyright">Unicode and the Unicode logo are trademarks of Unicode, Inc., and are 
  registered in some jurisdictions.</p>
  </div> <!-- WEB ONLY -->
 </div> <!-- BODY -->
</div> <!-- BOOK -->

</body>

</html>