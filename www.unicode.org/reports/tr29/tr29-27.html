<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<title>UAX #29: Unicode Text Segmentation</title>
<link rel="stylesheet" type="text/css" href="../reports-v2.css">
</head>
<body>
<table class="header" width="100%">
  <tr>
    <td class="icon"><a href="http://www.unicode.org">
    <img align="middle" alt="[Unicode]" border="0" src="../../webscripts/logo60s2.gif" width="34" height="33"></a>&nbsp;&nbsp;<a class="bar" href="../index.html">Technical 
    Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>
</table>
<div class="body">
	<h2 class="uaxtitle">Unicode® Standard Annex #29</h2>
  <h1>Unicode Text Segmentation</h1>
  
  <table class="simple" width="90%">
    <tr>
      <td valign="top" width="20%">Version</td>
      <td valign="top">Unicode 8.0.0</td>
    </tr>
    <tr>
      <td valign="top">Editors</td>
      <td valign="top"><a href="https://plus.google.com/114199149796022210033?rel=author">Mark Davis</a> (<a href="mailto:markdavis@google.com">markdavis@google.com</a>), 
        Laurențiu Iancu (<a href="mailto:liancu@unicode.org">liancu@unicode.org</a>)</td>
    </tr>
    <tr>
      <td valign="top">Date</td>
      <td valign="top">2015-06-01</td>
    </tr>
    <tr>
      <td valign="top">This Version</td>
      <td valign="top">
      	<a href="tr29-27.html">http://www.unicode.org/reports/tr29/tr29-27.html</a></td>
    </tr>
    <tr>
      <td valign="top">Previous Version</td>
      <td valign="top">
      	<a href="tr29-25.html">http://www.unicode.org/reports/tr29/tr29-25.html</a></td>
    </tr>
    <tr>
      <td valign="top">Latest Version</td>
      <td valign="top"><a href="../tr29.1">http://www.unicode.org/reports/tr29/</a></td>
    </tr>
    <tr>
      <td valign="top">Latest Proposed Update</td>
      <td valign="top"><a href="proposed.html">
      http://www.unicode.org/reports/tr29/proposed.html</a></td>
    </tr>
    <tr>
      <td valign="top">Revision</td>
      <td valign="top"><a href="tr29-27.html#Modifications">27</a></td>
    </tr>
  </table>
  
  <h4 class="summary">Summary</h4>
  <p><i>This annex describes guidelines for determining default 
	segmentation boundaries between certain 
  significant text elements: grapheme clusters (“user-perceived characters”), words, and sentences. 
  For line boundaries, see [<a href="../tr41/tr41-17.html#UAX14">UAX14</a>]</i>.</p>
  
 <h4 class="status">Status</h4>
 
	  <!-- NOT YET APPROVED -->
	  <!-- <p class="changed"><i>This is a<b><font color="#ff3333"> draft </font></b>document which 
      may be updated, replaced, or superseded by other documents at any time. 
      Publication does not imply endorsement by the Unicode Consortium. This is 
      not a stable document; it is inappropriate to cite this document as other 
      than a work in progress.</i></p> -->
      <!-- END NOT YET APPROVED -->
	  <!-- APPROVED --> 
      <p><i>This document has been reviewed by Unicode members and other 
	  interested parties, and has been approved for publication by the Unicode 
	  Consortium. This is a stable document and may be used as reference 
	  material or cited as a normative reference by other specifications.</i></p>
      <!-- END APPROVED -->

  <blockquote>
    <p><i><b>A Unicode Standard Annex (UAX)</b> forms an integral part of the 
	Unicode Standard, but is published online as a separate document. The 
	Unicode Standard may require conformance to normative content in a Unicode 
	Standard Annex, if so specified in the Conformance chapter of that version 
	of the Unicode Standard. The version number of a UAX document corresponds to 
	the version of the Unicode Standard of which it forms a part.</i></p>
  </blockquote>
  <p><i>Please submit corrigenda and other comments with the online reporting 
  form [<a href="http://www.unicode.org/reporting.html">Feedback</a>]. 
  Related information that is useful in understanding this annex is found in Unicode Standard Annex #41, 
  “<a href="../tr41/tr41-17.html">Common References for Unicode Standard Annexes</a>.” 
  For the latest version of the Unicode Standard, see [<a href="http://www.unicode.org/versions/latest/">Unicode</a>]. 
  For a list of current Unicode Technical Reports, see [<a href="../index.html">Reports</a>]. 
  For more information about versions of the Unicode Standard, see [<a href="http://www.unicode.org/versions/">Versions</a>]. 
  For any errata which may apply to this annex, see [<a href="http://www.unicode.org/errata/">Errata</a>].</i></p>
  
  <h4 class="contents">Contents</h4>
		<ul class="toc">
			<li>1 <a href="tr29-27.html#Introduction">Introduction</a>
				<ul class="toc">
					<li>1.1 <a href="tr29-27.html#Notation">Notation</a></li>
				</ul>
			</li>
			<li>2 <a href="tr29-27.html#Conformance">Conformance</a></li>
			<li>3 <a href="tr29-27.html#Grapheme_Cluster_Boundaries">Grapheme Cluster Boundaries</a>
				<ul class="toc">
					<li>3.1 <a href="tr29-27.html#Default_Grapheme_Cluster_Table">Default Grapheme Cluster Boundary Specification</a>
						<ul class="toc">
							<li>3.1.1 <a href="tr29-27.html#Grapheme_Cluster_Boundary_Rules">Grapheme Cluster Boundary Rules</a></li>
						</ul>
					</li>
				</ul>
			</li>
			<li>4 <a href="tr29-27.html#Word_Boundaries">Word Boundaries</a>
				<ul class="toc">
					<li>4.1 <a href="tr29-27.html#Default_Word_Boundaries">Default Word Boundary Specification</a>
						<ul class="toc">
							<li>4.1.1 <a href="tr29-27.html#Word_Boundary_Rules">Word Boundary Rules</a></li>
						</ul>
					</li>
					<li>4.2 <a href="tr29-27.html#Name_Validation">Name Validation</a></li>
				</ul>
			</li>
			<li>5 <a href="tr29-27.html#Sentence_Boundaries">Sentence Boundaries</a>
				<ul class="toc">
					<li>5.1 <a href="tr29-27.html#Default_Sentence_Boundaries">Default Sentence Boundary Specification</a>
						<ul class="toc">
							<li>5.1.1 <a href="tr29-27.html#Sentence_Boundary_Rules">Sentence Boundary Rules</a></li>
						</ul>
					</li>
				</ul>
			</li>
			<li>6 <a href="tr29-27.html#Implementation_Notes">Implementation Notes</a>
				<ul class="toc">
					<li>6.1 <a href="tr29-27.html#Normalization">Normalization</a></li>
					<li>6.2 <a href="tr29-27.html#Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a></li>
					<li>6.3 <a href="tr29-27.html#Regular_Expressions">Regular Expressions</a></li>
					<li>6.4 <a href="tr29-27.html#Random_Access">Random Access</a></li>
					<li>6.5 <a href="tr29-27.html#Tailoring">Tailoring</a></li>
				</ul>
			</li>
			<li>7 <a href="tr29-27.html#Testing">Testing</a></li>
			<li>8 <a href="tr29-27.html#Hangul_Syllable_Boundary_Determination">Hangul Syllable Boundary Determination</a>
				<ul class="toc">
					<li>8.1 <a href="tr29-27.html#Standard_Korean_Syllables">Standard Korean Syllables</a></li>
					<li>8.2 <a href="tr29-27.html#Transforming_Into_SKS">Transforming into Standard Korean Syllables</a></li>
				</ul>
			</li>
			<li><a href="tr29-27.html#Acknowledgments">Acknowledgments</a></li>
			<li><a href="tr29-27.html#References">References</a></li>
			<li><a href="tr29-27.html#Modifications">Modifications</a></li>
		</ul>
  <hr>
  <h2>1 <a name="Introduction" href="tr29-27.html#Introduction">Introduction</a></h2>
  <p>This annex describes guidelines for determining default boundaries between 
	certain significant text elements: user-perceived 
	characters, words, and sentences. The process of boundary determination is 
	also called <i>segmentation</i>.</p>
  <p>A string of Unicode-encoded text often needs to be broken up into text elements 
  programmatically. Common examples of text elements include what users think of as characters, 
  words, lines (more precisely, where line breaks are allowed), and sentences. The precise 
  determination of text elements may vary according to orthographic conventions for a given script 
  or language. The goal of matching user perceptions cannot always be met exactly because the text 
  alone does not always contain enough information to unambiguously decide boundaries. For example, 
  the <em>period</em> (U+002E FULL STOP) 
	is used ambiguously, sometimes for end-of-sentence purposes, sometimes for 
	abbreviations, and sometimes for numbers. In most cases, however, 
	programmatic text boundaries can match user perceptions quite closely, 
	although sometimes the best that can be done is not to surprise the user. </p>
  <p>Rather than concentrate on algorithmically searching for text elements 
	(often called <i>segments</i>), a simpler 
  and more useful computation instead detects the <i>boundaries</i> (or <i>breaks</i>) 
  between those text elements. The determination of those boundaries is often critical to performance, so it is important to be able to make such a determination as 
  quickly as possible. (For a general discussion of text elements, see <i>Chapter 
	2, General Structure</i>, of [<a href="../tr41/tr41-17.html#Unicode">Unicode</a>].)</p>
  <p>The default boundary determination mechanism specified in this annex provides a 
  straightforward and efficient way to determine some of the most significant boundaries in text: 
  user-perceived characters, words, and sentences. 
	Boundaries used in line breaking (also called <em>word wrapping</em>) are defined in 
	[<a href="../tr41/tr41-17.html#UAX14">UAX14</a>].</p>
  <p>The sheer number of characters in the Unicode Standard, together with 
	its representational power, place 
  requirements on both the specification of text element boundaries and the underlying 
  implementation. The specification needs to allow the designation of large sets of characters 
  sharing the same characteristics (for example, uppercase letters), while the implementation must 
  provide quick access and matches to those large sets. The mechanism also must handle special 
  features of the Unicode Standard, such as nonspacing marks and conjoining jamos.</p>
  <p>The default boundary determination builds upon the uniform character representation of the 
  Unicode Standard, while handling the large number of characters and special features such as 
  nonspacing marks and conjoining jamos in an effective manner. As this mechanism lends itself to a 
  completely data-driven implementation, it can be tailored to particular orthographic conventions 
  or user preferences without recoding.</p>
  <p>As in other Unicode algorithms, these specifications provide a <i>logical</i> description of the 
  processes: implementations can achieve the same results without using code or data that follows 
  these rules step-by-step. In particular, many production-grade implementations will use a 
  state-table approach. In that case, the performance does not depend on the complexity or number of 
  rules. Rather, performance is only affected by the number of characters that may match <i>
  after</i> the boundary position in a rule that applies.</p>

  <h3>1.1 <a name="Notation" href="tr29-27.html#Notation">Notation</a></h3>
  <p>A boundary specification summarizes boundary property values used in that 
	specification, then lists the rules for boundary determinations in terms of 
	those property values. The summary is provided as a list, where each element 
	of the list is one of the following:</p>
  <ul>
    <li>A literal character</li>
    <li>A range of literal characters</li>
    <li>All characters satisfying a given condition, using properties defined in the Unicode 
    Character Database [<a href="../tr41/tr41-17.html#UCD">UCD</a>]:
    <ul style="list-style-type:none">
      <li>Non-Boolean property values are given as <i>&lt;property&gt; = &lt;property value&gt;</i>, such as 
      General_Category = Titlecase_Letter.</li>
      <li>Boolean properties are given as <i>&lt;property&gt; = Yes</i>, such as
      Uppercase = Yes.</li>
      <li>Other conditions are specified textually in terms of UCD properties.</li>
    </ul>
    </li>
    <li>Boolean combinations of the above</li>
    <li>Two special identifiers, <i>sot</i> and <i>eot</i>, standing for start and end of text, 
	respectively</li>
  </ul>
  <p>For example, the following is such a list:</p>
	<blockquote>
			<p>General_Category = Line_Separator, <em>or</em><br>
      General_Category = Paragraph_Separator, <em>or</em><br>
      General_Category = Control, <em>or</em><br>
      General_Category = Format<br>
			<i>and not</i> U+000D CARRIAGE RETURN (CR)<br>
			<i>and not</i> U+000A LINE FEED (LF)<br>
			<i>and not</i> U+200C ZERO WIDTH NON-JOINER (ZWNJ)<br>
      <i>and not</i> U+200D ZERO WIDTH JOINER (ZWJ)</p>
	</blockquote>
  <p>In the table assigning the boundary property values, all of the values are intended to be 
  disjoint except for the special value <b>Any</b>. In case of conflict, rows higher in the table 
  have precedence in terms of assigning property values to characters. Data files containing 
  explicit assignments of the property values are found in [<a href="../tr41/tr41-17.html#Props0">Props</a>].</p>
  <p>Boundary determination is specified in terms of an ordered list of rules, 
	indicating the status of a boundary position. The rules are numbered for reference and are applied in sequence to determine whether 
  there is a boundary at any given offset. That is, there is an implicit “otherwise” at the front of 
  each rule following the first. The rules are processed from top to bottom. As soon as 
  a rule matches and produces a boundary status (boundary or no boundary) for that offset, the 
  process is terminated. </p>
  <p>Each rule consists of a left side, a boundary symbol (see <a href="tr29-27.html#Table_Boundary_Symbols"><em>Table 1</em></a>), and a right side. Either of the sides can 
  be empty. The left and right sides use the boundary property values in regular expressions. 
	The regular expression syntax used is a simplified version of the format 
	supplied in <em>Unicode Technical Standard #18, Unicode Regular Expressions</em>
	[<a href="../tr41/tr41-17.html#RegEx">RegEx</a>].</p>
  <p class="caption">Table 1. <a name="Table_Boundary_Symbols" href="tr29-27.html#Table_Boundary_Symbols">Boundary Symbols</a></p>
  <div align="center">
  <table class="simple">
    <tr>
      <td>÷</td>
      <td>Boundary (allow break here)</td>
    </tr>
    <tr>
      <td>×</td>
      <td>No boundary (do not allow break here)</td>
    </tr>
    <tr>
      <td>→</td>
      <td>Treat whatever on the left side as if it were what is on the right side</td>
    </tr>
  </table>
  </div>

  <p>An <i>underscore</i> (“_”) is used to indicate a space in examples.</p>
  <p>These rules are constrained in three ways, to make implementations significantly simpler and more efficient. 
	These constraints have not been found to be limitations for natural language use. In 
  particular, the rules are formulated so that they can be 
  efficiently implemented, such as 
  with a deterministic finite-state machine based on a small number of property values.</p>
  <ol>
    <li><i>Single boundaries.</i> Each rule has exactly one boundary position. This restriction is 
    more a limitation on the specification methods, because a rule with multiple boundaries could 
    be expressed instead as multiple rules. For example:<ul style="list-style-type:none">
      <li>“a b ÷ c d ÷ e f” could be broken into two rules “a b ÷ c d e f” and “a b c d ÷ e f”</li>
      <li>“a b × c d × e f” could be broken into two rules “a b × c d e f” and “a b c d × e f”</li>
    </ul>
    </li>
    <li><i>Ignore degenerates.</i> No special provisions are made to get marginally better behavior 
    for degenerate cases that never occur in practice, such as an <i>A</i> followed by an Indic 
    combining mark.</li>
	<li><i>Limited negation.</i> Negation of expressions is limited to instances 
	that resolve to a match against single characters, such as “¬(OLetter | 
	Upper | Lower | Sep)”.</li>
  </ol>

  <h2>2 <a name="Conformance" href="tr29-27.html#Conformance">Conformance</a></h2>
  <p>There are many different ways to divide text elements 
  corresponding to user-perceived 
	characters, words, and sentences, and the Unicode Standard 
	does not restrict the ways in which implementations can produce these 
	divisions.</p>
  <p>This specification defines <i>default</i> mechanisms; more sophisticated 
  implementations can <i>and should</i> tailor them for particular locales or environments. For 
  example, reliable detection of word boundaries 
	in languages such as Thai, Lao, Chinese, or Japanese requires the use of dictionary 
  lookup, analogous to English hyphenation. An implementation therefore may need to provide means to 
  override or subclass the default mechanisms 
  described in this annex. Note that tailoring can <i>
  either</i> add boundary positions <i>or</i> remove boundary positions, compared to the defaults 
  specified here.</p>
  <blockquote>
    <p><span class="note">Note:</span> Locale-sensitive boundary specifications,
    including boundary suppressions,
    can be expressed in LDML [<a href="../tr41/tr41-17.html#UTS35">UTS35</a>].
    Tailorings are available in the Common Locale Data Repository
    [<a href="../tr41/tr41-17.html#CLDR">CLDR</a>].</p>
  </blockquote>
  <p>To maintain canonical equivalence, all of the following specifications are defined on 
	text normalized in form NFD, 
  as defined in Unicode Standard Annex #15, &#x201C;Unicode Normalization Forms&#x201D; 
  [<a href="../tr41/tr41-17.html#UAX15">UAX15</a>]. A boundary exists in 
	text not 
	normalized in form NFD if and only if it would occur at 
  the corresponding position in NFD text. However, the default rules have 
  been written to provide equivalent results for non-NFD text and can be applied directly. Even in 
  the case of tailored rules, the requirement to use NFD is only a logical specification; in 
  practice, implementations can avoid normalization and achieve the same results. For more 
  information, see <span class="section">Section </span><span class="secno">6,</span> <a href="tr29-27.html#Implementation_Notes"><i>Implementation Notes</i></a>.</p>
  <h2>3 <a name="Grapheme_Cluster_Boundaries" href="tr29-27.html#Grapheme_Cluster_Boundaries">Grapheme Cluster Boundaries</a></h2>
	<p>It is important to recognize that what the user 
	thinks of as a “character”—a basic unit of a 
	writing system for a language—may not be just a single Unicode code point. 
	Instead, that basic unit may be made up of multiple Unicode code points. To avoid ambiguity with the computer use of the term <i>character,</i> this is 
	called a <i>user-perceived character</i>. For example, “G” + <i>acute-accent</i> is a 
	<i>user-perceived character</i>: users think of it as a single character, yet is 
	actually represented by two Unicode code points. 
	These user-perceived characters are approximated by what is called a <i>grapheme cluster</i>, 
	which can be determined programmatically.</p>
	<p>Grapheme cluster boundaries are 
	important for collation, regular expressions, UI 
	interactions (such as mouse selection, arrow key movement, backspacing), 
	segmentation for vertical text, identification of boundaries for 
	first-letter styling, and counting “character” positions within text. 
	Word boundaries, line boundaries, and sentence boundaries 
	should not occur within a grapheme 
	cluster: in other words, a grapheme cluster should 
	be an atomic unit with 
	respect to the process of determining these other boundaries.</p>
  <p>As far as a user is concerned, the underlying representation of text is not 
	important, but it is important that an editing interface present a uniform 
	implementation of what the user thinks of as characters. Grapheme clusters 
	commonly behave as units in terms of mouse selection, arrow key movement, 
	backspacing, and so on. For example, when a 
	grapheme cluster is represented
	internally by a character sequence
	consisting of base character + accents, then using the right arrow key would skip from 
  the start of the base character to the end of the last accent.</p>
  <p>However, in some cases editing a grapheme cluster element by element may be 
	preferable. 
  For example, on a given system the <i>backspace key</i> might delete by code point, while the <i>delete 
  key</i>
  may delete an entire cluster. Moreover, there is not a one-to-one relationship between 
  grapheme clusters and keys on a keyboard. A single key on a keyboard may correspond to a whole 
  grapheme cluster, a part of a grapheme cluster, or a sequence of more than one grapheme cluster.</p>
  <p>In those relatively rare circumstances where programmers need to supply end 
	users 
	with user-perceived character counts, the counts should correspond 
  to the number of segments delimited by grapheme cluster boundaries. Grapheme clusters<i> 
	may also be</i> used in searching and matching; for 
  more information, see Unicode Technical Standard #10, &#x201C;Unicode Collation Algorithm&#x201D; 
	[<a href="../tr41/tr41-17.html#UTS10">UTS10</a>], and Unicode Technical Standard #18, &#x201C;Unicode 
	Regular Expressions&#x201D; 
	[<a href="../tr41/tr41-17.html#UTS18">UTS18</a>].</p>
	<p>The Unicode Standard provides default 
	algorithms for determining grapheme cluster boundaries, with two variants:
	<b><i>legacy grapheme 
	clusters</i></b> and <b><i>extended grapheme clusters</i></b>.
	The most appropriate variant depends on the language and operation involved. However, the 
	extended grapheme cluster boundaries are recommended for general processing, 
	while the legacy grapheme cluster boundaries are maintained primarily for backwards 
	compatibility with earlier versions of this specification.</p>
	<p>These algorithms can be adapted to produce <b>
	<i>tailored grapheme clusters </i></b>for 
  specific locales or other customizations, such as the contractions used in collation tailoring tables. 
	In <a href="tr29-27.html#Table_Sample_Grapheme_Clusters"><em>Table 1a</em></a> are some examples of the differences between these concepts. The tailored 
	examples are only for illustration: what constitutes a grapheme cluster will 
depend on the customizations used by the particular tailoring in question.</p>
	<p class="caption">Table 1a. <a name="Table_Sample_Grapheme_Clusters" href="tr29-27.html#Table_Sample_Grapheme_Clusters">Sample Grapheme Clusters</a></p>
  <div align="center">   
  <table class="subtle"> 
	<tr>
      <th>Ex</th>
      <th width="40%">Characters</th>
      <th>Comments</th>
    </tr>
    <tr>
      <td class="lightgray" colspan="3"><i>Grapheme clusters (both legacy and extended)</i></td>
    </tr>
    <tr>
      <td>g̈</td>
      <td>0067 (&nbsp;g&nbsp;) LATIN SMALL LETTER G<br>
	  0308 (&nbsp;&#x25CC;&#x0308;&nbsp;) COMBINING DIAERESIS</td>
      <td valign="top">combining character sequences</td>
    </tr>
    <tr>
      <td rowspan="2">각</td>
      <td>AC01 (&nbsp;각&nbsp;) HANGUL SYLLABLE GAG</td>
      <td valign="top" rowspan="2">Hangul syllables such as<i> 
		gag</i> (which may be a single character, or a sequence of 
		conjoining jamos)</td>
    </tr>
    <tr>
      <td>1100 (&nbsp;ᄀ&nbsp;) HANGUL CHOSEONG KIYEOK<br>
        1161 (&nbsp;ᅡ&nbsp;) HANGUL JUNGSEONG A<br>
        11A8 (&nbsp;ᆨ&nbsp;) HANGUL JONGSEONG KIYEOK</td>
    </tr>
    <tr>
      <td>ก</td>
      <td>0E01 (&nbsp;ก&nbsp;) THAI CHARACTER KO KAI</td>
      <td valign="top">Thai <i>ko</i></td>
    </tr>
    <tr>
      <td class="lightgray" colspan="3"><i>Extended grapheme clusters</i></td>
    </tr>
    <tr>
      <td>நி </td>
      <td>0BA8 ( ந ) TAMIL LETTER NA<br>
	0BBF ( ி ) TAMIL VOWEL SIGN I</td>
      <td valign="top">Tamil <i>ni</i></td>
    </tr>
    <tr>
      <td>เ</td>
      <td>0E40 (&nbsp;เ&nbsp;) THAI CHARACTER SARA E</td>
      <td valign="top">Thai <i>e</i></td>
    </tr>
    <tr>
      <td>กำ</td>
      <td>0E01 (&nbsp;ก&nbsp;) THAI CHARACTER KO KAI<br>
        0E33 (&nbsp;ำ&nbsp;) THAI CHARACTER SARA AM</td>
      <td valign="top">Thai <i>kam</i></td>
    </tr>
    <tr>
      <td>षि</td>
      <td>0937 ( ष ) DEVANAGARI LETTER SSA<br>
		093F ( ि ) DEVANAGARI VOWEL SIGN I</td>
      <td valign="top">Devanagari <em>ssi</em></td>
    </tr>
    <tr>
      <td class="lightgray" colspan="3"><i>Legacy grapheme clusters</i></td>
    </tr>
    <tr>
      <td>ำ</td>
      <td>0E33 (&nbsp;ำ&nbsp;) THAI CHARACTER SARA AM</td>
      <td valign="top">Thai <i>am</i></td>
    </tr>
    <tr>
      <td>ष</td>
      <td>0937 ( ष ) DEVANAGARI LETTER SSA</td>
      <td valign="top">Devanagari <i>ssa</i></td>
    </tr>
    <tr>
      <td>ि</td>
      <td>093F ( ि ) DEVANAGARI VOWEL SIGN I</td>
      <td valign="top">Devanagari <i>i</i></td>
    </tr>
    <tr>
      <td class="lightgray" colspan="3"><i>Tailored grapheme clusters</i></td>
    </tr>
    <tr>
      <td>ch</td>
      <td>0063 (&nbsp;c&nbsp;) LATIN SMALL LETTER C<br>
	0068 (&nbsp;h&nbsp;) LATIN SMALL LETTER H</td>
      <td valign="top">Slovak <i>ch</i> digraph</td>
    </tr>
    <tr>
      <td>k<sup>w</sup></td>
      <td>006B (&nbsp;k&nbsp;) LATIN SMALL LETTER K<br>
	02B7 (&nbsp;ʷ&nbsp;) MODIFIER LETTER SMALL W</td>
      <td valign="top">sequence with letter modifier</td>
    </tr>
    <tr>
      <td>क्षि</td>
      <td>0915 ( क ) DEVANAGARI LETTER KA<br>
	094D ( ् ) DEVANAGARI SIGN VIRAMA<br>
	0937 ( ष ) DEVANAGARI LETTER SSA<br>
	093F ( ि ) DEVANAGARI VOWEL SIGN I</td>
      <td valign="top">Devanagari <i>kshi</i></td>
    </tr>
    </table>
    </div>
	<p><i>See also: <a href="http://www.unicode.org/standard/where/">Where is my Character?</a>,
		and the UCD file <strong>NamedSequences.txt</strong> [<a href="../tr41/tr41-17.html#Data34">Data34</a>].</i></p>
	<p>A <b><i>legacy grapheme cluster</i></b> is defined as a base (such as A or カ) followed 
	by zero or more continuing characters. One way to think of this is as a sequence of 
	characters that form a “stack”.</p>
	<p>The base can be single 
	characters, or be any sequence of Hangul Jamo characters that 
	form a Hangul Syllable, as defined by D133 in The Unicode Standard, or be any sequence of Regional_Indicator (RI) characters. The RI characters are used in pairs to denote Emoji national flag symbols corresponding to ISO country codes. Sequences of more than two RI characters should be separated by other characters, such as U+200B ZERO WIDTH SPACE (ZWSP).</p>
	<p>The continuing characters include
	nonspacing marks, the Join_Controls (U+200C ZERO WIDTH NON-JOINER and U+200D ZERO WIDTH JOINER) used in Indic languages, and a few spacing 
	combining marks to ensure canonical equivalence. Additional cases need to be added for completeness, 
	so that any string of text can be divided up into a sequence of grapheme clusters. Some of these 
	may be <i>degenerate</i> cases, such as a control code, or an isolated combining mark.</p>
	<p>An <b><i>extended grapheme cluster</i></b> is the same as a legacy grapheme cluster, with the 
	addition of some other characters. The continuing characters are extended to 
	include all spacing combining marks, such as the spacing (but 
	dependent) vowel signs in Indic scripts. For 
	example, this includes U+093F (&nbsp;ि&nbsp;) DEVANAGARI VOWEL SIGN I.
	The extended grapheme clusters should be used in implementations in preference
	to legacy grapheme clusters, because they provide better results for Indic scripts such as Tamil or
	Devanagari in which editing by orthographic syllable is typically preferred. For scripts such as Thai,
	Lao, and certain other Southeast Asian scripts, editing by visual unit is typically preferred, so for
	those scripts the behavior of extended grapheme clusters is similar to (but not identical to) the
	behavior of legacy grapheme clusters.</p>
  <p>For the rules defining the boundaries for grapheme clusters, 
  see <i><a href="tr29-27.html#Default_Grapheme_Cluster_Table">Section 3.1</a></i>. For more information on the composition of Hangul 
	syllables, 
  see <i>Chapter 3, Conformance</i>, of [<a href="../tr41/tr41-17.html#Unicode">Unicode</a>].</p>
  <blockquote>
    <p><i>Note: The boundary between default Unicode grapheme clusters can be 
    determined by just the two adjacent characters. See Section 7, <a href="tr29-27.html#Testing">Testing</a>, 
    for a chart showing the interactions of pairs of characters.</i></p>
  </blockquote>
	<p>A key feature of default 
	Unicode grapheme clusters 
	(both legacy and extended) is that they remain 
	unchanged across all canonically equivalent forms of the underlying text. Thus the boundaries 
	remain unchanged whether the text is in NFC or NFD. Using a grapheme cluster 
	as the fundamental unit of matching thus provides a very clear and easily 
	explained basis for canonically equivalent matching. This is important for 
	applications from searching to regular expressions.</p>
	<p>Another key feature is that 
	default Unicode grapheme clusters are atomic units with 
	respect to the process of determining the Unicode default word, and 
	sentence boundaries. They are usually—but not always—atomic units with respect to line boundaries: there are exceptions due to the special handling of spaces. For more information, see <em>Section 9.2  Legacy Support for Space Character as Base for Combining Marks</em> in [<a href="../tr41/tr41-17.html#UAX14">UAX14</a>].</p>
	<p>Grapheme clusters can be 
	tailored to meet further requirements. Such tailoring is permitted, but the 
	possible rules are outside of the scope of this document. One example of such a tailoring would be for the 
	<i>aksaras</i>,
or <i>orthographic syllables</i>, used in many Indic scripts. Aksaras usually consist of a consonant, sometimes with
an inherent vowel and sometimes followed by an explicit,
dependent vowel whose rendering may end up on any side
of the consonant letter base. Extended grapheme clusters
	include such simple combinations.
</p>
	<p>However, aksaras may also include
one or more additional prefixed consonants, typically with a <i>virama</i>
(halant) character between each pair of consonants in the sequence.
Such consonant cluster aksaras are not incorporated
into the default rules for extended grapheme clusters, in
part because not all such sequences are considered to
be single “characters” by users. Indic scripts vary considerably
in how they handle the rendering of such aksaras—in some
cases stacking them up into combined forms known as
consonant conjuncts, and in other cases stringing them out
horizontally, with visible renditions of the halant on
each consonant in the sequence. There is even greater
variability in how the typical liquid consonants (or “medials”),
<i>ya, ra, la,</i> and <i>wa</i>, are handled for display in combinations in
aksaras. So tailorings for aksaras may need to be
script-, language-, font-, or context-specific to be useful.	</p>
	<blockquote>
		<p><i>Note: Font-based information may be required to determine the appropriate unit to use for UI purposes, such as identification of 
		boundaries for first-letter paragraph styling. For example, such a unit 
		could be a ligature formed of two grapheme clusters, such as لا (Arabic </i>lam<i> + </i>alef<i>).</i></p>
	</blockquote>
	<p>The Unicode definitions of grapheme clusters are 
	defaults: not meant to exclude the use of 
	more sophisticated definitions of tailored grapheme clusters where 
	appropriate. Such definitions may more precisely match the user expectations 
	within individual languages for given processes. For example, “ch” may be 
	considered a grapheme cluster in Slovak, for processes such as collation. The default definitions are, however, designed to provide 
	a much more accurate match to overall user expectations for what the user 
	perceives of as <i>characters</i> than is provided by individual Unicode 
	code points.</p>
  <blockquote>
    <p><i>Note: The default Unicode grapheme 
	clusters were previously 
	referred to 
    as “locale-independent graphemes.” The term cluster is used to emphasize that the 
    term grapheme is used differently in linguistics. For simplicity and 
	to align terminology with Unicode Technical Standard #10, &#x201C;Unicode Collation Algorithm&#x201D; 
	[<a href="../tr41/tr41-17.html#UTS10">UTS10</a>], 
    the terms default and tailored are preferred over locale-independent 
    and locale-dependent, respectively.</i></p>
  </blockquote>
  <p><b><i>Display of Grapheme Clusters.</i></b> Grapheme clusters are not the 
	same as ligatures. For example, the grapheme cluster “ch” in Slovak is not 
	normally a ligature and, conversely, the ligature “fi” is not a grapheme 
	cluster. Default grapheme clusters do not necessarily reflect text display. 
	For example, the sequence &lt;f, i&gt; may be displayed as a single glyph on the 
	screen, but would still be two grapheme clusters.</p>
  <p>For information on the matching of grapheme clusters with regular 
	expressions, see Unicode Technical Standard #18, “Unicode Regular 
	Expressions” [<a href="../tr41/tr41-17.html#UTS18">UTS18</a>].</p>
  <p><b><i>Degenerate Cases.</i></b> The 
  default specifications are designed to be simple to implement, and provide an algorithmic 
  determination of grapheme clusters. However, they do <i>
  not</i> have to 
	cover edge cases that 
  will not occur in practice. For the purpose of segmentation, they may 
	also include degenerate cases that are not thought of as grapheme clusters, such as an isolated 
	control character or combining mark.  In this, they differ from the combining 
	character sequences and extended combining character sequences defined in 
	[<a href="../tr41/tr41-17.html#Unicode">Unicode</a>]. In addition, Unassigned  (Cn) 
  code points and Private_Use (Co) characters are given property values that  anticipate potential usage.</p>
	<p>For comparison, <i><a href="tr29-27.html#Table_Combining_Char_Sequences_and_Grapheme_Clusters">Table 1b</a></i> shows the relationship between 
	combining character sequences and grapheme clusters, using regex notation. Note that 
	given alternates (X|Y), the first match is taken.</p>
  <p class="caption">Table 1b. 
  <a name="Table_Combining_Char_Sequences_and_Grapheme_Clusters" href="tr29-27.html#Table_Combining_Char_Sequences_and_Grapheme_Clusters">Combining Character Sequences and Grapheme Clusters</a></p>
  <div align="center">

  <table class="subtle"> 
	<tr>
      <th width="20%">Term</th>
      <th width="40%">Regex</th>
      <th>Notes</th>
    </tr>
    <tr>
      <td>combining character sequence</td>
      <td><code>base? ( Mark | ZWJ | ZWNJ )+</code></td>
      <td>A single base character is <i>not</i> a 
		combining character sequence. 
		However, a single 
		combining mark <i>is</i> a (degenerate) combining character sequence.</td>
    </tr>
    <tr>
      <td>extended combining character sequence</td>
      <td><code>extended_base? ( Mark | ZWJ | ZWNJ )+</code></td>
      <td>extended_base includes Hangul Syllables</td>
    </tr>
    <tr>
      <td>legacy grapheme cluster</td>
      <td><code>( CRLF<br>
		  | ( RI-sequence | Hangul-Syllable | !Control )<br>
      Grapheme_Extend*<br>
  		| . )</code></td>
      <td>A single base character is a grapheme 
		cluster. Degenerate cases include any isolated non-base characters, 
		and non-base characters like controls.</td>
    </tr>
    <tr>
      <td>extended grapheme cluster</td>
      <td><code>( CRLF<br>
        | <b>Prepend*</b><br> 
        ( RI-sequence | Hangul-Syllable | !Control )<br>
        ( Grapheme_Extend | <b>SpacingMark</b> )*<br>
        | . )</code></td>
      <td>Extended grapheme clusters add prepending and spacing marks</td>
    </tr>
    </table>
    </div>

    <p> <a href="tr29-27.html#Table_Combining_Char_Sequences_and_Grapheme_Clusters"><em>Table 1b</em></a> uses several symbols defined in <a href="tr29-27.html#Regex_Definitions"><em>Table 1c</em></a>:</p>
     <p class="caption">Table 1c. 
  <a name="Regex_Definitions" href="tr29-27.html#Regex_Definitions">Regex Definitions</a></p>

   	<div align="center">

    <table class="simple">
      <tr>
        <td><code>CRLF</code></td>
        <td><code>:= CR LF</code></td>
      </tr>
      <tr>
        <td><code>RI-Sequence</code></td>
        <td><code>:= Regional_Indicator+</code></td>
      </tr>
      <tr>
        <td><code>Hangul-Syllable</code></td>
        <td><code>:=   L*  V+   T*<br>
           | L* LV V* T*<br>
           | L*  LVT  T*<br>
           | L+<br>
         | T+</code></td>
      </tr>
    </table>
    </div>
    <br>
    <h3>3.1 <a name="Default_Grapheme_Cluster_Table" href="tr29-27.html#Default_Grapheme_Cluster_Table">Default Grapheme Cluster 
    Boundary Specification</a></h3>
	<p>The Grapheme_Cluster_Break property value assignments are explicitly 
	listed in the corresponding data file in [<a href="../tr41/tr41-17.html#Props0">Props</a>]. The values in that file are the normative property values.</p>
	<p>For illustration, property values are summarized in <a href='tr29-27.html#Grapheme_Cluster_Break_Property_Values'><em>Table 2</em></a><em>,</em> but the lists of characters are illustrative.</p>
   <p class="caption">Table 2. 
    <a name="Grapheme_Cluster_Break_Property_Values" href="tr29-27.html#Grapheme_Cluster_Break_Property_Values">Grapheme_Cluster_Break Property Values</a></p>
	<div align="center">

  <table class="subtle"> 
    <tr>
      <th>Value</th>
      <th>Summary List of Characters</th>
    </tr>
    <tr>
      <td><b><a name="CR" href="tr29-27.html#CR">CR</a></b></td>
      <td>U+000D CARRIAGE RETURN (CR)</td>
    </tr>
    <tr>
      <td><b><a name="LF" href="tr29-27.html#LF">LF</a></b></td>
      <td>U+000A LINE FEED (LF)</td>
    </tr>
    <tr>
      <td><b><a name="Control" href="tr29-27.html#Control">Control</a></b></td>
      <td>General_Category = Line_Separator, <em>or</em><br>
      General_Category = Paragraph_Separator, <em>or</em><br>
      General_Category = Control, <em>or</em><br>
      General_Category = Unassigned <em>and</em> Default_Ignorable_Code_Point, <em>or</em><br>
      General_Category = Surrogate, <em>or</em><br>
      General_Category = Format<br>
      <i>and not</i> U+000D CARRIAGE RETURN<br>
      <i>and not</i> U+000A LINE FEED<br>
      <i>and not</i> U+200C ZERO WIDTH NON-JOINER (ZWNJ)<br>
      <i>and not</i> U+200D ZERO WIDTH JOINER (ZWJ)</td>
    </tr>
    <tr>
      <td><b><a name="Extend" href="tr29-27.html#Extend">Extend</a></b></td>
      <td>Grapheme_Extend = Yes<br><br>
		<i>This includes:</i><br>
		General_Category = Nonspacing_Mark<br>
		General_Category = Enclosing_Mark<br>
		U+200C ZERO WIDTH NON-JOINER<br>
		U+200D ZERO WIDTH JOINER<br>
		<i>plus a few</i> General_Category = Spacing_Mark <i>needed for canonical equivalence.</i></td>
    </tr>
    <tr>
      <td><a name="GB_After_Joiner" href="tr29-27.html#GB_After_Joiner"><strong>Regional_Indicator</strong></a></td>
      <td>U+1F1E6 REGIONAL INDICATOR SYMBOL LETTER A<br>
        ..U+1F1FF REGIONAL INDICATOR SYMBOL LETTER Z</td>
    </tr>
    <tr>
      <td><b><a name="Prepend" href="tr29-27.html#Prepend">Prepend</a></b></td>
      <td><i>Currently there are no characters with this value.</i></td>
    </tr>
    <tr>
      <td><b><a name="SpacingMark" href="tr29-27.html#SpacingMark">SpacingMark</a></b></td>
      <td>Grapheme_Cluster_Break ≠ Extend, <em>and</em><br>
        General_Category = Spacing_Mark<em>, or</em><br>
        <i>any of the following (which have</i> General_Category = Other_Letter<i>):</i><br>
          U+0E33 (&nbsp;ำ&nbsp;) THAI CHARACTER SARA AM<br>
          U+0EB3 (&nbsp;ຳ&nbsp;) LAO VOWEL SIGN AM<br>
        <br>
        <i>Exceptions: The following (which have</i> General_Category = Spacing_Mark
        <i>and would otherwise be included) are specifically excluded:</i><br>
		  U+102B (&nbsp;ါ&nbsp;) MYANMAR VOWEL SIGN TALL AA<br>
		  U+102C (&nbsp;ာ&nbsp;) MYANMAR VOWEL SIGN AA<br>
		  U+1038 (&nbsp;း&nbsp;) MYANMAR SIGN VISARGA<br>
		  U+1062 (&nbsp;ၢ&nbsp;) MYANMAR VOWEL SIGN SGAW KAREN EU<br>
		  ..U+1064 (&nbsp;ၤ&nbsp;) MYANMAR TONE MARK SGAW KAREN KE PHO<br>
		  U+1067 (&nbsp;ၧ&nbsp;) MYANMAR VOWEL SIGN WESTERN PWO KAREN EU<br>
		  ..U+106D (&nbsp;ၭ&nbsp;) MYANMAR SIGN WESTERN PWO KAREN TONE-5<br>
		  U+1083 (&nbsp;ႃ&nbsp;) MYANMAR VOWEL SIGN SHAN AA<br>
		  U+1087 (&nbsp;ႇ&nbsp;) MYANMAR SIGN SHAN TONE-2<br>
		  ..U+108C (&nbsp;ႌ&nbsp;) MYANMAR SIGN SHAN COUNCIL TONE-3<br>
		  U+108F (&nbsp;ႏ&nbsp;) MYANMAR SIGN RUMAI PALAUNG TONE-5<br>
		  U+109A (&nbsp;ႚ&nbsp;) MYANMAR SIGN KHAMTI TONE-1<br>
		  ..U+109C (&nbsp;ႜ&nbsp;) MYANMAR VOWEL SIGN AITON A<br>
		  U+1A61 (&nbsp;ᩡ&nbsp;) TAI THAM VOWEL SIGN A<br>
		  U+1A63 (&nbsp;ᩣ&nbsp;) TAI THAM VOWEL SIGN AA<br>
		  U+1A64 (&nbsp;ᩤ&nbsp;) TAI THAM VOWEL SIGN TALL AA<br>
		  U+AA7B (&nbsp;ꩻ&nbsp;) MYANMAR SIGN PAO KAREN TONE<br>
		  U+AA7D (&nbsp;ꩽ&nbsp;) MYANMAR SIGN TAI LAING TONE-5<br>
		  U+11720 (&nbsp;𑜠&nbsp;) AHOM VOWEL SIGN A<br>
		  U+11721 (&nbsp;𑜡&nbsp;) AHOM VOWEL SIGN AA
      </td>
    </tr>
    <tr>
      <td><b><a name="L" href="tr29-27.html#L">L</a></b></td>
      <td>Hangul_Syllable_Type=L, <i>such as:</i><br>
        U+1100 ( ᄀ ) HANGUL CHOSEONG KIYEOK<br>
		U+115F ( <b>ᅟ</b> ) HANGUL CHOSEONG FILLER<br>
        U+A960 ( ꥠ ) HANGUL CHOSEONG TIKEUT-MIEUM<br>
		U+A97C ( ꥼ ) HANGUL CHOSEONG SSANGYEORINHIEUH
      </td>
    </tr>
    <tr>
      <td><b><a name="V" href="tr29-27.html#V">V</a></b></td>
      <td>Hangul_Syllable_Type=V, <i>such as:</i><br>
          U+1160 ( <b>ᅠ</b> ) HANGUL JUNGSEONG FILLER<br>
          U+11A2 ( ᆢ ) HANGUL JUNGSEONG SSANGARAEA<br>
    	  U+D7B0 ( ힰ ) HANGUL JUNGSEONG O-YEO<br>
          U+D7C6 ( ퟆ ) HANGUL JUNGSEONG ARAEA-E
      </td>
    </tr>
    <tr>
      <td><b><a name="T" href="tr29-27.html#T">T</a></b></td>
      <td>Hangul_Syllable_Type=T, <i>such as:</i><br>
          U+11A8 ( ᆨ ) HANGUL JONGSEONG KIYEOK<br>
          U+11F9 ( ᇹ ) HANGUL JONGSEONG YEORINHIEUH<br>
          U+D7CB ( ퟋ ) HANGUL JONGSEONG NIEUN-RIEUL<br>
          U+D7FB ( ퟻ ) HANGUL JONGSEONG PHIEUPH-THIEUTH
      </td>
    </tr>
    <tr>
      <td><b><a name="LV" href="tr29-27.html#LV">LV</a></b></td>
      <td>Hangul_Syllable_Type=LV, <i>that is:</i><br>
      U+AC00 (가) 
      HANGUL SYLLABLE GA<br>
      U+AC1C (개) HANGUL SYLLABLE GAE<br>
      U+AC38 (갸) HANGUL SYLLABLE GYA<br>
      ...</td>
    </tr>
    <tr>
      <td><b><a name="LVT" href="tr29-27.html#LVT">LVT</a></b></td>
      <td>Hangul_Syllable_Type=LVT, <i>that is:</i><br>
      U+AC01 (각) HANGUL SYLLABLE GAG<br>
      U+AC02 (갂) HANGUL SYLLABLE GAGG<br>
      U+AC03 (갃) HANGUL SYLLABLE GAGS<br>
      U+AC04 (간) HANGUL SYLLABLE GAN<br>
      ...</td>
    </tr>
    <tr>
      <td><b><a name="AnyGC" href="tr29-27.html#AnyGC">Any</a></b></td>
      <td><i>This is not a property value; it is used in the rules to 
		represent any code point.</i></td>
    </tr>
  </table>
</div>
<p>&nbsp;</p>

  <h4>3.1.1 <a name="Grapheme_Cluster_Boundary_Rules" href="tr29-27.html#Grapheme_Cluster_Boundary_Rules">Grapheme Cluster Boundary Rules</a></h4>
	<p>The same rules are used for the Unicode 
	specification of boundaries for both legacy grapheme clusters and extended grapheme 
	clusters, with one exception. The extended grapheme clusters add rules
	<a href="tr29-27.html#GB9a">GB9a</a> and <a href="tr29-27.html#GB9b">GB9b</a>, while the 
	legacy grapheme clusters omit it.</p>
	<p>When citing the Unicode definition of grapheme clusters, it must be clear which of the two alternatives are being 
	specified: extended versus legacy.</p>
  <table class="subtle-nb loose">
    <tr>
      <td class="rule" colspan="4">Break at the start and end of text.</td>
    </tr>
    <tr>
      <td><a name="GB1" href="tr29-27.html#GB1">GB1</a></td>
      <td style="text-align:right">sot</td>
      <td style="text-align:center">÷</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><a name="GB2" href="tr29-27.html#GB2">GB2</a></td>
      <td style="text-align:right"></td>
      <td style="text-align:center">÷</td>
      <td>eot</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break between a CR and LF. Otherwise, break before and after controls.</td>
    </tr>
    <tr>
      <td><a name="GB3" href="tr29-27.html#GB3">GB3</a></td>
      <td style="text-align:right">CR</td>
      <td style="text-align:center">×</td>
      <td>LF</td>
    </tr>
    <tr>
      <td><a name="GB4" href="tr29-27.html#GB4">GB4</a></td>
      <td style="text-align:right">( Control | CR | LF )</td>
      <td style="text-align:center">÷</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><a name="GB5" href="tr29-27.html#GB5">GB5</a></td>
      <td style="text-align:right"></td>
      <td style="text-align:center">÷</td>
      <td>( Control | CR | LF )</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break Hangul syllable sequences.</td>
    </tr>
    <tr>
      <td><a name="GB6" href="tr29-27.html#GB6">GB6</a></td>
      <td style="text-align:right">L</td>
      <td style="text-align:center">×</td>
      <td>( L | V | LV | LVT )</td>
    </tr>
    <tr>
      <td><a name="GB7" href="tr29-27.html#GB7">GB7</a></td>
      <td style="text-align:right">( LV | V )</td>
      <td style="text-align:center">×</td>
      <td>( V | T )</td>
    </tr>
    <tr>
      <td><a name="GB8" href="tr29-27.html#GB8">GB8</a></td>
      <td style="text-align:right">( LVT | T)</td>
      <td style="text-align:center">×</td>
      <td>T</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break between regional indicator symbols.</td>
    </tr>
    <tr>
      <td><a name="GB8a" href="tr29-27.html#GB8a">GB8a</a></td>
      <td style="text-align:right">Regional_Indicator</td>
      <td style="text-align:center">×</td>
      <td>Regional_Indicator</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break before extending characters.</td>
    </tr>
	<tr>
      <td><a name="GB9" href="tr29-27.html#GB9">GB9</a></td>
      <td style="text-align:right">&nbsp;</td>
      <td style="text-align:center">×</td>
      <td>Extend</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">
      <b>Only for extended grapheme clusters:</b><br>
	  Do not break before SpacingMarks, or after Prepend characters.</td>
    </tr>
    <tr>
      <td><a name="GB9a" href="tr29-27.html#GB9a">GB9a</a></td>
      <td style="text-align:right">&nbsp;</td>
      <td style="text-align:center">×</td>
      <td>SpacingMark</td>
    </tr>
    <tr>
      <td><a name="GB9b" href="tr29-27.html#GB9b">GB9b</a></td>
      <td style="text-align:right">Prepend</td>
      <td style="text-align:center">×</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Otherwise, break everywhere.</td>
    </tr>
    <tr>
      <td><a name="GB10" href="tr29-27.html#GB10">GB10</a></td>
      <td style="text-align:right">Any</td>
      <td style="text-align:center">÷</td>
      <td>Any</td>
    </tr>
  </table>
  <p><em>Notes:</em></p>
  <ul>
    <li>Grapheme cluster boundaries can be easily tested 
      by looking at immediately adjacent characters. They can also be transformed 
      into simple regular expressions. For more information, see <i>
        <a href="tr29-27.html#Regular_Expressions">Section 6.3 Regular Expressions</a></i>.</li>
      <li>A tailoring for basic <em>aksara</em> support would add a rule of the form Virama × Base before GB10, where Virama and Base matched the appropriate characters for the Indic language in question. Typically the behavior of grapheme clusters does not matter for ill-formed text, so the Virama and Base types can be set to broader categories without problem, such as
	  <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=\p{ccc:virama}">\p{ccc:virama}</a> and 
	  <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=\p{gc:letter}">\p{gc:letter}</a>, respectively.</li>
			<li>The Grapheme_Base and Grapheme_Extend properties predated the development of the Grapheme_Cluster_Break property. The set of characters with Grapheme_Extend=Yes is the same as  the set of characters with Grapheme_Cluster_Break=Extend. However, the Grapheme_Base property proved to be insufficient for determining grapheme cluster boundaries. Grapheme_Base is no longer used by this specification.</li>
  </ul>
  <h2>4 <a name="Word_Boundaries" href="tr29-27.html#Word_Boundaries">Word Boundaries</a></h2>
  <p>Word boundaries are used in a number of different contexts. The most familiar ones are 
  selection (double-click mouse selection or “move to next word” control-arrow keys) 
  and the dialog option “Whole Word Search” for search and replace. They are also used in database queries, to 
  determine whether elements are within a certain number of words of one another.
	Searching may also use word boundaries in determining matching 
	items. Word boundaries are not restricted to whitespace and 
	punctuation. Indeed, some languages do not use spaces at all.</p>
  <p>Word boundaries can also be used in <i>intelligent cut and paste</i>. With this 
  feature, if the user cuts a selection of text on word boundaries, adjacent spaces are collapsed to a 
  single space. For example, cutting “quick” from “The_quick_fox” would leave “The_&nbsp;_fox”. 
  Intelligent cut and paste collapses this text to “The_fox”.<i> Figure 1</i> gives an example of word boundaries.</p>

   <p class="caption">Figure 1. <a name="Figure_Word_Boundaries" href="tr29-27.html#Figure_Word_Boundaries">Word Boundaries</a></p>

  <div align="center">
     <table class="simple nopad">
      <tr>
        <td>The</td>
        <td>&nbsp;</td>
        <td>quick</td>
        <td>&nbsp;</td>
        <td>(</td>
        <td>“</td>
        <td>brown</td>
        <td>”</td>
        <td>)</td>
        <td>&nbsp;</td>
        <td>fox</td>
        <td>&nbsp;</td>
        <td>can’t</td>
        <td>&nbsp;</td>
        <td>jump</td>
        <td>&nbsp;</td>
        <td>32.3</td>
        <td>&nbsp;</td>
        <td>feet</td>
        <td>,</td>
        <td>&nbsp;</td>
        <td>right</td>
        <td>?</td>
      </tr>
    </table>
  </div>

  <p>There is a boundary, for example, on either side of the word <i>brown</i>. These are the 
  boundaries that users would expect, for example, if they chose Whole Word Search. Matching <i>
  brown</i> with Whole Word Search works because there is a boundary on either side. Matching <i>brow</i> 
  does not. Matching <i>“brown”</i> also works because there are boundaries between the parentheses 
  and the quotation marks.</p>
  <p>Proximity tests in searching determines whether, for example, “quick” is within 
	three words of “fox”. 
  That is done with the above boundaries by ignoring any words that do not contain a letter, as in 
  <i><a href="tr29-27.html#Figure_Extracted_Words">Figure 2</a></i>. Thus, for proximity, “fox” is within three words of “quick”. This same technique 
  can be used for “get next/previous word” commands or keyboard arrow keys. Letters are not the only 
  characters that can be used to determine the “significant” words; different implementations may 
  include other types of characters such as digits or perform other analysis of the characters.</p>
     <p class="caption">Figure 2. <a name="Figure_Extracted_Words" href="tr29-27.html#Figure_Extracted_Words">Extracted Words</a></p>
 <div align="center">
    <table class="simple nopad">
      <tr>
        <td>The</td>
        <td>quick</td>
        <td>brown</td>
        <td>fox</td>
        <td>can’t</td>
        <td>jump</td>
        <td>32.3</td>
        <td>feet</td>
        <td>right</td>
      </tr>
    </table>
  </div>
  <p>Word boundaries are related to line boundaries, but are distinct: there are some 
  word  boundaries that are not line  boundaries, and vice versa. A 
	line  boundary is usually a word  boundary, but there are 
	exceptions such as a word containing a 
  SHY (soft hyphen): it will break across lines, yet is a single word.</p>
  <p>As with the other default specifications, implementations 
	may override 
    (tailor) the results to meet the requirements of different environments or particular languages. 
    For some languages, it may also be necessary to have different tailored word break 
    rules for selection versus Whole Word Search.</p>
	<p>In particular, the characters with the Line_Break property values of Contingent_Break 
    (CB), Complex_Context (SA/Southeast Asian), and Unknown (XX) are assigned word boundary 
    property values based on criteria outside of the scope of this annex.
	That means that satisfactory treatment of 
	languages like Chinese or Thai requires special handling.</p>  
  <h3>4.1 <a name="Default_Word_Boundaries" href="tr29-27.html#Default_Word_Boundaries">Default Word Boundary 
	Specification</a></h3>
	<p>The Word_Break property value assignments are explicitly listed in the 
	corresponding data file  in [<a href="../tr41/tr41-17.html#Props0">Props</a>]. The values in that file are the normative property values.</p>
    <p>For illustration, property values are summarized in <a href='tr29-27.html#Table_Word_Break_Property_Values'><em>Table 3</em></a>, but the lists of characters are illustrative.</p>
  <p class="caption">Table 3. <a name="Table_Word_Break_Property_Values" href="tr29-27.html#Table_Word_Break_Property_Values">Word_Break Property Values</a></p>

	<div align="center">
  <table class="subtle">
       <tr>
  <th>Value</th>
  <th>Summary List of Characters</th>
    	</tr>
    	<tr>
      <td><b><a name="CR0" href="tr29-27.html#CR0">CR</a></b></td>
      <td>U+000D CARRIAGE RETURN (CR)</td>
    	</tr>
		<tr>
      <td><b><a name="LF0" href="tr29-27.html#LF0">LF</a></b></td>
      <td>U+000A LINE FEED (LF)</td>
    	</tr>
		<tr>
      <td><b><a name="Newline" href="tr29-27.html#Newline">Newline</a></b></td>
      <td>U+000B LINE TABULATION<br>
		U+000C FORM FEED (FF)<br>
		U+0085 NEXT LINE (NEL)<br>
		U+2028 LINE SEPARATOR<br>
		U+2029 PARAGRAPH SEPARATOR</td>
    		</tr>
		<tr>
      <td><b><a name="Extend0" href="tr29-27.html#Extend0">Extend</a></b></td>
      <td>Grapheme_Extend = Yes, <i>or</i><br>
          General_Category = Spacing_Mark</td>
    		</tr>
		<tr>
		  <td><a name="WB_After_Joiner" href="tr29-27.html#WB_After_Joiner"><strong>Regional_Indicator</strong></a></td>
		  <td>U+1F1E6 REGIONAL INDICATOR SYMBOL LETTER A<br>
		    ..U+1F1FF REGIONAL INDICATOR SYMBOL LETTER Z</td>
		  </tr>
    <tr>
      <td><b><a name="Format" href="tr29-27.html#Format">Format</a></b></td>
      <td>General_Category = Format<br>
		<i>and not</i> U+200B ZERO WIDTH SPACE (ZWSP)<br>
      <i>and not</i> U+200C ZERO WIDTH NON-JOINER (ZWNJ)<br>
      <i>and not</i> U+200D ZERO WIDTH JOINER (ZWJ)</td>
    </tr>
    <tr>
      <td><b><a name="Katakana" href="tr29-27.html#Katakana">Katakana</a></b></td>
      <td>Script = KATAKANA, <i>or<br>
      any of the following:</i><br>
      U+3031 ( 〱 ) VERTICAL KANA REPEAT MARK<br>
      U+3032 ( 〲 ) VERTICAL KANA REPEAT WITH VOICED SOUND MARK<br>
      U+3033 ( 〳 ) VERTICAL KANA REPEAT MARK UPPER HALF<br>
      U+3034 ( 〴 ) VERTICAL KANA REPEAT WITH VOICED SOUND MARK UPPER HALF<br>
      U+3035 ( 〵 ) VERTICAL KANA REPEAT MARK LOWER HALF<br>
      U+309B ( ゛ ) KATAKANA-HIRAGANA VOICED SOUND MARK<br>
      U+309C ( ゜ ) KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK<br>
      U+30A0 ( ゠ ) KATAKANA-HIRAGANA DOUBLE HYPHEN<br>
      U+30FC ( ー ) KATAKANA-HIRAGANA PROLONGED SOUND MARK<br>
      U+FF70 ( ｰ ) HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK</td>
    </tr>
    <tr>
      <td><strong><a name="Hebrew_Letter" href="tr29-27.html#Hebrew_Letter">Hebrew_Letter</a></strong></td>
      <td>Script = Hebrew<br>
        <em>and</em> General_Category = Other_Letter</td>
    </tr>
    <tr>
      <td><b><a name="ALetter" href="tr29-27.html#ALetter">ALetter</a></b></td>
      <td>Alphabetic = Yes, <i>or</i><br>
     U+05F3 ( &#x05F3; ) HEBREW PUNCTUATION GERESH<br>
      <i>and</i> Ideographic = No<br>
      <i>and</i> Word_Break ≠ Katakana<br>
      <i>and</i> Line_Break ≠ Complex_Context (SA)<br>
      <i>and</i> Script ≠ Hiragana<br>
      <i>and</i> Word_Break ≠ Extend<br>
      <em>and</em> Word_Break ≠ Hebrew_Letter</td>
    </tr>
    	<tr>
    	  <td><a name="Single_Quote" href="tr29-27.html#Single_Quote"><b>Single_Quote</b></a></td>
    	  <td>U+0027 ( ' ) APOSTROPHE</td>
  	  </tr>
    	<tr>
    	  <td><a name="Double_Quote" href="tr29-27.html#Double_Quote"><b>Double_Quote</b></a></td>
    	  <td>U+0022 ( &quot; ) QUOTATION MARK</td>
  	  </tr>
    	<tr>
      <td><b><a name="MidNumLet" href="tr29-27.html#MidNumLet">MidNumLet</a></b></td>
      <td>U+002E ( . ) FULL STOP<br>
		U+2018 ( &#x2018; ) LEFT SINGLE QUOTATION MARK<br>
		U+2019 ( &#x2019; ) RIGHT SINGLE QUOTATION MARK<br>
		U+2024 ( ․ ) ONE DOT LEADER<br>
		U+FE52 ( ﹒ ) SMALL FULL STOP<br>
		U+FF07 ( ＇ ) FULLWIDTH APOSTROPHE<br>
		U+FF0E ( ． ) FULLWIDTH FULL STOP</td>
    	</tr>
    <tr>
      <td><b><a name="MidLetter" href="tr29-27.html#MidLetter">MidLetter</a></b></td>
      <td>U+00B7 ( · ) MIDDLE DOT<br>
          U+0387 ( · ) GREEK ANO TELEIA<br>
          U+05F4 ( &#x05F4; ) HEBREW PUNCTUATION GERSHAYIM<br>
          U+2027 ( ‧ ) HYPHENATION POINT<br>
          U+003A ( : ) COLON <i>(used in Swedish)</i><br>
          U+FE13 ( ︓ ) PRESENTATION FORM FOR VERTICAL COLON<br>
          U+FE55 ( ﹕ ) SMALL COLON<br>
          U+FF1A ( ： ) FULLWIDTH COLON<br>
          U+02D7 ( ˗ ) MODIFIER LETTER MINUS SIGN</td>
    </tr>
    <tr>
      <td><b><a name="MidNum" href="tr29-27.html#MidNum">MidNum</a></b></td>
      <td>Line_Break = Infix_Numeric, <i>or</i><br>
     <i>any of the following:</i><br>
		U+066C ( ٬ ) ARABIC THOUSANDS SEPARATOR<br>
		U+FE50 ( ﹐ ) SMALL COMMA<br>
		U+FE54 ( ﹔ ) SMALL SEMICOLON<br>
		U+FF0C ( ， ) FULLWIDTH COMMA<br>
		U+FF1B ( ； ) FULLWIDTH SEMICOLON<br>
		<i>and not</i> U+003A ( : ) COLON<br>
		<i>and not</i> U+FE13 ( ︓ ) PRESENTATION FORM FOR VERTICAL COLON<br>
		<i>and not</i> U+002E ( . ) FULL STOP</td>
    </tr>
    <tr>
      <td><b><a name="Numeric" href="tr29-27.html#Numeric">Numeric</a></b></td>
      <td>Line_Break = Numeric<br>
		<i>and not</i> U+066C ( ٬ ) ARABIC THOUSANDS SEPARATOR
    </tr>
    <tr>
      <td><b><a name="ExtendNumLetWB" href="tr29-27.html#ExtendNumLetWB">ExtendNumLet</a></b></td>
      <td>General_Category = Connector_Punctuation</td>
    </tr>
    <tr>
      <td><b><a name="AnyWB" href="tr29-27.html#AnyWB">Any</a></b></td>
      <td><i>This is not a property value; it is used in the rules to 
		represent any code point.</i></td>
    </tr>
  </table>
</div>

  <p>&nbsp;</p>

    <h4>4.1.1 <a name="Word_Boundary_Rules" href="tr29-27.html#Word_Boundary_Rules">Word Boundary Rules</a></h4>

  <p>The table of word boundary rules uses the 
    macro values listed in Table 3a. Each macro represents a repeated union of the basic Word_Break property
    values.</p>

  <p class="caption">Table 3a. 
    <a name="WB_Rule_Macros" href="tr29-27.html#WB_Rule_Macros">Word_Break Rule Macros</a></p>
  
  <div align="center">
  <table class="subtle">
    <tr>
      <th>Macro</th>
      <th>Represents</th>
    </tr>
    <tr>
      <td>AHLetter</td>
      <td>(ALetter | Hebrew_Letter)</td>
    </tr>
    <tr>
      <td>MidNumLetQ</td>
      <td>(MidNumLet | Single_Quote)
    </tr>
  </table>
</div>

  <p>&nbsp;</p>

  <table class="subtle-nb loose">
    <tr>
      <td class="rule" colspan="4">Break at the start and end of text.</td>
    </tr>
    <tr>
      <td><a name="WB1" href="tr29-27.html#WB1">WB1</a></td>
      <td style="text-align: right">sot</td>
      <td style="text-align:center">÷</td>
      <td></td>
    </tr>
    <tr>
      <td><a name="WB2" href="tr29-27.html#WB2">WB2</a></td>
      <td>&nbsp;</td>
      <td style="text-align:center">÷</td>
      <td>eot</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break within CRLF.</td>
    </tr>
   <tr>
      <td><a name="WB3" href="tr29-27.html#WB3">WB3</a></td>
      <td style="text-align:right">CR</td>
      <td style="text-align:center">×</td>
      <td>LF</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Otherwise break before and after Newlines (including CR and LF)</td>
    </tr>
    <tr>
      <td><a name="WB3a" href="tr29-27.html#WB3a">WB3a</a></td>
      <td style="text-align:right">(Newline | CR | LF)</td>
      <td style="text-align:center">÷</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><a name="WB3b" href="tr29-27.html#WB3b">WB3b</a></td>
      <td style="text-align:right">&nbsp;</td>
      <td style="text-align:center">÷</td>
      <td>(Newline | CR | LF)</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">
        Ignore Format and Extend characters, except when they appear at the beginning of a region of text.<br>
        (See Section 6.2, <a href="tr29-27.html#Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a>.)</td>
    </tr>
    <tr>
      <td><a name="WB4" href="tr29-27.html#WB4">WB4</a></td>
      <td style="text-align:right">X (Extend | Format)*</td>
      <td style="text-align:center">→</td>
      <td>X</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break between most letters.</td>
    </tr>
    <tr>
      <td><a name="WB5" href="tr29-27.html#WB5">WB5</a></td>
      <td style="text-align: right">AHLetter</td>
      <td style="text-align:center">×</td>
      <td>AHLetter</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break letters across certain punctuation.</td>
    </tr>
    <tr>
      <td><a name="WB6" href="tr29-27.html#WB6">WB6</a></td>
      <td style="text-align:right">AHLetter</td>
      <td style="text-align:center">×</td>
      <td>(MidLetter | MidNumLetQ) AHLetter</td>
    </tr>
    <tr>
      <td><a name="WB7" href="tr29-27.html#WB7">WB7</a></td>
      <td style="text-align:right">AHLetter (MidLetter | MidNumLetQ)</td>
      <td style="text-align:center">×</td>
      <td>AHLetter</td>
    </tr>
    <tr>
      <td><a name="WB7a" href="tr29-27.html#WB7a">WB7a</a></td>
      <td style="text-align:right">Hebrew_Letter</td>
      <td style="text-align:center">×</td>
      <td>Single_Quote</td>
    </tr>
    <tr>
      <td><a name="WB7b" href="tr29-27.html#WB7b">WB7b</a></td>
      <td style="text-align:right">Hebrew_Letter</td>
      <td style="text-align:center">×</td>
      <td>Double_Quote Hebrew_Letter</td>
    </tr>
    <tr>
      <td><a name="WB7c" href="tr29-27.html#WB7c">WB7c</a></td>
      <td style="text-align:right">Hebrew_Letter Double_Quote</td>
      <td style="text-align:center">×</td>
      <td>Hebrew_Letter</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">
      Do not break within sequences of digits, or digits adjacent to letters (“3a”, or “A3”).</td>
    </tr>
    <tr>
      <td><a name="WB8" href="tr29-27.html#WB8">WB8</a></td>
      <td style="text-align:right">Numeric</td>
      <td style="text-align:center">×</td>
      <td>Numeric</td>
    </tr>
    <tr>
      <td><a name="WB9" href="tr29-27.html#WB9">WB9</a></td>
      <td style="text-align:right">AHLetter</td>
      <td style="text-align:center">×</td>
      <td>Numeric</td>
    </tr>
    <tr>
      <td><a name="WB10" href="tr29-27.html#WB10">WB10</a></td>
      <td style="text-align:right">Numeric</td>
      <td style="text-align:center">×</td>
      <td>AHLetter</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break within sequences, such as “3.2” or “3,456.789”.</td>
    </tr>
    <tr>
      <td><a name="WB11" href="tr29-27.html#WB11">WB11</a></td>
      <td style="text-align:right">Numeric (MidNum | MidNumLetQ)</td>
      <td style="text-align:center">×</td>
      <td>Numeric</td>
    </tr>
    <tr>
      <td><a name="WB12" href="tr29-27.html#WB12">WB12</a></td>
      <td style="text-align:right">Numeric</td>
      <td style="text-align:center">×</td>
      <td>(MidNum | MidNumLetQ) Numeric</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break between Katakana.</td>
    </tr>
    <tr>
      <td><a name="WB13" href="tr29-27.html#WB13">WB13</a></td>
      <td style="text-align:right">Katakana</td>
      <td style="text-align:center">×</td>
      <td>Katakana</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break from extenders.</td>
    </tr>
    <tr>
      <td><a name="WB13a" href="tr29-27.html#WB13a">WB13a</a></td>
      <td style="text-align:right">(AHLetter | Numeric | Katakana | ExtendNumLet)</td>
      <td style="text-align:center">×</td>
      <td>ExtendNumLet</td>
    </tr>
    <tr>
      <td><a name="WB13b" href="tr29-27.html#WB13b">WB13b</a></td>
      <td style="text-align:right">ExtendNumLet</td>
      <td style="text-align:center">×</td>
      <td>(AHLetter | Numeric | Katakana)</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break between regional indicator symbols.</td>
    </tr>
    <tr>
      <td><a name="WB13c" href="tr29-27.html#WB13c">WB13c</a></td>
      <td style="text-align:right">Regional_Indicator</td>
      <td style="text-align:center">×</td>
      <td>Regional_Indicator</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Otherwise, break everywhere (including around ideographs).</td>
    </tr>
    <tr>
      <td><a name="WB14" href="tr29-27.html#WB14">WB14</a></td>
      <td style="text-align:right">Any</td>
      <td style="text-align:center">÷</td>
      <td>Any</td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <p><i>Notes:</i></p>
  <ul>
    <li>
    <p>It is not possible to provide a uniform set of rules that 
	resolves all issues across languages or that handles all ambiguous 
	situations within a given 
    language. The goal for the specification presented in this annex is to 
	provide a workable default; 
    tailored implementations can be more sophisticated.</li>
    <li>
    <p>For Thai, Lao, Khmer, Myanmar, and other scripts that do not  typically use 
    spaces between words, a good implementation should not depend on the default word boundary 
    specification. It should use a more sophisticated mechanism, as is also 
	required for line breaking. Ideographic 
    scripts such as Japanese and Chinese are even more complex. Where Hangul text is written without 
    spaces, the same applies. However, in the absence of a more sophisticated mechanism, the 
    rules specified in this annex supply a well-defined default.</li>
    <li>
    <p>The correct interpretation of hyphens in the context of word 
	boundaries is challenging. It is quite common for separate words to be 
	connected with a hyphen: “out-of-the-box,” “under-the-table,” “Italian-American,” 
	and so on. A significant number are hyphenated names, such as “Smith-Hawkins.” 
	When doing a Whole Word Search or query, users expect to find the word 
	within those hyphens. While there are some cases where they are separate 
	words (usually to resolve some ambiguity such as “re-sort” as opposed to “resort”), it 
	is better 
    overall to keep the hyphen out of the default definition. Hyphens include 
	U+002D HYPHEN-MINUS, U+2010 HYPHEN, possibly also
    U+058A ARMENIAN HYPHEN, and U+30A0 KATAKANA-HIRAGANA DOUBLE HYPHEN.</li>
    <li>
    <p>Implementations may build on the information 
	supplied by word boundaries. For example, a spell-checker would first check 
	that each word was valid according to the above definition, checking the four 
	words in “out-of-the-box.” If any of the words failed, it could build the 
	compound word and check if it as a whole sequence was in the dictionary (even if all 
	the components were not in the dictionary), such as with “re-iterate.” Of 
	course, spell-checkers for highly inflected or agglutinative languages will 
	need much more sophisticated algorithms.</li>
    <li>
    <p>The use of the apostrophe is ambiguous. It is usually considered part of one word (“can’t” 
	or 
    “aujourd’hui”) but it may also be considered as part of two words (“l’objectif”). 
	A further complication is the use of the same character as an apostrophe and 
	as a quotation mark. Therefore leading or trailing apostrophes are 
	best excluded from the default definition of a word. In some languages, such 
	as French and Italian, tailoring to break words when the character after the 
	apostrophe is a vowel may yield better results in more cases. This can be 
	done by adding a rule WB5a.</p>
    <table class="subtle-nb loose">
      <tr>
        <td class="rule"colspan="4">Break between apostrophe and vowels (French, Italian).</td>
      </tr>
      <tr>
        <td>WB5a</td>
        <td style="text-align:right"><i>apostrophe</i> </td>
        <td style="text-align:center">÷</td>
        <td>vowels</td>
      </tr>
    </table>
    <p>and defining appropriate property values for apostrophe and vowels. Apostrophe includes
    U+0027 ( &#39; ) APOSTROPHE and U+2019 ( ’ ) RIGHT SINGLE QUOTATION MARK (curly apostrophe). 
    Finally, in some transliteration schemes, apostrophe is 
    used at the beginning of words, requiring special tailoring.<br>
    </li>
    <li>
    <p>Certain cases such as colons in words (c:a) are included in the default 
    even though they may be specific to relatively small user communities (Swedish) because they do 
    not occur otherwise, in normal text, and so do not cause a problem for other languages.</li>
    <li>
    <p>For Hebrew, a tailoring may include a double quotation mark between letters, 
    because legacy data may contain that in place of U+05F4 ( &#x05F4; ) HEBREW PUNCTUATION GERSHAYIM. 
    This can be done by adding double quotation mark to MidLetter. U+05F3 ( &#x05F3; )
    HEBREW PUNCTUATION GERESH may also be included in a tailoring.</li>
    <li>
    <p>Format characters are included if they are not initial. Thus &lt;LRM&gt;&lt;ALetter&gt; will 
    break before the &lt;letter&gt;, but there is no break in &lt;ALetter&gt;&lt;LRM&gt;&lt;ALetter&gt; or &lt;ALetter&gt;&lt;LRM&gt;.</li>
    <li>
    <p>Characters such as hyphens, apostrophes, quotation 
    marks, and colon should be taken into account when using identifiers that are intended to 
    represent words of one or more natural languages. See Section 2.4, <i>Specific 
    Character Adjustments</i>, of [<a href="../tr41/tr41-17.html#UAX31">UAX31</a>]. 
    Treatment of hyphens, in particular, may be different in the case of processing identifiers than 
    when using word break analysis for a Whole Word Search or query, because when handling 
    identifiers the goal will be to parse maximal units corresponding to natural language “words,” 
    rather than to find smaller word units within longer lexical units connected by hyphens.</li>
	<li>
    <p>Normally word breaking does not require breaking between different 
	scripts. However, adding that capability may be useful in combination with other extensions of 
	word segmentation. For example, in Korean the sentence “I live in Chicago.” is written as three 
	segments delimited by spaces:<ul>
    <li>나는&nbsp; Chicago에&nbsp; 산다.</li>
  </ul>
  	<p>According to Korean standards, the grammatical suffixes, such as 
	“에” meaning “in”, are considered separate words. Thus the above sentence would be broken into 
	the following five words:
  <ul>
    <li>나,&nbsp; 는,&nbsp; Chicago,&nbsp; 에, and&nbsp; 산다.</li>
  </ul>
  	<p>Separating the first two words requires a dictionary lookup, but 
	for Latin text (“Chicago”) the separation is trivial based on the script boundary. </li>
	<li><p>Modifier letters (General_Category = Lm) are almost all included in the ALetter 
	class, by virtue of their Alphabetic property value. Thus, by default, modifier letters do not 
	cause word breaks and should be included in word selections. Modifier symbols (General_Category = Sk) are not in 
	the ALetter class and so do cause word breaks by default.</p></li>
	<li>Some or all of the following characters may be tailored to be in MidLetter, depending on the environment:
	  <ul>
	    <li>U+002D ( - ) HYPHEN-MINUS<br>
	      U+055A ( ՚ ) ARMENIAN APOSTROPHE<br>
	      U+058A ( ֊ ) ARMENIAN HYPHEN<br>
	      U+0F0B ( ་ ) TIBETAN MARK INTERSYLLABIC TSHEG<br>
	      U+1806 ( ᠆ ) MONGOLIAN TODO SOFT HYPHEN<br>
	      U+2010 ( ‐ ) HYPHEN<br>
	      U+2011 ( ‑ ) NON-BREAKING HYPHEN<br>
	      U+201B ( ‛ ) SINGLE HIGH-REVERSED-9 QUOTATION MARK<br>
	      U+30A0 ( ゠ ) KATAKANA-HIRAGANA DOUBLE HYPHEN<br>
	      U+30FB ( ・ ) KATAKANA MIDDLE DOT<br>
	      U+FE63 ( ﹣ ) SMALL HYPHEN-MINUS<br>
	      U+FF0D ( － ) FULLWIDTH HYPHEN-MINUS</li>
	    <li>In UnicodeSet notation, this is: <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\u002D\uFF0D\uFE63\u058A\u1806\u2010\u2011\u30A0\u30FB\u201B\u055A\u0F0B]">[\u002D\uFF0D\uFE63\u058A\u1806\u2010\u2011\u30A0\u30FB\u201B\u055A\u0F0B]</a></li>
	    <li>For example, some  writing systems  use a hyphen character between syllables within a word. An example is the Iu Mien language written with the Thai script. Such words should behave as single words for the purpose of selection (“double-click”), indexing, and so forth, meaning that they should not word-break on the hyphen.<br>
	      </li>
	    </ul>
	  </li>
	<li>
	  Some or all of the following characters may be tailored to be in MidNum, depending on the environment, to allow for 
	  languages that use spaces as thousands separators, such as €1 234,56.
	  <ul>
	    <li>U+0020 SPACE<br>
	      U+00A0 NO-BREAK SPACE <br>
	      U+2007 FIGURE SPACE<br>
	      U+2008 PUNCTUATION SPACE<br>
	      U+2009 THIN SPACE<br>
	      U+202F NARROW NO-BREAK SPACE
	      </li>
	    <li >In UnicodeSet notation, this is: <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\u0020\u00A0\u2007\u2008\u2009\u202F]">[\u0020\u00A0\u2007\u2008\u2009\u202F]</a></li>
	    </ul>
	  </li>
	</ul>
  <h3>4.2 <a name="Name_Validation" href="tr29-27.html#Name_Validation">Name Validation</a></h3>
  <p>Related to word determination is the issue of <em>personal name validation</em>. Implementations sometimes need to validate fields in which personal names are entered.  The goal is  to distinguish between characters like those in “James Smith-Faley, Jr.” and those in “!#@♥≠”. It is important to be reasonably lenient, because users  need to be able to add legitimate names, like “di Silva”, even if the names contain characters such as <em>space</em>. Typically, these personal name validations should not be language-specific; someone might be using a Web site in one language while his name is in a different language, for example. A basic set of name validation characters consists the characters allowed in words according to the above definition, plus a number of exceptional characters:</p>
  <p><em>Basic Name Validation Characters</em></p>
  <ul>
    <li><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\p{name%3D%2FCOMMA%2F}\p{name%3D%2FFULL+STOP%2F}%26\p{p}%0D%0A\p{whitespace}-\p{c}%0D%0A\p{alpha}%0D%0A\p{wb%3DKatakana}\p{wb%3DExtend}\p{wb%3DALetter}\p{wb%3DMidLetter}\p{wb%3DMidNumLet}%0D%0A[\u002D\u055A\u058A\u0F0B\u1806\u2010\u2011\u201B\u2E17\u30A0\u30FB\uFE63\uFF0D]]">[\p{name=/COMMA/}\p{name=/FULL STOP/}&amp;\p{p}<br>
      \p{whitespace}-\p{c}<br>
      \p{alpha}<br>
      \p{wb=Katakana}\p{wb=Extend}\p{wb=ALetter}\p{wb=MidLetter}\p{wb=MidNumLet}<br>
[\u002D\u055A\u058A\u0F0B\u1806\u2010\u2011\u201B\u2E17\u30A0\u30FB\uFE63\uFF0D]]</a></li>
  </ul>
<p>This is  only a basic set of validation characters; in particular, the following points should be kept in mind:</p>
<ul>
  <li> It is a lenient, non-language-specific set, and could be tailored where only a limited set of languages are permitted, or for other environments. For example, the set can be narrowed if name fields are separated: “,” and “.” may not be necessary if titles are not allowed.</li>
  <li>It includes characters that may not be appropriate for identifiers, and some that would not be parts of words. It also permits some characters that may be part of words in a broad sense, but not part of names, such as in “c:a” in Swedish, or hyphenation points used in dictionary words.</li>
  <li>Additional tests may be needed in cases where security is at issue. In particular, names may be validated by transforming them to NFC format, and then testing to ensure that no characters in the result of the transformation  change under NFKC. A second test is to use the information in<em> Table 5. Recommended Scripts</em> in  <em>Unicode Identifier and Pattern Syntax</em> [<a href="../tr41/tr41-17.html#UAX31">UAX31</a>]. If the name has one or more characters with explicit script values that are not in <em>Table 5</em>, then reject the name.</li>
</ul>
<h2>5 <a name="Sentence_Boundaries" href="tr29-27.html#Sentence_Boundaries">Sentence Boundaries</a></h2>
  <p>Sentence boundaries are often used for triple-click or some other method of selecting or 
  iterating through blocks of text that are larger than single words. They are also used to 
  determine whether words occur within the same sentence in database queries.</p>
  <p>Plain text provides inadequate information for determining good sentence 
	boundaries. Periods can signal the end of a sentence, indicate 
	abbreviations, or be used for decimal points, for example. Without much more 
	sophisticated analysis, one cannot distinguish between the two following 
	examples of the sequence &lt;?, ”, space, uppercase-letter&gt;.
	In the first example, they mark the end of a 
	sentence, while in the second they do not.</p>
  <blockquote>
    <table class="simple nopad">
      <tr>
        <td>He said, “Are you going?”&nbsp;</td>
        <td>John shook his head.</td>
      </tr>
    </table><br>
    <table class="simple nopad">
      <tr>
        <td>“Are you going?” John asked.</td>
      </tr>
    </table>
  </blockquote>
  <p>Without analyzing the text 
  semantically, it is impossible to be certain which of these usages is intended (and sometimes 
  ambiguities still remain). However, in most cases a straightforward mechanism 
  works well.</p>
  <blockquote>
    <p><i>Note:</i> As with the other default specifications, implementations are free to override 
    (tailor) the results to meet the requirements of different environments or particular languages.
    For example, locale-sensitive boundary suppression specifications
    can be expressed in LDML [<a href="../tr41/tr41-17.html#UTS35">UTS35</a>]. Specific sentence boundary suppressions are available in the
    Common Locale Data Repository [<a href="../tr41/tr41-17.html#CLDR">CLDR</a>] and may be used to improve the quality of boundary analysis.</p>
  </blockquote>

  <h3>5.1 <a name="Default_Sentence_Boundaries" href="tr29-27.html#Default_Sentence_Boundaries">Default Sentence Boundary 
	Specification</a></h3>
	<p>The Sentence_Break property value assignments are explicitly listed in 
	the corresponding data file in [<a href="../tr41/tr41-17.html#Props0">Props</a>]. The values in that file are the normative property values.</p>
    <p>For illustration, property values are summarized in <a href='tr29-27.html#Table_Sentence_Break_Property_Values'><em>Table 4</em></a>, but the lists of characters are illustrative.</p>
   <p class="caption">Table 4. 
    <a name="Table_Sentence_Break_Property_Values" href="tr29-27.html#Table_Sentence_Break_Property_Values">Sentence_Break Property Values</a></p>    

	<div align="center">
  <table class="subtle">
    <tr>    
      <th>Value</th>
      <th>Summary List of Characters</th>
    </tr>
    <tr>
      <td><b><a name="CR1" href="tr29-27.html#CR1">CR</a></b></td>
      <td>U+000D CARRIAGE RETURN (CR)</td>
    </tr>
	<tr>
      <td><b><a name="LF1" href="tr29-27.html#LF1">LF</a></b></td>
      <td>U+000A LINE FEED (LF)</td>
    </tr>
	<tr>
      <td><b><a name="Extend1" href="tr29-27.html#Extend1">Extend</a></b></td>
      <td>
      Grapheme_Extend = Yes, <i>or</i><br>
		General_Category = Spacing_Mark</td>
    	</tr>
    <tr>
      <td><b><a name="Sep" href="tr29-27.html#Sep">Sep</a></b></td>
      <td>U+0085 NEXT LINE (NEL)<br>
      U+2028 LINE SEPARATOR<br>
      U+2029 PARAGRAPH SEPARATOR</td>
    </tr>
    <tr>
      <td><a name="SB_Format" href="tr29-27.html#SB_Format"><b>Format</b></a></td>
      <td>General_Category = Format<br>
      <i>and not</i> U+200C ZERO WIDTH NON-JOINER (ZWNJ)<br>
      <i>and not</i> U+200D ZERO WIDTH JOINER (ZWJ)</td>
    </tr>
    <tr>
      <td><b><a name="Sp" href="tr29-27.html#Sp">Sp</a></b></td>
      <td>Whitespace = Yes<br>
      <i>and</i> Sentence_Break ≠ Sep<br>
		<i>and </i>Sentence_Break ≠ CR<br>
		<i>and </i>Sentence_Break ≠ LF</td>
    </tr>
    <tr>
      <td><b><a name="Lower" href="tr29-27.html#Lower">Lower</a></b></td>
      <td>Lowercase = Yes<br>
      <i>and</i> Grapheme_Extend = No</td>
    </tr>
    <tr>
      <td><b><a name="Upper" href="tr29-27.html#Upper">Upper</a></b></td>
      <td>General_Category = Titlecase_Letter, <i>or</i><br>
      Uppercase = Yes</td>
    </tr>
    <tr>
      <td><b><a name="OLetter" href="tr29-27.html#OLetter">OLetter</a></b></td>
      <td>Alphabetic = Yes, <i>or</i><br>
      U+00A0 NO-BREAK SPACE (NBSP), <i>or</i><br>
      U+05F3 ( &#x05F3; ) HEBREW PUNCTUATION GERESH<br>
      <i>and</i> Lower = No<br>
      <i>and</i> Upper = No<br>
      <i>and</i> Sentence_Break ≠ Extend</td>
    </tr>
    <tr>
      <td><a name="SB_Numeric" href="tr29-27.html#SB_Numeric"><b>Numeric</b></a></td>
      <td>Line_Break = Numeric</td>
    </tr>
    <tr>
      <td><b><a name="ATerm" href="tr29-27.html#ATerm">ATerm</a></b></td>
      <td>U+002E ( . ) FULL STOP<br>
		  U+2024 ( ․ ) ONE DOT LEADER<br>
		U+FE52 ( ﹒ ) SMALL FULL STOP<br>
		U+FF0E ( ． ) FULLWIDTH FULL STOP</td>
    </tr>
    <tr>
      <td><b><a name="SContinue" href="tr29-27.html#SContinue">SContinue</a></b></td>
      <td>U+002C (&nbsp;,&nbsp;) COMMA<br>
		U+002D (&nbsp;-&nbsp;) HYPHEN-MINUS<br>
		U+003A (&nbsp;:&nbsp;) COLON<br>
		U+055D (&nbsp;՝&nbsp;) ARMENIAN COMMA<br>
		U+060C (&nbsp;،&nbsp;) ARABIC COMMA<br>
		U+060D (&nbsp;‎؍‎&nbsp;) ARABIC DATE SEPARATOR<br>
		U+07F8 (&nbsp;߸&nbsp;) NKO COMMA<br>
		U+1802 (&nbsp;᠂&nbsp;) MONGOLIAN COMMA<br>
		U+1808 (&nbsp;᠈&nbsp;) MONGOLIAN MANCHU COMMA<br>
		U+2013 (&nbsp;–&nbsp;) EN DASH<br>
		U+2014 (&nbsp;—&nbsp;) EM DASH<br>
		U+3001 (&nbsp;、&nbsp;) IDEOGRAPHIC COMMA<br>
		U+FE10 (&nbsp;︐&nbsp;) PRESENTATION FORM FOR VERTICAL COMMA<br>
		U+FE11 (&nbsp;︑&nbsp;) PRESENTATION FORM FOR VERTICAL IDEOGRAPHIC COMMA<br>
		U+FE13 (&nbsp;︓&nbsp;) PRESENTATION FORM FOR VERTICAL COLON<br>
		U+FE31 (&nbsp;︱&nbsp;) PRESENTATION FORM FOR VERTICAL EM DASH<br>
		U+FE32 (&nbsp;︲&nbsp;) PRESENTATION FORM FOR VERTICAL EN DASH<br>
		U+FE50 (&nbsp;﹐&nbsp;) SMALL COMMA<br>
		U+FE51 (&nbsp;﹑&nbsp;) SMALL IDEOGRAPHIC COMMA<br>
		U+FE55 (&nbsp;﹕&nbsp;) SMALL COLON<br>
		U+FE58 (&nbsp;﹘&nbsp;) SMALL EM DASH<br>
		U+FE63 (&nbsp;﹣&nbsp;) SMALL HYPHEN-MINUS<br>
		U+FF0C (&nbsp;，&nbsp;) FULLWIDTH COMMA<br>
		U+FF0D (&nbsp;－&nbsp;) FULLWIDTH HYPHEN-MINUS<br>
		U+FF1A (&nbsp;：&nbsp;) FULLWIDTH COLON<br>
		U+FF64 (&nbsp;､&nbsp;) HALFWIDTH IDEOGRAPHIC COMMA</td>
    </tr>
    <tr>
      <td><b><a name="STerm" href="tr29-27.html#STerm">STerm</a></b></td>
      <td>STerm = Yes</td>
    </tr>
    <tr>
      <td><b><a name="Close" href="tr29-27.html#Close">Close</a></b></td>
      <td>General_Category = Open_Punctuation, <i>or</i><br>
      General_Category = Close_Punctuation, <i>or</i><br>
      Line_Break = Quotation<br>
      <i>and not</i> U+05F3 ( &#x05F3; ) HEBREW PUNCTUATION GERESH<br>
      <i>and</i> ATerm = No<br>
      <i>and</i> STerm = No</td>
    </tr>
    <tr>
      <td><b><a name="AnySB" href="tr29-27.html#AnySB">Any</a></b></td>
      <td><i>This is not a property value; it is used in the rules to 
		represent any code point.</i></td>
    </tr>
  </table>
</div>

  <p>&nbsp;</p>

      <h4>5.1.1 <a name="Sentence_Boundary_Rules" href="tr29-27.html#Sentence_Boundary_Rules">Sentence Boundary Rules</a></h4>

  <p>The table of sentence boundary rules uses the 
    macro values listed in Table 4a. Each macro represents a repeated union of the basic Sentence_Break property
    values.</p>

  <p class="caption">Table 4a. 
    <a name="SB_Rule_Macros" href="tr29-27.html#SB_Rule_Macros">Sentence_Break Rule Macros</a></p>
  
  <div align="center">
  <table class="subtle">
    <tr>
      <th>Macro</th>
      <th>Represents</th>
    </tr>
    <tr>
      <td>ParaSep</td>
      <td>(Sep | CR | LF)</td>
    </tr>
    <tr>
      <td>SATerm</td>
      <td>(STerm | ATerm)
    </tr>
  </table>
</div>

  <p>&nbsp;</p>

  <table class="subtle-nb loose">
    <tr>
      <td class="rule" colspan="4">Break at the start and end of text.</td>
    </tr>
    <tr>
      <td><a name="SB1" href="tr29-27.html#SB1">SB1</a></td>
      <td style="text-align:right">sot</td>
      <td style="text-align:center">÷</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><a name="SB2" href="tr29-27.html#SB2">SB2</a></td>
      <td style="text-align:right"></td>
      <td style="text-align:center">÷</td>
      <td>eot</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break within CRLF.</td>
    </tr>
    <tr>
      <td><a name="SB3" href="tr29-27.html#SB3">SB3</a></td>
      <td style="text-align:right">CR</td>
      <td style="text-align:center">×</td>
      <td>LF</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Break after paragraph separators.</td>
    </tr>
    <tr>
      <td><a name="SB4" href="tr29-27.html#SB4">SB4</a></td>
      <td style="text-align:right">ParaSep</td>
      <td style="text-align:center">÷</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Ignore Format and Extend characters, except after sot, Sep, CR, or LF.
    (See Section 6.2, <a href="tr29-27.html#Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a>.)</td>
    </tr>
    <tr>
      <td><a name="SB5" href="tr29-27.html#SB5">SB5</a></td>
      <td style="text-align:right">X (Extend | Format)*</td>
      <td style="text-align:center">→</td>
      <td>X</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Do not break after full stop in certain contexts. 
      [See note below.] </td>
    </tr>
    <tr>
      <td><a name="SB6" href="tr29-27.html#SB6">SB6</a></td>
      <td style="text-align:right">ATerm</td>
      <td style="text-align:center">×</td>
      <td>Numeric</td>
    </tr>
    <tr>
      <td><a name="SB7" href="tr29-27.html#SB7">SB7</a></td>
      <td style="text-align:right">(Upper | Lower) ATerm</td>
      <td style="text-align:center">×</td>
      <td>Upper</td>
    </tr>
    <tr>
      <td><a name="SB8" href="tr29-27.html#SB8">SB8</a></td>
      <td style="text-align:right">ATerm Close* Sp*</td>
      <td style="text-align:center">×</td>
      <td>( ¬(OLetter | Upper | Lower | ParaSep | SATerm) )* Lower</td>
    </tr>
    <tr>
      <td>
    <a name="SB8a" href="tr29-27.html#SB8a">SB8a</a></td>
      <td style="text-align:right">SATerm Close* Sp*</td>
      <td style="text-align:center">×</td>
      <td>(SContinue | SATerm)</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">
      Break after sentence terminators, but include closing punctuation, trailing 
      spaces, and any paragraph separator. [See note below.]</td>
    </tr>
    <tr>
      <td><a name="SB9" href="tr29-27.html#SB9">SB9</a></td>
      <td style="text-align:right">SATerm Close*</td>
      <td style="text-align:center">×</td>
      <td>(Close | Sp | ParaSep)</td>
    </tr>
    <tr>
      <td><a name="SB10" href="tr29-27.html#SB10">SB10</a></td>
      <td style="text-align:right">SATerm Close* Sp*</td>
      <td style="text-align:center">×</td>
      <td>(Sp | ParaSep)</td>
    </tr>
    <tr>
      <td><a name="SB11" href="tr29-27.html#SB11">SB11</a></td>
      <td style="text-align:right">SATerm Close* Sp* ParaSep?</td>
      <td style="text-align:center">÷</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td class="rule" colspan="4">Otherwise, do not break.</td>
    </tr>
    <tr>
      <td><a name="SB12" href="tr29-27.html#SB12">SB12</a></td>
      <td style="text-align:right">Any</td>
      <td style="text-align:center">×</td>
      <td>Any</td>
    </tr>
  </table>
<p>&nbsp;</p>
	<p><i>Notes:</i></p>
  <ul>
    <li>Rules <a href="tr29-27.html#SB6">SB6</a>-<a href="tr29-27.html#SB8">SB8</a> are designed to forbid breaks 
      after ambiguous terminators (primarily U+002E FULL STOP) within strings such as
      those shown in <a href="tr29-27.html#ForbiddenSB"><i>Figure 3</i></a>.
      The contexts which forbid breaks include occurrence directly
        before a number, between uppercase letters, when followed by a lowercase letter (optionally
        after certain punctuation), or when followed by certain continuation punctuation such as a
        comma, colon, or semicolon.
      These rules permit breaks in strings such as
      those shown in <a href="tr29-27.html#AllowedSB"><i>Figure 4</i></a>.
      They cannot detect cases such as “...Mr. Jones...”; more 
      sophisticated tailoring would be required to detect such cases.</li>
  	<li>Rules <a href="tr29-27.html#SB9">SB9</a>-<a href="tr29-27.html#SB11">SB11</a> are designed to allow breaks after sequences of the 
	following form, but not within them:<ul>
    <li>( STerm | ATerm ) Close* Sp* ( Sep | CR | LF )?</li>
    </ul>
  	</li>
    <li>Note that in unusual cases, a word segment (determined according to <em>Section 4 <a href="tr29-27.html#Word_Boundaries">Word Boundaries</a></em>)
      may span a sentence break (according to <em>Section 5 <a href="tr29-27.html#Sentence_Boundaries">Sentence Boundaries</a></em>).
      Inconsistencies between word and sentence boundaries can be reduced by customizing <a href="tr29-27.html#SB11">SB11</a> to take account
      of whether a period is followed by a character from a script that doesn't normally require spaces between words.</li>
    <li>Users can run experiments in an interactive <a href='http://unicode.org/cldr/utility/breaks.jsp'>online demo</a>
      to observe default word and sentence boundaries in a given piece of text.</li>
  </ul>

  <p class="caption">Figure 3. <a name="ForbiddenSB" href="tr29-27.html#ForbiddenSB">Forbidden Breaks on "."</a></p>

  <div align="center">
          <table class="simple">
          <tr>
            <td style="text-align:right; padding-right:0px">c.</td>
            <td style="text-align:left; padding-left:0px">d</td>
          </tr>
          <tr>
            <td style="text-align:right; padding-right:0px">3.</td>
            <td style="text-align:left; padding-left:0px">4</td>
          </tr>
          <tr>
            <td style="text-align:right; padding-right:0px">U.</td>
            <td style="text-align:left; padding-left:0px">S.</td>
          </tr>
          <tr>
            <td style="text-align:right; padding-right:0px">... the resp.</td>
            <td style="text-align:left; padding-left:0px">&nbsp;leaders are ...</td>
          </tr>
          <tr>
            <td style="text-align:right; padding-right:0px">... etc.)’&nbsp;</td>
            <td style="text-align:left; padding-left:0px">‘(the ...</td>
          </tr>
          </table>
  </div>

  <p class="caption">Figure 4. <a name="AllowedSB" href="tr29-27.html#AllowedSB">Allowed Breaks on "."</a></p>

  <div align="center">
        <table class="simple">
          <tr>
            <td style="text-align:right">She said “See spot run.”</td>
            <td style="text-align:left">&nbsp;John shook his head. ...</td>
          </tr>
          <tr>
            <td style="text-align:right">... etc.</td>
            <td style="text-align:left">它们指...</td>
          </tr>
          <tr>
            <td style="text-align:right">...理数字.</td>
            <td style="text-align:left">它们指...</td>
          </tr>
        </table>    
  </div>

  <p>&nbsp;</p>

  <h2>6 <a name="Implementation_Notes" href="tr29-27.html#Implementation_Notes">Implementation Notes</a></h2>
  <h3>6.1 <a name="Normalization" href="tr29-27.html#Normalization">Normalization</a></h3>
  <p>The boundary specifications are stated in terms of text normalized 
	according to Normalization Form NFD (see Unicode Standard Annex #15, &#x201C;Unicode 
	Normalization Forms&#x201D; [<a href="../tr41/tr41-17.html#UAX15">UAX15</a>]). In practice, normalization of the input is not 
  required. To ensure that the same results are returned for canonically equivalent text (that is, 
  the same boundary positions will be found, although those may be represented by different 
  offsets), the grapheme cluster boundary specification has the following features:</p>
  <ul>
	<li>There is never a break within a sequence of nonspacing marks.</li>
	<li>There is never a break between a base character and subsequent 
	nonspacing marks. </li>
	</ul>
  <p>The specification also avoids certain problems by explicitly assigning the 
	Extend property value to certain characters, such as U+09BE (&nbsp;া&nbsp;) 
    BENGALI VOWEL SIGN AA, to deal with particular compositions.</p>
  <p>The other default boundary specifications never break within grapheme clusters, and 
	they always use 
  a consistent property value for each grapheme cluster as a whole.</p>
  <h3>6.2 <a name="Grapheme_Cluster_and_Format_Rules" href="tr29-27.html#Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a></h3>
  <p>An important rule for the default word and sentence specifications ignores 
	Extend and Format characters. The main purpose of this rule is to always 
	treat a grapheme cluster as a single character—that is, as if it were simply 
	the first character of the cluster. Both word and sentence specifications do 
	not distinguish between L, V, T, LV, and LVT: 
	thus it does not matter whether 
  there is a sequence of these or a single one. In addition, there is a specific 
  rule to disallow breaking within CRLF. Thus ignoring Extend is sufficient to disallow breaking 
  within a grapheme cluster. Format characters are also ignored by default, because these characters 
  are normally irrelevant to such boundaries.</p>
  <p>The “Ignore” rule is then equivalent to making the 
	following changes in the rules:</p>

  <table class="simple">
	<tr>
		<td class="lightgray" colspan="3">
		<i>Replace the “Ignore” rule by the following, to disallow 
	breaks within sequences (except after CRLF and related characters):</i></td>
	</tr>
	<tr>
		<th style="text-align:right">Original</th>
		<th style="text-align:center">&nbsp;</th>
		<th>Modified</th>
	</tr>
	<tr>
		<td style="text-align:right">X (Extend | Format)*→X</td>
		<td style="text-align:center">&#x21D2;</td>
		<td>(¬Sep) × <u>(Extend | Format)</u></td>
	</tr>
	<tr>
		<td class="lightgray" colspan="3">
		<i>In all subsequent rules, insert (Extend | Format)* after every boundary property value, 
		except in negations (such as ¬(OLetter | Upper ...). (It is not 
	necessary to do this after the final property, on the right side of the break symbol.) For example:</i></td>
	</tr>
	<tr>
		<th style="text-align:right">Original</th>
		<th style="text-align:center">&nbsp;</th>
		<th>Modified</th>
	</tr>
	<tr>
		<td style="text-align:right">X Y × Z W</td>
		<td style="text-align:center">&#x21D2;</td>
		<td>X <u>(Extend | Format)*</u> Y <u>(Extend | Format)*</u> × Z <u>(Extend | Format)*</u> W</td>
	</tr>
	<tr>
		<td style="text-align:right">X Y ×</td>
		<td style="text-align:center">&#x21D2;</td>
		<td>X <u>(Extend | Format)*</u> Y <u>(Extend | Format)*</u> ×</td>
	</tr>
	<tr>
		<td class="lightgray" colspan="3">
		<i>An alternate expression that resolves to a single 
		character is treated as a whole. For example:</i></td>
	</tr>
		<tr>
			<th style="text-align:right">Original</th>
			<th style="text-align:center">&nbsp;</th>
			<th>Modified</th>
		</tr>
		<tr>
			<td style="text-align:right">(STerm | ATerm)</td>
			<td style="text-align:center">&#x21D2;</td>
			<td>(STerm | ATerm) <u>(Extend | Format)*</u></td>
		</tr>
		<tr>
			<td style="text-align:right"><i><b>not</b></i></td>
			<td style="text-align:center">&#x21D2;</td>
			<td>(STerm <u>(Extend | Format)*</u> | ATerm <u>(Extend | Format)*</u>)</td>
		</tr>
	</table>

  <p>The Ignore rules should not be overridden by tailorings, with the 
  possible exception of remapping some of the Format characters to other classes.</p>
  <h3>6.3 <a name="Regular_Expressions" href="tr29-27.html#Regular_Expressions">Regular Expressions</a></h3>
  <p>The preceding rules can be converted into regular expressions that will produce the same results. 
  The regular expression must be evaluated starting at a known boundary (such as the start of the 
  text) and take the longest match (except in the case of sentence boundaries, where the shortest 
  match needs to be used).</p>
  <p>The conversion into a regular expression is 
	fairly straightforward for the grapheme cluster boundaries of <i><a href='tr29-27.html#Grapheme_Cluster_Break_Property_Values'>Table 2</a></i>. For example, they can be transformed into the  
regular expression found in <a href="tr29-27.html#Table_Combining_Char_Sequences_and_Grapheme_Clusters"><em>Table 1b</em></a>.</p>

	<p >Such a regular expression can also be turned 
	into a fast, deterministic finite-state machine. Similar regular expressions 
	are possible for Word boundaries. Line and Sentence boundaries are 
	more complicated, and more difficult to represent with regular expressions. 
	For more information on Unicode Regular Expressions, see Unicode Technical 
	Standard #18, “Unicode Regular Expressions” [<a href="../tr41/tr41-17.html#UTS18">UTS18</a>].</p>
  <h3>6.4 <a name="Random_Access" href="tr29-27.html#Random_Access">Random Access</a></h3>
  <p>Random access introduces a further complication. When iterating through a string from 
  beginning to end, a regular expression or state machine works well. From each boundary to find the 
  next boundary is very fast. By constructing a state table for the reverse direction from the same 
  specification of the rules, reverse iteration is possible.</p>
  <p>However, suppose that the user wants to iterate starting at a random point in the text, or 
  detect whether a random point in the text is a boundary. If the starting point does not provide 
  enough context to allow the correct set of rules to be applied, then one could fail to find a 
  valid boundary point. For example, suppose a user clicked after the first space after the question 
  mark in “Are_you_there? _ _ No,_I&#x2019;m_not”. On a forward iteration searching for a sentence 
  boundary, one would fail to find the boundary before the “N”, because the “?” had 
	not been seen 
  yet.</p>
  <p>A second set of rules to determine a “safe” starting point provides a solution. Iterate 
  backward with this second set of rules until a safe starting point is located, then iterate 
  forward from there. Iterate forward to find boundaries that were located between the safe point 
  and the starting point; discard these. The desired boundary is the first one that is not less than 
  the starting point. The safe rules must be designed so that they function correctly no matter what 
  the starting point is, so they have to be conservative in terms of finding boundaries, 
	and only find those boundaries that can be determined by a small context (a 
	few neighboring characters).</p>
  <p class="caption">Figure 5. <a name="Figure_Random_Access" href="tr29-27.html#Figure_Random_Access">Random Access</a></p>
  <p align="center" style="text-align: center"><img src="images/random_access.jpg" alt="random access diagram"></p>
  <p>This process would represent a significant performance cost if it had to be performed on every 
  search. However, this functionality can be wrapped up in an iterator object, which preserves the 
  information regarding whether it currently is at a valid boundary point. Only if it is reset to an 
  arbitrary location in the text is this extra backup processing performed. The iterator may even 
  cache local values that it has already traversed.</p>
  <h3>6.5 <a name="Tailoring" href="tr29-27.html#Tailoring">Tailoring</a></h3>
  <p>Rule-based implementation can also be combined with a 
  code-based or table-based tailoring mechanism. For typical state machine 
  implementations, for example, a Unicode character is 
  typically passed to a mapping table that maps characters to boundary property values. This mapping 
  can use an efficient mechanism such as a trie. Once a boundary property value is produced, it 
  is passed to the state machine.</p>
  <p>The simplest customization is to adjust the values coming out of the character mapping 
  table. For example, to mark the appropriate quotation marks for a given language as having the 
  sentence boundary property value Close, artificial property values can be introduced for different 
  quotation marks. A table can be applied after the main mapping table to map those artificial 
  character property values to the real ones. To change languages, a different small table is 
  substituted. The only real cost is then an extra array lookup.</p>
  <p>For code-based tailoring a different special range of property values can be added. The state 
  machine is set up so that any special property value causes the state machine to halt and return 
  a particular exception value. When this exception value is detected, the higher-level process can 
  call specialized code according to whatever the exceptional value is. This can all be encapsulated 
  so that it is transparent to the caller.</p>
  <p>For example, Thai characters can be mapped to a special property value. When the state machine 
  halts for one of these values, then a Thai word break implementation
  is invoked internally, to produce boundaries within the subsequent string of Thai 
  characters. These boundaries can then be cached so that subsequent calls for next 
	or previous 
  boundaries merely return the cached values. Similarly Lao characters can be mapped to a different 
  special property value, causing a different implementation to be 
  invoked.</p>
  <h2>7 <a name="Testing" href="tr29-27.html#Testing">Testing</a></h2>
  <p>There is no requirement that Unicode-conformant implementations implement these default 
  boundaries. As with the other default specifications, implementations are also free to override 
  (tailor) the results to meet the requirements of different environments or particular languages. 
  For those who do implement the default boundaries as specified in this annex, and wish to check that that 
  their implementation matches that specification, three test files have been made available 
  in [<a href="../tr41/tr41-17.html#Tests29">Tests29</a>].</p>
  <p>These tests cannot be exhaustive, because of the large number of possible 
	combinations; but they do provide 
  samples that test all pairs of property values, using a representative character for each value, 
  plus certain other sequences.</p>
  <p>A sample HTML file is also available for each that shows various combinations in chart form, 
  in [<a href="../tr41/tr41-17.html#Charts29">Charts29</a>]. The header cells of the chart consist of a property 
  value, followed by a representative code point number. The body cells in the chart show the <i>
  break status</i>: whether a break occurs between the row property value and the column property 
  value. If the browser supports tool-tips, then hovering the mouse over the code point number will 
  show the character name, General_Category, Line_Break, and Script property values. Hovering over 
  the break status will display the number of the rule responsible for that status.</p>
  <blockquote>
    <p><span class="note">Note:</span><i> Testing two adjacent characters is 
	insufficient for determining a boundary, except for the case of the default grapheme clusters.</i></p>
  </blockquote>
  <p>The chart may be followed by some test cases. These test cases consist of various strings with 
  the break status between each pair of characters shown by blue lines for breaks and 
	by whitespace 
  for non-breaks. Hovering over each character (with tool-tips enabled) shows the character name and 
  property value; hovering over the break status shows the number of the rule responsible for that 
  status.</p>
	<p>Due to the way they have been mechanically processed for generation, the 
	test rules do not match the rules in this annex precisely. In particular:</p>
	<ol>
		<li>The rules are cast into a more regex-style.</li>
		<li>The rules “sot ÷”, “÷ eot”, and “÷ Any” are added mechanically and 
		have artificial numbers. </li>
		<li>The rules are given decimal numbers without prefix, so rules such as 
		WB13a are given 
		a number using tenths, such as 13.1.</li>
		<li>Where a rule has multiple parts (lines), each one is numbered using 
		hundredths, such as<ul>
			<li>21.01) × $BA</li>
			<li>21.02) × $HY</li>
			<li>...</li>
		</ul>
		</li>
		<li>Any “treat as” or “ignore” rules are handled as discussed in this annex, and thus 
		reflected in a transformation of the rules not visible in the tests.</li>
	</ol>
	<p>The mapping from the rule numbering in this annex to the numbering for 
	the test rules is 
  summarized in <i><a href="tr29-27.html#Table_Numbering_of_Rules">Table 5</a>.</i></p>

    <p class="caption">Table 5. 
      <a name="Table_Numbering_of_Rules" href="tr29-27.html#Table_Numbering_of_Rules">Numbering of Rules</a></p>

  <div align="center">

	<table class="subtle">
	<tr>
		<th>Rule in This Annex</th>
		<th>Test Rule</th>
		<th>Comment</th>
	</tr>
	<tr>
		<td>xx1</td>
		<td>0.1</td>
		<td>start of text</td>
	</tr>
	<tr>
		<td>xx2</td>
		<td>0.2</td>
		<td>end of text</td>
	</tr>
	<tr>
		<td>SB8a</td>
		<td>8.1</td>
		<td rowspan="3" style="vertical-align: middle">letter style</td>
	</tr>
	<tr>
		<td>WB13a</td>
		<td>13.1</td>
	</tr>
	<tr>
		<td>WB13b</td>
		<td>13.2</td>
	</tr>
	<tr>
		<td>GB10</td>
		<td rowspan="2" style="vertical-align: middle">999</td>
		<td rowspan="2" style="vertical-align: middle">any&nbsp; </td>
	</tr>
	<tr>
		<td>WB14</td>
	</tr>
	</table>
	</div>

  <p>&nbsp;</p>

    <h2>8 <a name="Hangul_Syllable_Boundary_Determination" href="tr29-27.html#Hangul_Syllable_Boundary_Determination">Hangul Syllable Boundary Determination</a></h2>
<p>In rendering, a sequence of jamos is displayed as a series of syllable blocks. The following rules specify how to divide up an arbitrary sequence of jamos (including nonstandard sequences) into these syllable blocks. The symbols  L, V, T, LV, LVT represent the  corresponding Hangul_Syllable_Type property values; the symbol M for combining marks.</p> 
<p>The precomposed Hangul syllables are of two types: LV or LVT. In determining the syllable boundaries, the LV behave as if they were a sequence of jamo L V, and the LVT behave as if they were a sequence of jamo L V T.</p>
<p>Within any sequence of characters, a syllable break never occurs between the pairs of characters shown in <a href="tr29-27.html#Hangul_Syllable_No_Break_Rules"><em>Table 6</em></a>. In all cases other than those shown in <i>Table 6</i>, a syllable break occurs before and after any jamo or precomposed Hangul syllable. As for other characters, any combining mark between two conjoining jamos prevents the jamos from forming a syllable block.</p>

<p class="caption">Table 6. 
  <a name="Hangul_Syllable_No_Break_Rules" href="tr29-27.html#Hangul_Syllable_No_Break_Rules">Hangul Syllable No-Break Rules</a></p>

<div align="center">

<table class="subtle"> 
    <tr> 
      <th colspan='2' style="text-align:center">Do Not Break Between</th> 
      <th>Examples</th> 
    </tr> 
    <tr> 
      <td valign="top">L</td> 
      <td valign="top">L, V, LV or LVT</td> 
      <td valign="top">L × L<br>
          L × V<br>
          L × LV<br>
          L × LVT</td> 
    </tr> 
    <tr> 
      <td valign="top">V or LV</td> 
      <td valign="top">V or T</td> 
      <td valign="top">V × V<br>
          V × T<br>
          LV × V<br>
          LV × T</td> 
    </tr> 
    <tr> 
      <td valign="top">T or LVT</td> 
      <td valign="top">T</td> 
      <td valign="top">T × T<br>
          LVT × T</td> 
    </tr> 
    <tr> 
      <td valign="top">Jamo, LV or LVT</td> 
      <td valign="top">Combining marks</td> 
      <td valign="top">L × M<br>
          V × M<br>
          T × M<br>
          LV × M<br>
          LVT × M</td> 
    </tr> 
</table>
</div>

<p>Even in Normalization Form NFC, a syllable block may contain a precomposed Hangul syllable in the middle. An example is L LVT T. Each well-formed modern Hangul syllable, however, can be represented in the form L V T? (that is one L, one V and optionally one T) and consists of a single encoded character in NFC.</p> 
<p>For information on the behavior of Hangul compatibility jamos in syllables, see <i>Section 18.6, Hangul</i> of [<a href="../tr41/tr41-17.html#Unicode">Unicode</a>].</p> 
<h3>8.1 <a name="Standard_Korean_Syllables" href="tr29-27.html#Standard_Korean_Syllables">Standard Korean Syllables</a></h3> 
<ul > 
  <li><i>Standard Korean syllable block:</i> A sequence of one or more L followed by a sequence of one or more V and a sequence of zero or more T, or any other sequence that is canonically equivalent.</li> 
</ul> 
<ul > 
  <li>All precomposed Hangul syllables, which have the form LV or LVT, are standard Korean syllable blocks.</li> 
  <li>Alternatively, a standard Korean syllable block may be expressed as a sequence of a choseong and a jungseong, optionally followed by a jongseong.</li> 
  <li>A choseong filler may substitute for a missing leading consonant, and a jungseong filler may substitute for a missing vowel.</li> 
</ul> 
<p>Using regular expression notation, a canonically decomposed standard Korean syllable block is of the following form:</p> 
<p align="center">L+ V+ T*</p> 
<p>Arbitrary standard Korean syllable blocks have a somewhat more complex form because they include any canonically equivalent sequence, thus including precomposed Korean syllables. The regular expressions for them have the following form:</p> 
<p align="center">(L+ V+ T*) | (L* LV V* T*) | (L* LVT T*)</p> 
<p>All standard Korean syllable blocks used in modern Korean are of the form &lt;L V T&gt; or &lt;L V&gt; and have equivalent, single-character precomposed 
forms.</p> 
<p>Old Korean characters are represented by a series of conjoining jamos. While the Unicode Standard allows for two L, V, or T characters as part of a syllable, KS X 1026-1 only allows single instances. Implementations that need to conform to KS X 1026-1 can tailor the default rules in <em>Section 3.1&nbsp; <a href="tr29-27.html#Default_Grapheme_Cluster_Table">Default Grapheme Cluster Boundary Specification</a></em> accordingly.</p> 
<h3>8.2 <a name="Transforming_Into_SKS" href="tr29-27.html#Transforming_Into_SKS">Transforming into Standard Korean Syllables</a></h3> 
<p>A sequence of jamos that do not all match the regular expression for a standard Korean syllable block can be transformed into a sequence of standard Korean syllable blocks by the correct insertion of choseong fillers (L<i><sub>f</sub></i> ) and jungseong fillers (V<i><sub>f</sub></i> ). This transformation of a string of text into standard Korean syllables is performed by determining the syllable breaks as explained in the earlier subsection “Hangul Syllable Boundaries,” then inserting one or two fillers as necessary to transform each syllable into a standard Korean syllable as shown in <a href="tr29-27.html#Inserting_Fillers"><i>Figure 6</i></a>. 

<p class="caption">Figure 6. 
  <a name="Inserting_Fillers" href="tr29-27.html#Inserting_Fillers">Inserting Fillers</a></p>

<div align="center">
<table class="simple">
  <tr>
    <td>L [^V] → L V<i><sub>f</sub></i> [^V]</td>
  </tr>
  <tr>
    <td>[^L] V → [^L] L<i><sub>f</sub></i> V</td>
  </tr>
  <tr>
    <td>[^V] T → [^V] L<i><sub>f</sub></i> V<i><sub>f</sub></i> T</td>
  </tr>
</table>
</div>

<p>In <i>Figure 6</i>
 [^X] indicates a character that is not X, or the absence of a character.</p> 
<p>In <a href="tr29-27.html#Korean_Syllable_Break_Examples"><i>Table 7</i></a>, the first row shows syllable breaks in a standard sequence, the second row shows syllable breaks in a nonstandard sequence, and the third row shows how the sequence in the second row could be transformed into standard form by inserting fillers into each syllable. Syllable breaks are shown by <i>middle dots</i> “·”.</p>

<p class="caption">Table 7. <a name="Korean_Syllable_Break_Examples" href="tr29-27.html#Korean_Syllable_Break_Examples">Korean Syllable Break Examples</a></p>
<div align="center"> 
<table class="subtle"> 
  <tbody> 
    <tr> 
      <th>No.</th> 
      <th>Sequence</th> 
      <th>&nbsp;</th> 
      <th>Sequence with Syllable Breaks Marked</th> 
    </tr> 
    <tr> 
      <td style="text-align:center">1</td> 
      <td>LVTLVLVLV<i><sub>f</sub></i> L<i><sub>f</sub></i> VL<i><sub>f</sub></i> V<i><sub>f</sub></i> T</td> 
      <td>→</td> 
      <td>LVT · LV · LV · LV<i><sub>f</sub></i> · L<i><sub>f</sub></i> V · L<i><sub>f</sub></i> V<i><sub>f</sub></i> T</td> 
    </tr> 
    <tr> 
      <td style="text-align:center">2</td> 
      <td>LLTTVVTTVVLLVV</td> 
      <td>→</td> 
      <td>LL · TT · VVTT · VV · LLVV</td> 
    </tr> 
    <tr> 
      <td style="text-align:center">3</td> 
      <td>LLTTVVTTVVLLVV</td> 
      <td>→</td> 
      <td>LLV<i><sub>f</sub></i> · L<i><sub>f</sub></i> V<i><sub>f</sub></i> TT · L<i><sub>f</sub></i> VVTT · L<i><sub>f</sub></i> VV · LLVV</td> 
    </tr> 
  </tbody> 
</table>
</div>

<h2 class="nonumber"><a name="Acknowledgments" href="tr29-27.html#Acknowledgments">Acknowledgments</a></h2>
  <p>Mark Davis is the author of the initial version and has added to and maintained the text of this annex. 
    Laurențiu Iancu has assisted in updating it for Versions 7.0 and 8.0.</p>
	<p>Thanks to Julie Allen, Asmus Freytag, Andy Heninger, Ted Hopp, Martin Hosken, Michael Kaplan, Eric Mader, Steve Tolkin, and Ken Whistler for their feedback on this annex, including earlier versions.</p>
  <h2 class="nonumber"><a name="References" href="tr29-27.html#References">References</a></h2>
    <p>For references for this annex, see Unicode Standard Annex #41, “<a href="../tr41/tr41-17.html">Common 
	References for Unicode Standard Annexes</a>.”</p>
  
  <h2 class="nonumber"><a name="Modifications" href="tr29-27.html#Modifications">Modifications</a></h2>
  <p>The following summarizes modifications from the previous versions of this 
	annex.</p>

  <h3>Revision 27 [KW, LI]</h3>
  <ul>
    <li><b>Reissued</b> for Unicode 8.0.</li>
    <li>Modified rule <a href="tr29-27.html#SB7">SB7</a> to prevent sentence breaks within a word segment such as “Mr.Hamster”.</li>
    <li>Updated notes on tailoring using CLDR boundary suppressions.</li>
    <li>Recast rule tables to use macros for compactness.</li>
    <li>Updated table styles, removed inconsistently applied styles on character names
      and code points, and adjusted layout of various tables and figures.</li>
    <li>Section 3.1 <a href="tr29-27.html#Default_Grapheme_Cluster_Table">Default Grapheme Cluster Boundary Specification</a> 
      <ul>
        <li>Removed the New Tai Lue characters U+19B0..U+19B4, U+19B8..U+19B9, U+19BB..U+19C0, U+19C8..U+19C9 from the exception list for <a href="tr29-27.html#SpacingMark">SpacingMark</a> in <a href="tr29-27.html#Grapheme_Cluster_Break_Property_Values">Table 2, <em>Grapheme_Cluster_Break Property Values</em></a>.</li>
        <li>Added U+11720 AHOM VOWEL SIGN A and U+11721 AHOM VOWEL SIGN AA to the same exception list for <a href="tr29-27.html#SpacingMark">SpacingMark</a>.</li>
      </ul>
    </li>
  </ul>

  <p>Revision 26 being a proposed update, only changes between versions 27 and 25 are noted here.</p>

  <h3>Revision 25</h3>
  <ul>
	<li><b>Reissued</b> for Unicode 7.0.</li>
	<li>General text cleanup, including “_” in property and property value names, use of curly-quotes and italics.</li>
	
    <li>Section 3.1 <a href="tr29-27.html#Default_Grapheme_Cluster_Table">Default Grapheme Cluster Boundary Specification</a> 
      <ul>
        <li>Added U+AA7D MYANMAR SIGN TAI LAING TONE-5 to the exception list for <a href="tr29-27.html#SpacingMark">SpacingMark</a> in <a href="tr29-27.html#Grapheme_Cluster_Break_Property_Values">Table 2, <em>Grapheme_Cluster_Break Property Values</em></a>.</li>
      </ul>
    </li>
	<li>Section 5.1 <a href="tr29-27.html#Default_Sentence_Boundaries">Default Sentence Boundary Specification</a>
      <ul>
        <li>Added note to clarify that Format and Extend characters are not joined to separators like LF.</li>
        <li>Added note about the fact that words can span a sentence break.</li>
      </ul>
    </li>
  </ul>
  
	<p>Revision 24 being a proposed update, only changes between versions 25 and 23 are noted here.</p>

  <h3>Revision 23</h3>
  <ul>
	<li><b>Reissued</b> for Unicode 6.3.0.</li>
    <li>Added U+02D7 ( ˗ ) MODIFIER LETTER MINUS SIGN to MidLetter.</li>
    <li>Corrected statement that grapheme clusters were atomic with respect to line boundaries.</li>
    <li>Simplified WB7c.</li>
    <li>Restored colon and equivalents (removed in previous draft).</li>
    <li>Removed colon from MidLetter, so that it is no longer contained within words. Handling of colon for word boundary determination in Swedish would be done by tailoring, instead – for example by a Swedish localization definition in CLDR.</li>
    <li>Allowed ' and &quot; in Hebrew words, since those are commonly used in place of U+05F3 ( ׳ ) HEBREW PUNCTUATION GERESH and U+05F4 ( ״ ) HEBREW PUNCTUATION GERSHAYIM.</li>
  </ul>

  	  <p>Revision 22 being a proposed update, only changes between versions 23 and 21 are noted here.</p>

  <h3>Revision 21</h3>
<ul>
		  <li><b>Reissued</b> for Unicode 6.2.0.</li>
		  <li>Modified property values and rules to prevent breaks between Regional_Indicator (RI) characters. (Sequences of more than two RI characters should be separated by other characters, such as U+200B ZERO WIDTH SPACE.)</li>
		  <li>Clarified regex in Table 1b, <em><a href="tr29-27.html#Table_Combining_Char_Sequences_and_Grapheme_Clusters">Combining Character Sequences and Grapheme Clusters</a></em>.</li>
          <li>Miscellaneous editorial changes.</li>
		</ul>

	  <p>Revision 20 being a proposed update, only changes between versions 21 and 19 are noted here.</p>

<h3>Revision 19</h3>
		<ul>
			<li><b>Reissued</b> for Unicode 6.1.0.</li>
			<li>In Table 2 
			added to <b>Control</b> those code points that are Cs and those Cn 
			that are also Default Ignorable, so that they do not join with 
			following Extend characters.</li>
			<li>In Table 2 
			Grapheme_Cluster_Break Property Values, changed Prepend and 
			SpacingMark class so for Thai, Lao and certain other SE Asian 
			scripts, extended grapheme clusters behave like legacy grapheme 
			clusters (except for handling of Thai SARA AM and Lao AM). In Table 
			1a. Sample Grapheme Clusters, adjusted examples and added more to 
			illustrate the new behavior. Removed the language added in draft 2 
			that put legacy and extended grapheme clusters on the same level. 
			Added language in the extended grapheme cluster definition 
			indicating the difference in user expectation for grapheme clusters 
			between Indic scripts and SE Asian scripts. Put extended and legacy 
			GCBs on the same level</li>
			<li>Moves the 
			discussion of Hangul Syllable segmentation from the core standard to 
			a new section 8 <a href="tr29-18.html#Hangul_Syllable_Boundary_Determination">Hangul 
			Syllable Boundary Determination</a>. Removed older statements about 
			Old Korean, replacing them with descriptions of restrictions in KS X 
			1026-1, and emphasizing that Unicode text segmentation can be 
			tailored for it.</li>
			<li>Added example 
			for word-interior hyphens in the Iu Mien language (written with the 
			Thai script).</li>
			<li>Clarified the 
			relation of Grapheme_Cluster_Break to the Grapheme_Base and 
			Grapheme_Extend properties.</li>
			<li>Made it clear 
			that the lists of characters are illustrative; the normative values 
			are in the data files.</li>
		</ul>

	  <p>Revision 18 being a proposed update, only changes between versions 19 and 17 are noted here.</p>

<h3>Revision 17</h3>
		<ul>
			<li><b>Reissued</b> for Unicode 6.0.0.</li>
			<li>Added anchors to tables and figures that did not have them.</li>
			<li>Moved explicitly listed Thai/Lao characters from Grapheme_Cluster_Break = Extend to Grapheme_Cluster_Break = SpacingMark to preserve behavior of legacy Grapheme clusters.</li>
			<li>Added TAI VIET characters to Grapheme_Cluster_Break = Prepend</li>
			<li>Added Hangul characters to the description of Grapheme_Cluster_Break property values for L, V, and T. (These property values were in Unicode 5.2, but the descriptive text had not been updated to match.)</li>
			<li>Added notes on  tailoring grapheme clusters for  <em>sara am</em> and <em>sign am</em> for Thai/Lao, and for <em>aksaras</em>.</li>
		</ul>
		<p>Revision 16 being a proposed update, only changes between versions 17 and 15 are noted here.</p>
		
<h3>Revision 15</h3>
		<ul>
			<li><strong>Reissued</strong> for Unicode 5.2.0</li>
			<li>Added characters that may be tailored to be in MidLetter.</li>
			<li>Added section 4.2 Name Validation</li>
			<li>Revised 6.3 <a href="tr29-27.html#Regular_Expressions">Regular Expressions</a></li>
			<li>Added a pointer from 3.1  
			<a href="tr29-27.html#Default_Grapheme_Cluster_Table">Default Grapheme Cluster Boundary Specification</a></li>
			<li>Many small wording changes.</li>
			<li>Changed property of ZWSP to XX (Any) in 4.1 
			<a href="tr29-27.html#Default_Word_Boundaries">Default Word Boundary Specification</a></li>
		</ul>
  <p><i>Revision 14 being a proposed update, only changes between versions 15 and 
	13 are noted here.</i></p>
			<h3>Revision 13</h3>
  <ul>
 	<li>Updated for Unicode 5.1.0.</li>
	<li>Revised the contents of <a href="tr29-27.html#SContinue">SContinue</a>.</li>
	<li>Added <a href="tr29-27.html#Newline">Newline</a>, and rules <a href="tr29-27.html#WB3a">WB3a</a> and
	<a href="tr29-27.html#WB3b">WB3b</a>.</li>
	<li>Added <a href="tr29-27.html#Prepend">Prepend</a>, and rule <a href="tr29-27.html#GB9b">GB9b</a>.</li>
	<li>Note that the GraphemeBreakTest now tests  grapheme clusters, since those are more 
	inclusive.</li>
	<li>Major revision of the 3 <a href="tr29-27.html#Grapheme_Cluster_Boundaries">Grapheme Cluster Boundaries</a>, 
	to reflect UTC decisions. Includes use of the name <i>extended grapheme 
	cluster</i>, and significant reordering and enhancement of the text.</li>
	<li>Added note on breaking between scripts in 4.1  <a href="tr29-27.html#Default_Word_Boundaries">Default Word Boundary Specification</a>.</li>
	<li>Added note on modifier letters.</li>
	<li>Added note on SB9-11.</li>
	<li>Added SContinue (sentence-continue) to improve sentence segmentation.</li>
	<li>Added MidNumLet to improve word segmentation, by allowing certain 
	characters to “bridge” both numbers and alphabetic words.</li>
	<li>Added informative note on the use of space in numbers.</li>
	<li>Made changes to property values for Word/Sentence break.</li>
	<li>Added CR, LF, Extend, Control as needed under Word and Sentence boundaries. 
	This caused all rules containing Sep to be changed.</li>
	<li>Clarified use of “Any”.</li>
	<li>Updated MidLetter to include U+2018.</li>
	<li>Fixed items that were noted in proof for 5.0.0.</li>
  </ul>
	<p><em>Revision 12 being a proposed update, only changes between versions 13 and 
	11 are noted here.</em></p>
  <h3>Revision 11</h3>
  <ul>
	<li>Removed NBSP from ALetter.</li>
	<li>Added note on problem with Sentence Break rules SB8 and SB11.</li>
    <li>Changed table format, minor edits.</li>
	<li>Cleaned up description of how to handle Ignore Rules</li>
	<li>Added more details on the test file formats (for the html files).</li>
	<li>Added note about identifiers and natural language.</li>
	<li>Added reference to LDML/CLDR.</li>
	<li>Modified GC treatment to 
    use the equivalent (but more straightforward) use of Extend* in Section 4, <i><a href="tr29-27.html#Word_Boundaries">Word 
    Boundaries</a></i>, and Section 5, <i><a href="tr29-27.html#Sentence_Boundaries">Sentence 
    Boundaries</a></i>. (This is equivalent because breaks are 
    not allowed within Hangul syllables by the other rules anyway.) Also unify the application of 
    Extend*  and Format*. This combines two rules into one in each set of rules (former 3 and 4 
    in Word Boundaries, 4 and 5 in Sentence Boundaries).</li>
	<li>Clarified how to apply “ignore” rules in Section 6.2, <i><a href="tr29-27.html#Grapheme_Cluster_and_Format_Rules">Grapheme 
    Cluster and Format Rules</a></i>, and combined Extend and Format</li>
	<li>Added “Do not break within CRLF” to Section 4, <i><a href="tr29-27.html#Word_Boundaries">Word 
    Boundaries</a></i>, and Section 5, <i><a href="tr29-27.html#Sentence_Boundaries">Sentence Boundaries</a></i>.</li>
	<li>Added 8a in Section 5, <i><a href="tr29-27.html#Sentence_Boundaries">Sentence Boundaries</a></i>, 
    to address an edge condition and fix a typo in #10.</li>
	<li>Replaced “user character” by “user-perceived character”.</li>
	<li>Reformed ALetter in Section 4, <i><a href="tr29-27.html#Word_Boundaries">Word 
    Boundaries</a></i>, to depend on Line_Break. Fixed references within properties.</li>
	<li>Removed Rule 0 of Section 4, <i><a href="tr29-27.html#Word_Boundaries">Word 
    Boundaries</a>.</i></li>
	<li>Clarified discussion of NFD, spelling checkers, and cleaned up 
    language around “engines” and “state machines” versus “implementations”.</li>
  </ul>
	<p>Revision 10 being a proposed update, only changes between versions 11 and 
	9 are noted here.</p>
  <h3>Revision 9.</h3>
  <ul>
    <li>Reworded introduction slightly, moved last half of Notation into the introduction.</li>
    <li>Added line above each boundary property value table pointing to the data files for the 
    precise definition of the properties.</li>
    <li>Added note to clarify that grapheme clusters are not broken in word or sentence boundaries.</li>
    <li>Clarified examples in <i>“1. Single boundaries”.</i></li>
    <li>Added pointer to UTS #10</li>
    <li>Change the “and not” formulation for clarity.<ul>
      <li>“and not X = true” → “and X = false”</li>
      <li>“and not X = Y” → “and X ≠ > Y”</li>
    </ul>
    </li>
  </ul>
  <p><b>Revision 8</b></p>
  <ul>
    <li>Modified the tables so as to make the property values orthogonal.</li>
    <li>Added Joiner/Non-Joiner.</li>
    <li>Added additional katakana characters.</li>
    <li>Removed MidNumLet, and added ExtendedNumLet (with corresponding changes to the rules).</li>
    <li>Moved the test files to the references.</li>
    <li>Fixed up the property file references.</li>
  </ul>
  <p><b>Revision 7</b></p>
  <ul>
    <li>Incorporated corrigendum for Hangul_Syllable_Type=L explanation, and adjusted for the 
    change in status of the Joiner characters.</li>
    <li>Added override for CB, SA, SG, and XX in wordbreak.</li>
    <li>Added “Any” entries, and note about precedence.</li>
    <li>Added NBSP, and removed GRAPHEME EXTEND = true from the “alphabetics”.</li>
    <li>Added data files with explicit property values.</li>
  </ul>
  <h3>Revision 6</h3>
  <ul>
    <li>Changed <a href="tr29-27.html#STerm">Term</a> to be the 4.0.1 UCD property STerm. Note: the new property 
    provides minor corrections as well.</li>
  </ul>
  <h3>Revision 4</h3>
  <ul>
    <li>
    <p>Updated boilerplate.</li>
    <li>Use the Grapheme_Extend property. Dropped note on Other_Grapheme_Extend, 
    because those changes are in UCD 4.0.0</li>
    <li>Deleted note on relation to 3.0 text. Replace reference to 3.2 with one 
    to 4.0.</li>
    <li>Replaced the lists of Korean chars by reference to the 
    Hangul_Syllable_Type, with the lists kept as examples. Added reference to the UCD.</li>
    <li>Simplified ALetter and OLetter, because some characters are changing from 
    Sk to Lm, and thus get included; other Sk are not really candidates for words.</li>
    <li>Subtracted characters from certain classes so they wouldn&#x2019;t overlap:
    <ul>
      <li>CR and LF from Control in Grapheme Break</li>
      <li>Soft hyphen from MidLetter in Word Break (because it is Cf in 4.0)</li>
      <li>ATerm, Term and GERESH from Close in 
      Sentence Break</li>
    </ul>
    </li>
    <li>Added note about finite-state machine; highlighted notes about adjacent 
    characters.</li>
    <li>Fixed the term “interior” (didn&#x2019;t match the rules); and some character 
    names.</li>
  </ul>
  <h3>Revision 3</h3>
  <ul>
    <li>Removal of two open issues, resolved by UTC</li>
    <li>Changed name of “character class” to “property value” for consistency</li>
    <li>Other_Grapheme_Extend now includes characters for canonical closure</li>
    <li>Minor changes to some other property values</li>
    <li>Some additional notes on tailoring words for French, Italian, and Hebrew</li>
    <li>Added Section 7, <i><a href="tr29-27.html#Testing">Testing</a>.</i></li>
    <li>Minor editing.</li>
  </ul>
  <h3>Revision 2</h3>
  <ul>
    <li>Simplified grapheme cluster.</li>
    <li>Handled format characters appropriately.</li>
    <li>Removed Hiragana × Hiragana from word break, as well as prefix/postfix for numbers (because 
    they should not block Whole-Word Search).</li>
    <li>Modified sentence break to catch edge conditions.</li>
    <li>Added conformance section, with more warnings throughout that these specifications need to 
    be tailored for different languages/orthographic conventions.</li>
    <li>Tightened up the specifications of the character classes.</li>
    <li>Clarified the rule process.</li>
    <li>Added explanations of the interaction with normalization.</li>
    <li>Added an implementation section (incorporating the previous Random Access section).</li>
  </ul>
  <hr width="50%">
  <p class="copyright">Copyright © 2000&ndash;2015 Unicode, Inc. All Rights 
  Reserved. The Unicode Consortium makes no expressed or implied warranty of any kind, and assumes 
  no liability for errors or omissions. No liability is assumed for incidental and consequential 
  damages in connection with or arising out of the use of the information or programs contained or 
  accompanying this technical report. The Unicode <a href="http://www.unicode.org/copyright.html">
  Terms of Use</a> apply.</p>
  <p class="copyright">Unicode and the Unicode logo are trademarks of Unicode, Inc., and are 
  registered in some jurisdictions.</p>
 </div> <!-- BODY -->

</body>

</html>
