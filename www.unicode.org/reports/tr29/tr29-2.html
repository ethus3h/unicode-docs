<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
       "http://www.w3.org/TR/REC-html40/loose.dtd"> 
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" href="../../unicode/reports/reports.css" type="text/css">
<title>UTR #29: Text Boundaries</title>
<style type="text/css">
<!--
.right       { text-align: Right }
.left        { text-align: Left }
.center      { text-align: Center }
.example2    { background-color: #FFFF99 }
.charlist    { font-size: 90%; font-family: monospace }
-->
</style>
</head>

<body bgcolor="#ffffff">

<table class="header" width="100%">
  <tr>
    <td class="icon"><a href="http://www.unicode.org"><img align="middle" alt="[Unicode]" border="0" src="../../webscripts/logo60s2.gif" width="34" height="33"></a>&nbsp;&nbsp;<a class="bar" href="http://www.unicode.org/unicode/reports">Technical 
      Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>
</table>
<div class="body">
  <h2 align="center"><i>Draft<br>
  </i>Unicode Technical Report #29</h2>
  <h1 align="right">Text Boundaries</h1>
  <table class="wide" border="1" width="100%">
    <tr>
      <td>Version</td>
      <td>2</td>
    </tr>
    <tr>
      <td>Authors</td>
      <td>Mark Davis (<a href="mailto:mark.davis@us.ibm.com">mark.davis@us.ibm.com</a>)</td>
    </tr>
    <tr>
      <td>Date</td>
      <td>2002-08-09</td>
    </tr>
    <tr>
      <td>This Version</td>
      <td><a href="tr29-2.html">http://www.unicode.org/reports/tr29/tr29-2.html</a></td>
    </tr>
    <tr>
      <td>Previous Version</td>
      <td><a href="tr29-1.html">http://www.unicode.org/reports/tr29/tr29-1.html</a></td>
    </tr>
    <tr>
      <td>Latest Version</td>
      <td><a href="../tr29.1">http://www.unicode.org/reports/tr29</a></td>
    </tr>
    <tr>
      <td>Tracking Number</td>
      <td><a href="tr29-2.html#Modifications">2</a></td>
  </table>
  <br>
  <h3><i>Summary</i></h3>
  <p><i><em>This document describes guidelines </em>for determining default 
  boundaries between certain significant text elements: grapheme clusters 
  (“user characters”), words, and sentences. For line-break boundaries, see <a href="http://www.unicode.org/unicode/reports/tr14/">UAX 
  #14: Line Breaking Properties</a>.</i></p>
  <h3><i>Status</i></h3>
  <p><i>This document is a draft <b>Unicode Technical Report</b>. Publication 
  does not imply endorsement by the Unicode Consortium. This is a draft document 
  which may be updated, replaced, or superseded by other documents at any time. 
  This is not a stable document; it is inappropriate to cite this document as 
  other than a work in progress.</i></p>
  <blockquote>
    <p align="left"><i><b>Note: </b>The intention is for this document to become 
    a UAX, once approved.</i></p>
  </blockquote>
  <p><i>A list of current Unicode Technical Reports is found on [<a href="tr29-2.html#Reports">Reports</a>]. 
  For more information about versions of the Unicode Standard, see [<a href="tr29-2.html#Versions">Versions</a>]. 
  Please mail corrigenda and other comments to the author(s).</i> <i>The <a href="tr29-2.html#References">References</a> 
  provide related information that is useful in understanding this document.</i></p>
  <p><i>Please mail corrigenda and other comments to the author(s).</i></p>
  <h3><i>Contents</i></h3>
  <ul>
    <li><a href="tr29-2.html#Introduction">1 Introduction</a>
      <ul>
        <li><a href="tr29-2.html#Notation">1.1 Notation</a></li>
      </ul>
    </li>
    <li><a href="tr29-2.html#Conformance">2 Conformance</a></li>
    <li><a href="tr29-2.html#Grapheme_Cluster_Boundaries">3 Grapheme Cluster Boundaries</a></li>
    <li><a href="tr29-2.html#Word_Boundaries">4 Word Boundaries</a></li>
    <li><a href="tr29-2.html#Sentence_Boundaries">5 Sentence Boundaries</a></li>
    <li><a href="tr29-2.html#Implementation_Notes">6 Implementation Notes</a>
      <ul>
        <li><a href="tr29-2.html#Normalization">6.1 Normalization</a></li>
        <li><a href="tr29-2.html#Grapheme_Cluster_and_Format_Rules">6.2 Grapheme Cluster 
          and Format Rules</a>
        <li><a href="tr29-2.html#Regular_Expressions">6.3 Regular Expressions</a></li>
        <li><a href="tr29-2.html#Random_Access">6.4 Random Access</a></li>
        <li><a href="tr29-2.html#Tailoring">6.5 Tailoring</a></li>
      </ul>
    </li>
    <li><a href="tr29-2.html#Acknowledgements">Acknowledgements</a></li>
    <li><a href="tr29-2.html#References">References</a></li>
    <li><a href="tr29-2.html#Modifications">Modifications</a></li>
  </ul>
  <h2>1 <a name="Introduction">Introduction</a></h2>
  <p>This document describes guidelines for determining default boundaries 
  between certain significant text elements: grapheme clusters (“user 
  characters”), words, and sentences. It updates most of <a href="http://www.unicode.org/unicode/uni2book/ch05.pdf">5.15 
  Locating Text Element Boundaries</a>, except for the line-break boundaries, 
  which are covered in <a href="http://www.unicode.org/unicode/reports/tr14/">UAX 
  #14: Line Breaking Properties</a>.</p>
  A string of Unicode-encoded text often needs to be broken up into text 
  elements programmatically. Common examples of text elements include what users 
  think of as characters, words, lines (more precisely, where line breaks are 
  allowed), and sentences. The precise determination of text elements may vary 
  according to orthographic conventions for a given script or language. The goal 
  of matching user perceptions cannot always be met exactly because the text 
  alone does not always contain enough information to unambiguously decide 
  boundaries. For example, the <em>period</em> (U+002E <span style="font-variant: small-caps">full 
  stop</span>) is used ambiguously, sometimes for end-of-sentence purposes, 
  sometimes for abbreviations, and sometimes for numbers. In most cases, 
  however, programmatic text boundaries can match user perceptions quite 
  closely, or at least not surprise the user.
  <p>Rather than concentrate on algorithmically searching for text elements 
  themselves, a simpler and more useful computation looks instead at detecting 
  the <i>boundaries</i> between those text elements. The determination of those 
  boundaries is often critical to the performance of general software, so it is 
  important to be able to make such a determination as quickly as possible.</p>
  <p>The default boundary determination mechanism provides a straightforward and 
  efficient way to determine some of the most significant boundaries in text: 
  grapheme clusters (what end-users usually think of as characters), words, and 
  sentences. (Line boundaries are to be found in <a href="http://www.unicode.org/unicode/reports/tr14/">UAX 
  #14: Line Breaking Properties</a>.)</p>
  <p>Boundary determination builds upon the uniform character representation of 
  the Unicode Standard, while handling the large number of characters and 
  special features such as combining marks and conjoining jamo in an effective 
  manner. As this mechanism lends itself to a completely data-driven 
  implementation, it can be tailored to particular orthographic conventions or 
  user preferences without recoding.</p>
  <p>The large character set of the Unicode Standard and its representational 
  power place requirements on both the specification of text element boundaries 
  and the underlying implementation. The specification needs to allow for the 
  designation of large sets of characters sharing the same characteristics (for 
  example, uppercase letters), while the implementation must provide quick 
  access and matches to those large sets. The mechanism also must handle special 
  features of the Unicode Standard, such as combining or nonspacing marks and 
  conjoining jamo.</p>
  <h3>1.1 <a name="Notation">Notation</a></h3>
  <p>A boundary specification defines different classes, then lists the rules 
  for boundaries in terms of those classes. The character classes are specified 
  as a list, where each element of the list is:
</div>
<blockquote>
  <ul>
    <li>A literal character</li>
    <li>A range of literal characters</li>
    <li>A property of a Unicode character, as defined in the Unicode Character 
      Database (UCD):
      <ul>
        <li>Non-boolean properties are given as <i>&lt;property&gt;=&lt;property 
          value&gt;</i>, such as General_Category = Titlecase_Letter.</li>
        <li>Boolean properties are given as <i>&lt;property&gt;=true</i>, such 
          as<br>
          Uppercase = true.</li>
        <li>Other conditions are specified textually in terms of UCD properties.</li>
      </ul>
    </li>
    <li>Boolean combinations of the above</li>
  </ul>
  <p>The two special classes <i>sot</i> and <i>eot</i> stand for start and end 
  of text respectively.</p>
</blockquote>
<div class="body">
  The rules are numbered for reference and are applied in order in order to 
  determine whether there is a boundary at a given offset. That is, there is an 
  implicit “otherwise” at the front of each rule following the first. So 
  logically the rules are processed from top to bottom. As soon as a rule 
  matches and produces a break or no-break result for that offset, the process 
  is terminated.
  <p>Each rule consists of a left side, a break symbol, and a right side. Either 
  of the sides can be empty. The left and right sides use the above classes in 
  regular expressions. For more information on regular expression syntax used, 
  see <a href="http://www.unicode.org/unicode/reports/tr18/">UTR #18: Unicode 
  Regular Expression Guidelines</a>.</p>
  <p>The break symbols are:</p>
  <table border="0" class="syntax">
    <tr>
      <td>
        <p>÷</p>
      </td>
      <td>Allow break here.</td>
    </tr>
    <tr>
      <td>×</td>
      <td>Do not allow break here.</td>
    </tr>
    <tr>
      <td>→</td>
      <td>Treat whatever on the left side as if it were what is on the right 
        side.</td>
    </tr>
  </table>
  <p>An <i>underscore </i>(“_”) is used to indicate a space in examples.</p>
  <p>As in other cases, these are a <i>logical</i> description of the processes: 
  implementations can achieve the same results without using code or data that 
  follows these rules step-by-step. In particular, most production-grade 
  implementations will use a state-table approach. In that case, the performance 
  does not depend on the complexity or number of rules. The only feature that 
  does affect performance is the number of characters that may match <i>after</i> 
  the boundary position in a rule that is matched.
  <p>Some additional constraints are reflected in the specification. These 
  constraints make the implementation significantly simpler and more efficient 
  and have not been found to be limitations for natural language use.</p>
  <ol>
    <li><i>Single boundaries. </i>Each rule has exactly one boundary position. 
      Because of constraint (1), this restriction is more a limitation on the 
      specification methods, because a rule with two boundaries could generally 
      be expressed as two rules. For example, “ab ÷ cd ÷ ef” could be 
      broken into “ab ÷ cd” and “cd ÷ ef”.</li>
    <li><i>Ignore degenerates. </i>No special provisions are made to get 
      marginally better behavior for degenerate cases that never occur in 
      practice, such as an <i>A</i> followed by an Indic combining mark.</li>
  </ol>
  <p><b>Editorial Note: </b>The Unicode 3.0 text contained text including more 
  constraints and other descriptions, but that text had fallen out of date, and 
  does not apply to the default boundaries described in this document, nor to <a href="http://www.unicode.org/unicode/reports/tr14/">UAX 
  #14: Line Breaking Properties</a>.</p>
  <p>Different issues are present with different types of boundaries, as the 
  following discussion and examples should make clear.</p>
  <h2>2 <a name="Conformance">Conformance</a></h2>
  <p>This is informative material. There are many different ways to divide text 
  elements corresponding to grapheme clusters, words and sentences, and the 
  Unicode Standard and this document do not restrict the ways in which 
  implementations can do this.</p>
  <p>This specification is a <i>default</i> mechanism; more sophisticated 
  engines can and should tailor it for particular locales or environments. For 
  example, good Thai, Lao, Chinese, or Japanese word-break boundaries require 
  the use of dictionary lookup, analogous to English hyphenation. An 
  implementation therefore may need to provide means to override or subclass the 
  default mechanism described in this document. Note that tailoring can <i>either</i> 
  add boundary positions <i>or</i> remove boundary positions, compared to the 
  default specified here.</p>
  <p>To maintain canonical equivalence, all of the following specifications are 
  defined on NFD text, as defined in <a href="../tr15.1">UAX 
  #15: Unicode Normalization Forms</a> [<a href="tr29-2.html#Reports">Reports</a>]. A 
  boundary exists in non-NFD text just in case it would occur at the 
  corresponding position in NFD text. However, this is only a logical 
  specification; in practice implementations can avoid normalization and achieve 
  the same results. For more information, see <a href="tr29-2.html#Implementation_Notes">§6 
  Implementation Notes</a>.</p>
  <h2><a name="Grapheme_Cluster_Boundaries">3 Grapheme Cluster Boundaries</a></h2>
  <p>One or more Unicode characters may make up what the user thinks of as a 
  character or basic unit of the language. To avoid ambiguity with the computer 
  use of the term <i>character,</i> this is called a <i>grapheme cluster</i>. 
  For example, “G” + <i>acute-accent</i> is a grapheme cluster: it is 
  thought of as a single character by users, yet is actually represented by two 
  Unicode code points. For more information on the ambiguity in the term <i>character</i>, 
  see <a href="http://www.unicode.org/unicode/reports/tr17/">UTR #17: Character 
  Encoding Model</a> [<a href="tr29-2.html#Reports">Reports</a>].</p>
  <p>Grapheme clusters include, but are not limited to, combining character 
  sequences such as (g + °), digraphs such as Slovak “ch”, and sequences 
  with letter modifiers such as k<sup>w</sup>. Grapheme cluster boundaries are 
  important for collation, regular-expressions, and counting “character” 
  positions within text.&nbsp; Word breaks, line breaks and sentence breaks do 
  not occur within a grapheme cluster. In this section, the Unicode Standard 
  provides a determination of where the default grapheme boundaries fall in a 
  string of characters. This algorithm can be tailored for specific locales or 
  other customizations, which is what is done in providing contracting 
  characters in collation tailoring tables.</p>
  <blockquote>
    <p><b>Note:</b> In previous documentation, default grapheme clusters were 
    previously referred to as “locale-independent graphemes”. The term <i>cluster</i> 
    has been added to emphasize that the term <i>grapheme</i> as used 
    differently in linguistics. For simplicity and to align with <a href="http://www.unicode.org/unicode/reports/tr10/">UTS 
    #10: Unicode Collation Algorithm</a>&nbsp; [<a href="tr29-2.html#Reports">Reports</a>], 
    the terms <i>default</i> and <i>tailored</i> are used in preference to <i>locale-independent</i> 
    and <i>locale-dependent</i>, respectively.</p>
  </blockquote>
  <p>As far as a user is concerned, the underlying representation of text is not 
  important, but it is important that an editing interface present a uniform 
  implementation of what the user thinks of as characters. Grapheme clusters 
  commonly behave as units in terms of mouse selection, arrow key movement, 
  backspacing, and so on. When this is done, for example, and an accented 
  character is represented by a combining character sequence, then using the 
  right arrow key would skip from the start of the base character to the end of 
  the last combining character. In some cases, editing a grapheme cluster 
  element by element may be the preferred way.</p>
  <p>In those rare circumstances where end-users need character counts, the 
  counts should correspond to the grapheme cluster boundaries.</p>
  <p>There is not a one-to-one relationship between grapheme clusters and keys 
  on a keyboard. A single key on a keyboard may correspond to: a whole grapheme 
  cluster, a part of a grapheme clusters, or a sequence of more than one 
  grapheme clusters.</p>
  <p>The principal requirements for default grapheme cluster boundaries are the 
  handling of combining marks and Hangul conjoining jamo. Boundaries may be 
  further tailored for requirements of different languages, such as the addition 
  of “ch” for Slovak, or Indic, Thai or Tibetan character clusters. For the 
  rules defining the default boundaries, see <i><a href="tr29-2.html#Default_Grapheme_Cluster_Table">Table 
  1, Default Grapheme Cluster Boundaries</a></i><a href="tr29-2.html#Default_Grapheme_Cluster_Table"> 
  </a>below.</p>
  <blockquote>
    <p><b>Note: </b>As with the other default specifications, implementations 
    are free to override (tailor) the results to meet the requirements of 
    different environments or particular languages.</p>
  </blockquote>
  <p align="center"><b>Table 1. <a name="Default_Grapheme_Cluster_Table">Default 
  Grapheme Cluster Boundaries</a></b></p>
  <table cellspacing="0" cellpadding="4" border="0">
    <caption class="left"><span style="COLOR: black">Character Classes</span></caption>
    <tbody>
      <tr>
        <td valign="top"><b>CR</b></td>
        <td><span class="charlist">U+000D CARRIAGE RETURN (CR</span></td>
      </tr>
      <tr>
        <td valign="top"><b>LF</b></td>
        <td><span class="charlist">U+000A LINE FEED (LF)</span></td>
      </tr>
      <tr>
        <td valign="top"><b>Control</b></td>
        <td>General_Category = Line Separator (Zl), or<br>
          General_Category = Paragraph Separator (Zp), or<br>
          General_Category = Control (Cc), or<br>
          General_Category = Format (Cf)</td>
      </tr>
      <tr>
        <td valign="top"><b>Extend</b></td>
        <td>General Category = Non-spacing Mark (Mn),<br>
          General_Category = Enclosing Mark (Me), or<br>
          Other_GraphemeExtend = true</td>
      </tr>
      <tr>
        <td valign="top"><b>L</b></td>
        <td>Hangul leading jamo:<span class="charlist"><br>
          U+1100..U+115F</span></td>
      </tr>
      <tr>
        <td valign="top"><b>V</b></td>
        <td>Hangul vowel jamo:<br>
          <span class="charlist">U+1160..U+11A2</span></td>
      </tr>
      <tr>
        <td valign="top"><b>T</b></td>
        <td>Hangul trailing jamo:<br>
          <span class="charlist">U+11A8..U+11F9</span></td>
      </tr>
      <tr>
        <td valign="top"><b>LV</b></td>
        <td>Any Hangul syllable that is canonically<br>
          equivalent to a sequence of &lt;L,V&gt;</td>
      </tr>
      <tr>
        <td valign="top"><b>LVT</b></td>
        <td>Any Hangul syllable that is canonically equivalent<br>
          to a sequence of &lt;L,V,T&gt;</td>
      </tr>
      <tr>
        <td valign="top"><b>Any</b></td>
        <td>Any character (includes all of the above)</td>
      </tr>
    </tbody>
  </table>
  <p>&nbsp;</p>
  <table cellspacing="0" cellpadding="4" border="0">
    <caption class="left">Rules</caption>
    <tbody>
      <tr>
        <td colspan="4">
          <p align="left"><i>Break at the start and end of text.</i></p>
        </td>
      </tr>
      <tr>
        <td class="right" width="45%">sot</td>
        <td class="center">÷</td>
        <td width="40%"></td>
        <td class="right">(1)</td>
      </tr>
      <tr>
        <td class="right"></td>
        <td class="center">÷</td>
        <td>eot</td>
        <td class="right">(2)</td>
      </tr>
      <tr>
        <td colspan="4">
          <p align="left"><i>Do not break between a CR and LF. Otherwise break 
          before and after controls.</i></p>
        </td>
      </tr>
      <tr>
        <td class="right">CR</td>
        <td class="center">×</td>
        <td>LF</td>
        <td class="right">(3)</td>
      </tr>
      <tr>
        <td class="right">Control</td>
        <td class="center">÷</td>
        <td></td>
        <td class="right">(4)</td>
      </tr>
      <tr>
        <td class="right"></td>
        <td class="center">÷</td>
        <td>Control</td>
        <td class="right">(5)</td>
      </tr>
      <tr>
        <td align="right" colspan="4">
          <p align="left"><i>Do not break Hangul syllable sequences.</i></p>
        </td>
      </tr>
      <tr>
        <td class="right">L</td>
        <td class="center">×</td>
        <td>( L | V | LV | LVT )</td>
        <td class="right">(6)</td>
      </tr>
      <tr>
        <td class="right">( LV | V )</td>
        <td class="center">×</td>
        <td>( V | T )</td>
        <td class="right">(7)</td>
      </tr>
      <tr>
        <td class="right">( LVT | T)</td>
        <td class="center">×</td>
        <td>T</td>
        <td class="right">(8)</td>
      </tr>
      <tr>
        <td align="right" colspan="4">
          <p align="left"><i>Do not break before extending characters.</i></p>
        </td>
      </tr>
      <tr>
        <td class="right">&nbsp;</td>
        <td class="center">×</td>
        <td>Extend</td>
        <td class="right">(9)</td>
      </tr>
      <tr>
        <td align="right" colspan="4">
          <p align="left"><i>Otherwise, break everywhere.</i></p>
        </td>
      </tr>
      <tr>
        <td class="right">Any</td>
        <td class="center">÷</td>
        <td>Any</td>
        <td class="right">(10)</td>
      </tr>
    </tbody>
  </table>
  <p>A default grapheme cluster normally begins with a base character. 
  Exceptions are when a combining mark is at the start of text, or it is 
  preceded by a control (or format) character. The boundary of a default 
  grapheme cluster can be determined by just the adjacent characters.</p>
  <p>For more information on the composition of Hangul Syllables (with L, V, or 
  T) see <a href="../tr28/index.html#3_11_conjoining_jamo_behavior">3.11 
  Conjoining Jamo Behavior (revision)</a> in <a href="../tr28/index.html">UAX 
  #28: Unicode Version 3.2</a> [<a href="tr29-2.html#Reports">Reports</a>].</p>
  <p><b><i>Degenerate Cases.</i> </b>As with other definitions in Chapter 5 and 
  elsewhere, such definitions are designed to be simple to implement. They need 
  to provide an algorithmic determination of the valid, default grapheme 
  clusters, and exclude sequences that are normally not considered default 
  grapheme clusters. However, they do <i>not</i> have to catch edge cases that 
  will not occur in practice.</p>
  <p>The definition of default grapheme clusters is not meant to exclude the use 
  of more sophisticated definitions of tailored grapheme clusters where 
  appropriate: definitions that more precisely match the user expectations 
  within individual languages. For example, “ch” may be considered a 
  grapheme cluster in Slovak. It is, however, designed to provide a much more 
  accurate match to overall user expectations for <i>characters</i> than is 
  provided by individual Unicode code points.</p>
  <p><b><i>Display of Grapheme Clusters.</i> </b>Grapheme clusters are not the 
  same as ligatures. For example, the grapheme cluster “ch” in Slovak is not 
  normally a ligature, and conversely, the ligature “fi” is not a grapheme 
  cluster. Default grapheme clusters do not necessarily reflect text display. 
  For example, the sequence &lt;f, i&gt; may be displayed as a single glyph on 
  the screen, but would still be two grapheme clusters.</p>
  <p>For more information on the use of grapheme clusters, see <a href="http://www.unicode.org/unicode/reports/tr18/">UTR 
  #18: Unicode Regular Expression Guidelines</a>&nbsp; [<a href="tr29-2.html#Reports">Reports</a>].</p>
  <h2><a name="Word_Boundaries">4 Word Boundaries</a></h2>
  <p>Word boundaries are used in a number of different contexts. The most 
  familiar ones are double-click mouse selection, “move to next word” 
  control-arrow keys, and “Whole Word Search” (WWS) for search and replace. 
  They are also used in database queries, to determine whether elements are 
  within a certain number of words of one another.</p>
  <p>Word boundaries can also be used in so-called <i>intelligent cut and paste</i>. 
  With this feature, if the user cuts a piece of text on word boundaries, 
  adjacent spaces are collapsed to a single space. For example, cutting 
  “quick” from “The_quick_fox” would leave “The_&nbsp;_fox”. 
  Intelligent cut and paste collapses this text to “The_fox”.</p>
  <p align="left">Here is an example of word boundaries.</p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" border="1">
      <caption class="left"><i>Example 1: Word Boundaries</i></caption>
      <tbody>
        <tr>
          <td>The</td>
          <td>&nbsp;</td>
          <td>quick</td>
          <td>&nbsp;</td>
          <td>(</td>
          <td>“</td>
          <td>brown</td>
          <td>”</td>
          <td>)</td>
          <td>&nbsp;</td>
          <td>fox</td>
          <td>&nbsp;</td>
          <td>can’t</td>
          <td>&nbsp;</td>
          <td>jump</td>
          <td>&nbsp;</td>
          <td>32.3</td>
          <td>&nbsp;</td>
          <td>feet</td>
          <td>,</td>
          <td>&nbsp;</td>
          <td>right</td>
          <td>?</td>
        </tr>
      </tbody>
    </table>
  </div>
  <p>There is a boundary, for example, on either side of the word <i>brown</i>. 
  These are the boundaries that users would expect, for example, if they chose 
  WWS. Matching <i>brown</i> with WWS works, since there is a boundary on either 
  side. Matching <i>brow</i> doesn’t. Matching <i>“brown”</i> also works, 
  since there are boundaries between the parentheses and the quotation marks.</p>
  <p>For proximity tests, one sees whether, for example, “monster” is within 
  3 words of “truck”. That is done with the above boundaries by ignoring any 
  words that do not contain a letter (or perhaps digit — whether or not digits 
  count is task-specific), as in Example 2 below. Thus for proximity, “fox” 
  is within three words of “quick”. This same technique can be used for 
  “get next/previous word” commands or keyboard arrow-keys. There are other 
  cases where the characters between given boundaries are ignored, based on the 
  other types of characters.</p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" border="1">
      <caption class="left"><i>Example 2: Extracted Words</i></caption>
      <tbody>
        <tr>
          <td>The</td>
          <td>quick</td>
          <td>brown</td>
          <td>fox</td>
          <td>can’t</td>
          <td>jump</td>
          <td>32.3</td>
          <td>feet</td>
          <td>right</td>
        </tr>
      </tbody>
    </table>
  </div>
  <p>The word boundaries are related to the line boundaries, but are distinct: 
  there are some word-break boundaries that are not line-break boundaries and 
  vice-versa. However, it is relatively seldom that a line-break boundary is not 
  a word-break boundary. One example is a word containing a SHY (soft hyphen). 
  It will break across lines, yet is a single word.</p>
  <blockquote>
    <p><b>Note: </b>As with the other default specifications, implementations 
    are free to override (tailor) the results to meet the requirements of 
    different environments or particular languages.</p>
  </blockquote>
  <p align="center"><b>Table 2. <a name="Default_Word_Boundaries">Default Word 
  Boundaries</a></b></p>
  <table cellspacing="0" cellpadding="4" border="0">
    <caption class="left"><span style="COLOR: black">Character Classes</span></caption>
    <tbody>
      <tr>
        <td valign="top">Format</td>
        <td>General_Category = Format (Cf)</td>
      </tr>
      <tr>
        <td valign="top">Katakana</td>
        <td>Script = KATAKANA, <i>or<br>
          </i>Any of the following:<br>
          <span class="charlist">U+30FC # KATAKANA-HIRAGANA PROLONGED SOUND MARK<br>
          U+FF70 # HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK<br>
          U+FF9E..U+FF9F # HALFWIDTH KATAKANA SOUND MARKS</span></td>
      </tr>
      <tr>
        <td valign="top">ALetter</td>
        <td>Alphabetic = true, <i>or</i><br>
          Any of the following modifier letters:<br>
          <span class="charlist">U+02B9..U+02BA # PRIME..DOUBLE PRIME<br>
          U+02C2..U+02CF # LEFT ARROWHEAD..LOW ACUTE ACCENT<br>
          U+02D2..U+02DF # CENTRED RIGHT HALF RING..CROSS ACCE<br>
          U+02E5..U+02ED # EXTRA-HIGH TONE BAR..UNASPIRATED<br>
          U+05F3 (׳) geresh<br>
          </span><font size="2"><br>
          </font><i>and not </i>Ideographic = true<br>
          <i>and not</i> Katakana = true<i><br>
          and not</i> Script = Thai<br>
          <i>and not</i> Script = Lao<br>
          <i>and not</i> Script = Hiragana</td>
      </tr>
      <tr>
        <td valign="top">MidLetter</td>
        <td>Any of the following:<br>
          <span class="charlist">U+0027 (') apostrophe<br>
          U+00AD () soft hyphen<br>
          U+05F4 (״) gershayim<br>
          U+2019 (’) curly apostrophe</span></td>
      </tr>
      <tr>
        <td valign="top">MidNumLet</td>
        <td>Any of the following:<span class="charlist"><br>
          U+002E (.) period<br>
          U+003A (:) colon (used in Swedish)</span></td>
      </tr>
      <tr>
        <td valign="top">MidNum</td>
        <td>Line_Break = Infix_Numeric<br>
          <i>and not</i> MidNumLet = true</td>
      </tr>
      <tr>
        <td valign="top"><i>other</i></td>
        <td>Other categories are from Line_Break<br>
          <i>(using the long names from PropertyAliases)</i></td>
      </tr>
    </tbody>
  </table>
  <p>&nbsp;</p>
  <table cellspacing="0" cellpadding="4" border="0">
    <caption class="left">Rules</caption>
    <tr>
      <td colspan="4">
        <p align="left"><i>Break at the start and end of text.</i></p>
      </td>
    </tr>
    <tr>
      <td class="right" width="45%">sot</td>
      <td class="center">÷</td>
      <td width="40%"></td>
      <td class="right">(1)</td>
    </tr>
    <tr>
      <td class="right"></td>
      <td class="center">÷</td>
      <td>eot</td>
      <td class="right">(2)</td>
    </tr>
    <tr>
      <td align="right" colspan="4">
        <p align="left"><i>Treat a grapheme cluster as if it were a single 
        character: the first character of the cluster.</i></p>
      </td>
    </tr>
    <tr>
      <td>
        <p align="right" class="right">GC</p>
      </td>
      <td align="right">
        <p class="center">→</p>
      </td>
      <td align="right">FB</td>
      <td class="right">(3)</td>
    </tr>
    <tr>
      <td colspan="4">
        <p align="left"><i>Ignore interior Format characters. That is, ignore 
        Format characters in all subsequent rules (except the last rule).</i></p>
      </td>
    </tr>
    <tr>
      <td class="right">X Format*</td>
      <td class="center">→</td>
      <td>X</td>
      <td class="right">(4)</td>
    </tr>
    <tr>
      <td colspan="4">
        <p align="left"><i>Do not break between most letters.</i></p>
      </td>
    </tr>
    <tr>
      <td class="right">ALetter</td>
      <td class="center">×</td>
      <td>ALetter</td>
      <td class="right">(5)</td>
    </tr>
    <tr>
      <td colspan="4">
        <p align="left"><i>Do not break letters across certain punctuation.</i></p>
      </td>
    </tr>
    <tr>
      <td class="right">ALetter</td>
      <td class="center">×</td>
      <td>(MidLetter | MidNumLet) ALetter</td>
      <td class="right">(6)</td>
    </tr>
    <tr>
      <td class="right">ALetter (MidLetter | MidNumLet)</td>
      <td class="center">×</td>
      <td>ALetter</td>
      <td class="right">(7)</td>
    </tr>
    <tr>
      <td colspan="4">
        <p align="left"><i>Do not break within sequences of digits, or digits 
        adjacent to letters ('3a', or 'A3').</i></p>
      </td>
    </tr>
    <tr>
      <td class="right">Numeric</td>
      <td class="center">×</td>
      <td>Numeric</td>
      <td class="right">(8)</td>
    </tr>
    <tr>
      <td class="right">ALetter</td>
      <td class="center">×</td>
      <td>Numeric</td>
      <td class="right">(9)</td>
    </tr>
    <tr>
      <td class="right">Numeric</td>
      <td class="center">×</td>
      <td>ALetter</td>
      <td class="right">(10)</td>
    </tr>
    <tr>
      <td colspan="4">
        <p align="left"><i>Do not break within sequences like: ‘3.2’ or 
        '3,456.789'.</i></p>
      </td>
    </tr>
    <tr>
      <td class="right">Numeric (MidNum | MidNumLet)</td>
      <td class="center">×</td>
      <td>Numeric</td>
      <td class="right">(11)</td>
    </tr>
    <tr>
      <td class="right">Numeric</td>
      <td class="center">×</td>
      <td>(MidNum | MidNumLet) Numeric</td>
      <td class="right">(12)</td>
    </tr>
    <tr>
      <td colspan="4">
        <p align="left"><i>Do not break between Katakana.</i></p>
      </td>
    </tr>
    <tr>
      <td class="right">Katakana</td>
      <td class="center">×</td>
      <td>Katakana</td>
      <td class="right">(13)</td>
    </tr>
    <tr>
      <td colspan="4">
        <p align="left"><i>Otherwise, break everywhere (including around 
        ideographs).</i></p>
      </td>
    </tr>
    <tr>
      <td class="right">Any</td>
      <td class="center">÷</td>
      <td>Any</td>
      <td class="right">(14)</td>
    </tr>
  </table>
  <br>
  <b>Notes:</b>
  <ul>
    <li>
      <p align="left">Unfortunately not all issues can be resolved across 
      languages (or even within a language, since there are ambiguities). The 
      goal is to have as workable a default as possible; tailored engines can be 
      more sophisticated about these matters.</p>
    <li>
      <p align="left">Thai, Lao, Japanese and Chinese are cases where, as in 
      LineBreak, a good implementation should not just depend on the default 
      word boundary specification, but should use a more sophisticated 
      mechanism. There must be some default, however, in the absence of such a 
      mechanism. Where Hangul text is written without spaces, the same applies.</p>
    <li>
      <p align="left">The hard hyphen is a tricky case. It is quite common for 
      separate words to be connected with a hyphen: out-of-the-box, 
      under-the-table, Anglo-american, etc. A significant number are hyphenated 
      names: Smith-Hawkins, etc. When people do a “Whole Word” search or 
      query, they expect to find the word within those hyphens. While there are 
      some cases where they are separate words (usually to resolve some 
      ambiguity such as re-sort vs. resort) it’s better overall to keep the 
      hard hyphen out of the default definition.</p>
    <li>
      <p align="left">Apostrophe is another tricky case. Usually considered part 
      of one word (“can’t”, “aujourd’hui”) it may also be considered 
      two (“l’objectif”). Also, one cannot easily distinguish the cases 
      where it is used as a quotation mark from those where it is used as an 
      apostrophe, so one should not include leading or trailing apostrophes. In 
      some languages, such as French, tailoring it to break words may yield 
      better results in more cases.</p>
    <li>
      <p align="left">Certain cases like colon in words (c:a) are included even 
      though they may be specific to relatively small user communities (Swedish) 
      because they don’t occur otherwise in normal text, and so don’t cause 
      a problem for other languages.</p>
    </li>
    <li>
      <p align="left">Format characters are ignored if they are interior. Thus 
      &lt;LRM&gt;&lt;letter&gt; will break, and &lt;letter&gt;&lt;LRM&gt; will 
      break, but there is no break in &lt;letter&gt;&lt;LRM&gt;&lt;letter&gt;.</p>
    </li>
  </ul>
  <table border="1" width="100%" class="example">
    <tr>
      <td><b><i>Open Issue:</i></b>
        <p>As noted above, for Thai, Lao, Japanese and Chinese, a proper 
        implementation will really be dictionary-based. The rule for <i>katakana</i> 
        is included above, since the vast majority of the time there is no 
        break.</p>
        <p>We could implement some rules that would disallow breaks where they 
        clearly cannot happen; however, it is unclear whether that would be 
        worth the effort. The rules could be something like the following for 
        the given scripts:</p>
        <ul>
          <li>Never break between prefix letters and letters</li>
          <li>Never break between letters and suffix characters</li>
        </ul>
        <p>Where prefix letters are something like:</p>
        <p>Prefix:</p>
        <p><span class="charlist">U+0E40..U+0E44 # THAI CHARACTER SARA E..THAI 
        CHARACTER SARA AI MAIMALAI<br>
        U+0EC0..U+0EC4 # LAO VOWEL SIGN E..LAO VOWEL SIGN AI</span></p>
        <p>Suffix:</p>
        <p><span class="charlist">U+0E30 # THAI CHARACTER SARA A<br>
        U+0E32..U+0E33 # THAI CHARACTER SARA AA..THAI CHARACTER SARA AM<br>
        U+0E45..U+0E46 # THAI CHARACTER LAKKHANGYAO..THAI CHARACTER MAIYAMOK<br>
        U+0EB0 # LAO VOWEL SIGN A<br>
        U+0EB2..U+0EB3 # LAO VOWEL SIGN AA..LAO VOWEL SIGN AM<br>
        U+0EBD # LAO SEMIVOWEL SIGN NYO<br>
        U+0EC6 # LAO KO LA<br>
        U+17D7 # KHMER SIGN LEK TOO<br>
        U+3005 # IDEOGRAPHIC ITERATION MARK<br>
        U+303B..U+303C # VERTICAL IDEOGRAPHIC ITERATION MARK..MASU MARK<br>
        U+3041 # HIRAGANA LETTER SMALL A<br>
        U+3043 # HIRAGANA LETTER SMALL I<br>
        U+3045 # HIRAGANA LETTER SMALL U<br>
        U+3047 # HIRAGANA LETTER SMALL E<br>
        U+3049 # HIRAGANA LETTER SMALL O<br>
        U+3063 # HIRAGANA LETTER SMALL TU<br>
        U+3083 # HIRAGANA LETTER SMALL YA<br>
        U+3085 # HIRAGANA LETTER SMALL YU<br>
        U+3087 # HIRAGANA LETTER SMALL YO<br>
        U+308E # HIRAGANA LETTER SMALL WA<br>
        U+3095..U+3096 # HIRAGANA LETTER SMALL KA..HIRAGANA LETTER SMALL KE<br>
        U+309D..U+309E # HIRAGANA ITERATION MARK..HIRAGANA VOICED ITERATION MARK<br>
        U+30FC # KATAKANA-HIRAGANA PROLONGED SOUND MARK</span></p>
      </td>
    </tr>
  </table>
  <p align="left">&nbsp;</p>
  <h2><a name="Sentence_Boundaries">5 Sentence Boundaries</a></h2>
  <p>Sentence boundaries are often used for triple-click or some other method of 
  selecting or iterating through blocks of text that are larger than single 
  words. They are also used to determine whether words occur within the same 
  sentence in database queries.</p>
  <p>Plain text provides inadequate information for determining good sentence 
  boundaries. Periods, for example, can either signal the end of a sentence, 
  indicate abbreviations, or be used for decimal points. Remember that these 
  are, like the others, default boundaries, and may be tailored. One cannot, 
  without much more sophisticated analysis, distinguish between cases like:</p>
  <blockquote>
    <table cellspacing="0" cellpadding="0" border="1">
      <tbody>
        <tr>
          <td>He said, “Are you going?”&nbsp;</td>
          <td>Mr. Smith shook his head.</td>
        </tr>
      </tbody>
    </table>
    <table cellspacing="0" cellpadding="0" border="1">
      <tbody>
        <tr>
          <td>“Are you going?” Mr. Smith asked.</td>
        </tr>
      </tbody>
    </table>
  </blockquote>
  <p class="MsoNormal" style="MARGIN-TOP: 6pt; TEXT-ALIGN: justify">Without 
  analyzing the text semantically, it is impossible to be certain which of these 
  usages is intended (and sometimes ambiguities still remain). However, in a 
  large majority of cases, a straightforward mechanism works well.</p>
  <blockquote>
    <p><b>Note: </b>As with the other default specifications, implementations 
    are free to override (tailor) the results to meet the requirements of 
    different environments or particular languages.</p>
  </blockquote>
  <p align="center"><b>Table 3. <a name="Default_Sentence_Boundaries">Default 
  Sentence Boundaries</a></b></p>
  <table cellspacing="0" cellpadding="4" border="0">
    <caption class="left"><span style="COLOR: black">Character Classes</span></caption>
    <tbody>
      <tr>
        <td valign="top">Sep</td>
        <td>Any of the following characters:<br>
          <span class="charlist">U+000A LINE FEED (LF)<br>
          U+000D CARRIAGE RETURN (CR)<br>
          U+0085 NEXT LINE (NEL)<br>
          U+2028 LINE SEPARATOR (LS)<br>
          U+2029 PARAGRAPH SEPARATOR (PS)</span></td>
      </tr>
      <tr>
        <td valign="top">Format</td>
        <td>General_Category = Format (Cf)</td>
      </tr>
      <tr>
        <td valign="top">Sp</td>
        <td>Whitespace = true<br>
          <i>and not </i>Sep = true</td>
      </tr>
      <tr>
        <td valign="top">Lower</td>
        <td>Lowercase = true</td>
      </tr>
      <tr>
        <td valign="top">Upper</td>
        <td>General_Category = Titlecase_Letter (Lt), <i>or</i><br>
          Uppercase = true</td>
      </tr>
      <tr>
        <td valign="top">OLetter</td>
        <td>Alphabetic = true, <i>or</i><br>
          Any of the following modifier letters:<br>
          <span class="charlist">U+02B9..U+02BA # PRIME..DOUBLE PRIME<br>
          U+02C2..U+02CF # LEFT ARROWHEAD..LOW ACUTE ACCENT<br>
          U+02D2..U+02DF # CENTRED RIGHT HALF RING..CROSS ACCE<br>
          U+02E5..U+02ED # EXTRA-HIGH TONE BAR..UNASPIRATED<br>
          U+05F3 (׳) geresh<br>
          </span><i>and not</i> Lower = true<br>
          <i>and not </i>Upper = true </td>
      </tr>
      <tr>
        <td valign="top">Close</td>
        <td>General_Category = Open_Punctuation (Po), <i>or</i><br>
          General_Category = End_Punctuation (Pe), <i>or</i><br>
          Linebreak = Quotation (QU)</td>
      </tr>
      <tr>
        <td valign="top">ATerm</td>
        <td>Any of the following characters:<br>
          <span class="charlist">U+002E FULL STOP</span></td>
      </tr>
      <tr>
        <td valign="top">Term</td>
        <td>Any of the following characters:<br>
          <span class="charlist">U+0021 EXCLAMATION MARK<br>
          U+003F QUESTION MARK<br>
          U+0589 ARMENIAN FULL STOP<br>
          U+061F ARABIC QUESTION MARK<br>
          U+06D4 ARABIC FULL STOP<br>
          U+0700 SYRIAC END OF PARAGRAPH<br>
          U+0701 SYRIAC SUPRALINEAR FULL STOP<br>
          U+0702 SYRIAC SUBLINEAR FULL STOP<br>
          U+0964 DEVANAGARI DANDA<br>
          U+1362 ETHIOPIC FULL STOP<br>
          U+1367 ETHIOPIC QUESTION MARK<br>
          U+1368 ETHIOPIC PARAGRAPH SEPARATOR<br>
          U+1803 MONGOLIAN FULL STOP<br>
          U+1809 MONGOLIAN MANCHU FULL STOP<br>
          U+203C DOUBLE EXCLAMATION MARK<br>
          U+203D INTERROBANG<br>
          U+2048 QUESTION EXCLAMATION MARK<br>
          U+2049 EXCLAMATION QUESTION MARK<br>
          U+3002 IDEOGRAPHIC FULL STOP<br>
          U+FE52 SMALL FULL STOP<br>
          U+FE57 SMALL EXCLAMATION MARK<br>
          U+FF01 FULLWIDTH EXCLAMATION MARK<br>
          U+FF0E FULLWIDTH FULL STOP<br>
          U+FF1F FULLWIDTH QUESTION MARK<br>
          U+FF61 HALFWIDTH IDEOGRAPHIC FULL STOP</span></td>
      </tr>
    </tbody>
  </table>
  <p>&nbsp;</p>
  <table cellspacing="0" cellpadding="4" border="0">
    <caption class="left">Rules</caption>
    <tbody>
      <tr>
        <td colspan="4">
          <p align="left"><i>Break at the start and end of text.</i></p>
        </td>
      </tr>
      <tr>
        <td class="right" width="45%">sot</td>
        <td class="center">÷</td>
        <td width="40%"></td>
        <td class="right">(1)</td>
      </tr>
      <tr>
        <td class="right"></td>
        <td class="center">÷</td>
        <td>eot</td>
        <td class="right">(2)</td>
      </tr>
      <tr>
        <td colspan="4">
          <p align="left"><i>Break after paragraph separators.</i></p>
        </td>
      </tr>
      <tr>
        <td align="right" class="right">Sep</td>
        <td class="center">÷</td>
        <td></td>
        <td class="right">(3)</td>
      </tr>
      <tr>
        <td align="right" colspan="4">
          <p align="left"><i>Treat a grapheme cluster as if it were a single 
          character: the first character of the cluster.</i></p>
        </td>
      </tr>
      <tr>
        <td>
          <p align="right" class="right">GC</p>
        </td>
        <td align="right">
          <p class="center">→</p>
        </td>
        <td align="right">FB</td>
        <td class="right">(4)</td>
      </tr>
      <tr>
        <td colspan="4">
          <p align="left"><i>Ignore interior Format characters. That is, ignore 
          Format characters in all subsequent rules.</i></p>
        </td>
      </tr>
      <tr>
        <td class="right">X Format*</td>
        <td class="center">→</td>
        <td>X</td>
        <td class="right">(5)</td>
      </tr>
      <tr>
        <td colspan="4">
          <p align="left"><i>Do not break after ambiguous terminators like 
          period, if the first following letter is lowercase, or if the 
          immediately following letter is uppercase. For example, a period may 
          be an abbreviation or numeric period, and not mark the end of a 
          sentence.</i></p>
        </td>
      </tr>
      <tr>
        <td class="right">ATerm Close* Sp*</td>
        <td class="center">×</td>
        <td>(¬( OLetter | Upper ))* Lower</td>
        <td class="right">(6)</td>
      </tr>
      <tr>
        <td class="right">ATerm</td>
        <td class="center">×</td>
        <td>Upper</td>
        <td class="right">(7)</td>
      </tr>
      <tr>
        <td colspan="4">
          <p align="left"><i>Break after sentence terminators, but include 
          closing punctuation, trailing spaces, and (optionally) a paragraph 
          separator.</i></p>
        </td>
      </tr>
      <tr>
        <td class="right">( Term | ATerm ) Close*</td>
        <td class="center">×</td>
        <td>( Close | Sp | Sep )</td>
        <td class="right">(8)</td>
      </tr>
      <tr>
        <td class="right">( Term | ATerm ) Close* Sp</td>
        <td class="center">×</td>
        <td>( Sp | Sep )</td>
        <td class="right">(9)</td>
      </tr>
      <tr>
        <td class="right">( Term | ATerm ) Close* Sp*</td>
        <td class="center">÷</td>
        <td></td>
        <td class="right">(10)</td>
      </tr>
      <tr>
        <td colspan="4">
          <p align="left"><i>Otherwise, do not break</i></p>
        </td>
      </tr>
      <tr>
        <td class="right">Any</td>
        <td class="center">×</td>
        <td>Any</td>
        <td class="right">(11)</td>
      </tr>
    </tbody>
  </table>
  <p>&nbsp;</p>
  <table border="1" width="100%" class="example">
    <tr>
      <td width="100%"><i><b>Open Issues: </b></i>
        <ul>
          <li>There probably need to be additional modifications for numerics, 
            and for multiple terminators.</li>
          <li>Reviewers should especially consider the composition of Term and 
            ATerm: whether any characters should be added, removed, or moved 
            from one to the other. For comparison, the following characters from 
            the property Terminal_Punctuation are not included above.</li>
        </ul>
        <p><span class="charlist">U+0387 GREEK ANO TELEIA<br>
        U+0703 SYRIAC SUPRALINEAR COLON<br>
        U+0704 SYRIAC SUBLINEAR COLON<br>
        U+0705 SYRIAC HORIZONTAL COLON<br>
        U+0706 SYRIAC COLON SKEWED LEFT<br>
        U+0707 SYRIAC COLON SKEWED RIGHT<br>
        U+0708 SYRIAC SUPRALINEAR COLON SKEWED LEFT<br>
        U+0709 SYRIAC SUBLINEAR COLON SKEWED RIGHT<br>
        U+070A SYRIAC CONTRACTION<br>
        U+070C SYRIAC HARKLEAN METOBELUS<br>
        U+0965 DEVANAGARI DOUBLE DANDA<br>
        U+0E5A THAI CHARACTER ANGKHANKHU<br>
        U+0E5B THAI CHARACTER KHOMUT<br>
        U+104A MYANMAR SIGN LITTLE SECTION<br>
        U+104B MYANMAR SIGN SECTION<br>
        U+1361 ETHIOPIC WORDSPACE<br>
        U+1363 ETHIOPIC COMMA<br>
        U+1364 ETHIOPIC SEMICOLON<br>
        U+1365 ETHIOPIC COLON<br>
        U+1366 ETHIOPIC PREFACE COLON<br>
        U+166D CANADIAN SYLLABICS CHI SIGN<br>
        U+166E CANADIAN SYLLABICS FULL STOP<br>
        U+16EB RUNIC SINGLE PUNCTUATION<br>
        U+16EC RUNIC MULTIPLE PUNCTUATION<br>
        U+16ED RUNIC CROSS PUNCTUATION<br>
        U+17D4 KHMER SIGN KHAN<br>
        U+17D5 KHMER SIGN BARIYOOSAN<br>
        U+17D6 KHMER SIGN CAMNUC PII KUUH<br>
        U+17DA KHMER SIGN KOOMUUT<br>
        U+1802 MONGOLIAN COMMA<br>
        U+1804 MONGOLIAN COLON<br>
        U+1805 MONGOLIAN FOUR DOTS<br>
        U+1808 MONGOLIAN MANCHU COMMA<br>
        U+3001 IDEOGRAPHIC COMMA<br>
        U+FE50 SMALL COMMA<br>
        U+FE51 SMALL IDEOGRAPHIC COMMA<br>
        U+FE54 SMALL SEMICOLON<br>
        U+FE55 SMALL COLON<br>
        U+FE56 SMALL QUESTION MARK<br>
        U+FF0C FULLWIDTH COMMA<br>
        U+FF1A FULLWIDTH COLON<br>
        U+FF1B FULLWIDTH SEMICOLON<br>
        U+FF64 HALFWIDTH IDEOGRAPHIC COMMA</span></td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <h2><a name="Implementation_Notes">6 Implementation Notes</a></h2>
  <h3>6.1 <a name="Normalization">Normalization</a></h3>
  <p>Although boundaries are specified in terms of NFD text, in practice 
  normalization is not required. None of the default specifications break within 
  a sequence of non-spacing marks, which is the only part that can reorder in 
  the formation of NFD. Nor do any of the specifications break between a base 
  character and subsequent non-spacing marks.</p>
  <h3>6.2 <a name="Grapheme_Cluster_and_Format_Rules">Grapheme Cluster and 
  Format Rules</a></h3>
  <p>The first rule for the default word and sentence specifications is to treat 
  a grapheme cluster as a single character: the first character of the cluster. 
  This would be equivalent to making the following changes to the subsequent 
  rules.</p>
  <ul>
    <li>Add rules 1, 3-4 from <a href="tr29-2.html#Default_Grapheme_Cluster_Table">Table 1 
      Default Grapheme Cluster Table</a> to disallow breaking between Hangul 
      syllables or CRLF.
      <ul>
        <li>Note: none of the specifications distinguish between L, V, T, LV, or 
          LVT; nor between CR and LF, nor does it matter whether there is a 
          sequence of these or a single one.</li>
      </ul>
    </li>
    <li>Insert Extend* after every character class — except after the final 
      class after the break symbol.
      <ul>
        <li>Thus <span class="example2">&nbsp;X Y × Z W&nbsp;</span> becomes
          <ul>
            <li><span class="example2">&nbsp;X <u>Extend*</u> Y <u>Extend*</u> 
              × Z <u>Extend*</u> W&nbsp;</span></li>
          </ul>
        </li>
        <li>Thus <span class="example2">&nbsp;X Y ×&nbsp;</span> becomes
          <ul>
            <li><span class="example2">&nbsp;X <u>Extend*</u> Y <u>Extend*</u> 
              ×&nbsp;</span></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <p>The other special rule for the word and sentence specifications is to 
  ignore interior Format characters. This would be equivalent to making the 
  following further changes to the affected subsequent rules.</p>
  <ul>
    <li>If the break symbol is a no-break sign (×), insert Format* after each 
      Extend*, and after the break symbol — except where there is nothing 
      after the break symbol.
      <ul>
        <li>Thus <span class="example2">&nbsp;X Extend* Y Extend* × Z Extend* W&nbsp;</span> 
          becomes
          <ul>
            <li><span class="example2">&nbsp;X Extend* <u>Format*</u> Y Extend* <u>Format*</u> 
              × <u>Format*</u> Z Extend* <u>Format*</u> W&nbsp;</span></li>
          </ul>
        </li>
        <li>Thus <span class="example2">&nbsp;X Extend* Y Extend* ×&nbsp;</span> 
          becomes
          <ul>
            <li><span class="example2">&nbsp;X Extend* <u>Format*</u> Y Extend* 
              ×&nbsp;</span></li>
          </ul>
        </li>
      </ul>
    <li>If the break symbol is a break sign (÷), insert Format* after each 
      Extend* — except not before the break symbol.
      <ul>
        <li>Thus <span class="example2">&nbsp;X Extend* Y Extend* ÷ Z Extend* W&nbsp;</span> 
          becomes
          <ul>
            <li><span class="example2">&nbsp;X Extend* <u>Format*</u> Y Extend* 
              ÷ Z Extend* <u>Format*</u> W&nbsp;</span></li>
          </ul>
        </li>
        <li>Thus <span class="example2">&nbsp;X Extend* Y Extend* ÷&nbsp;</span> 
          becomes
          <ul>
            <li><span class="example2">&nbsp;X Extend* <u>Format*</u> Y Extend* 
              ÷&nbsp;</span></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <h3>6.3 <a name="Regular_Expressions">Regular Expressions</a></h3>
  <p>The above rules can be converted into a regular expression that will 
  produce the same results. The regular expression must be evaluated starting at 
  a known boundary (such as the start of the text), and take the longest match 
  (except in the case of Sentence boundaries, where the shortest match needs to 
  be used).</p>
  <p>The conversion into a regular expression is fairly straightforward, 
  although it takes a little thought. For example, <a href="tr29-2.html#Default_Grapheme_Cluster_Table">Table 
  1. Default Grapheme Cluster Boundaries</a> can be transformed into the 
  following regular expression:</p>
  <blockquote>
    <p><span class="charlist">&nbsp; Control<br>
    | CR LF<br>
    | ( !Control? | L+ | T+ | L* ( LV? V+ | LV | LVT ) T* ) Extend*</span></p>
  </blockquote>
  <p>Such a regular expression can then be turned into a very fast state 
  machine. For more information on Unicode Regular Expressions, see <a href="http://www.unicode.org/unicode/reports/tr18/">UTR 
  #18: Unicode Regular Expression Guidelines</a> [<a href="tr29-2.html#Reports">Reports</a>].</p>
  <h3><a name="Random_Access">6.4 Random Access</a></h3>
  <p>A further complication is introduced by random access. When iterating 
  through a string from beginning to end, a regular expression / state machine 
  works well. From each boundary to find the next boundary is very fast. By 
  constructing a state table for the reverse direction from the same 
  specification of the rules, reverse iteration is possible.</p>
  <p>However, suppose that the user wants to iterate starting at a random point 
  in the text, or detect whether a random point in the text is a boundary. If 
  the starting point does not provide enough context to allow the correct set of 
  rules to be applied, then one could fail to find a valid boundary point. For 
  example, suppose a user clicked after the first space after the question mark 
  in “Are_you_there? _ _ No,_I'm_not”. On a forward iteration searching for 
  a sentence boundary, one would fail to find the boundary before the “N”, 
  because the “?” hadn’t been seen yet.</p>
  <p>A second set of rules to determine a “safe” starting point provides a 
  solution. Iterate backward with this second set of rules until a safe starting 
  point is located, then iterate forward from there. Iterate forward to find 
  boundaries that were located between the safe point and the starting point; 
  discard these. The desired boundary is the first one that is not less than the 
  starting point. The safe rules must be designed so that they function 
  correctly no matter what the starting point is, so they have to be 
  conservative in terms of finding boundaries: only finding those boundaries 
  that can be determined by a small context.</p>
  <p align="center"><img src="images/random_access.gif" width="246" height="138" alt="random acces diagram"></p>
  <p>This process would represent a significant performance cost if it had to be 
  performed on every search. However, this functionality can be wrapped up in an 
  iterator object, which preserves the information regarding whether it 
  currently is at a valid boundary point. Only if it is reset to an arbitrary 
  location in the text is this extra backup processing performed. The iterator 
  may even cache local values that it has already traversed.</p>
  <h3>6.5 <a name="Tailoring">Tailoring</a></h3>
  <p>State machines can also be combined with a code-based or table-based 
  tailoring mechanism. For typical Unicode state machines, a Unicode character 
  is typically passed to a mapping table that maps characters to character 
  classes. This mapping can use an efficient mechanism such as a trie. Once a 
  character class is produced, then it is passed to the state machine.</p>
  <p>The simplest customization is just to adjust the values coming out of the 
  character mapping table. For example, to put the appropriate quotation marks 
  for a given language into the Close character class for sentence boundaries, 
  artificial character classes can be introduced for different quotation marks. 
  A table can be applied after the main mapping table to map those artificial 
  character classes to the real ones. To change languages, a different small 
  table is substituted. The only real cost is then an extra array look-up.</p>
  <p>For code-based tailoring a different special range of character classes can 
  be added. The state machine is set up so that any special character class 
  causes the state machine to halt, and return a particular exception value. 
  When this exception value is detected, the higher-level process can call 
  specialized code according to whatever the exceptional value is. This can all 
  be encapsulated so that it is transparent to the caller.</p>
  <p>For example, Thai characters can be mapped to a special character class. 
  When the state machine halts for one of these values, then a Thai word-break 
  engine is invoked internally, to produce boundaries within the subsequent 
  string of Thai characters. These boundaries can then be cached so that 
  subsequent calls for next/previous boundaries merely return the cached values. 
  Similarly Lao characters can be mapped to a different special class, causing a 
  different engine to be invoked.</p>
  <h2><a name="Acknowledgements">Acknowledgements</a></h2>
  <p>Thanks to Ted Hopp, Andy Heninger, and Eric Mader for their feedback on 
  previous versions of this document.</p>
  <h2><a name="References">References</a></h2>
  <table class="noborder">
    <tr>
      <td width="1" class="noborder">[<a name="FAQ">FAQ</a>]</td>
      <td class="noborder">Unicode Frequently Asked Questions<br>
        <a href="http://www.unicode.org/unicode/faq/">http://www.unicode.org/unicode/faq/<br>
        </a><i>For answers to common questions on technical issues.</i></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Glossary">Glossary</a>]</td>
      <td class="noborder">Unicode Glossary<a href="http://www.unicode.org/glossary/"><br>
        http://www.unicode.org/glossary/<br>
        </a><i>For explanations of terminology used in this and other documents.</i></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Reports">Reports</a>]</td>
      <td class="noborder">Unicode Technical Reports<br>
        <a href="http://www.unicode.org/unicode/reports/">http://www.unicode.org/unicode/reports/<br>
        </a><i>For information on the status and development process for 
        technical reports, and for a list of technical reports.</i></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="U3.1">U3.1</a>]</td>
      <td class="noborder">Unicode Standard Annex #27: Unicode 3.1<a href="http://www.unicode.org/unicode/reports/tr27/"><br>
        http://www.unicode.org/unicode/reports/tr27/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Versions">Versions</a>]</td>
      <td class="noborder">Versions of the Unicode Standard<br>
        <a href="http://www.unicode.org/unicode/standard/versions/">http://www.unicode.org/unicode/standard/versions/<br>
        </a><i>For details on the precise contents of each version of the 
        Unicode Standard, and how to cite them.</i></td>
    </tr>
  </table>
  <br>
  <h2><a name="Modifications">Modifications</a></h2>
  <p>The following summarizes modifications from the previous version of this 
  document.</p>
  <ul>
    <li>Simplified grapheme cluster.</li>
    <li>Handled format characters appropriately.</li>
    <li>Removed Hiragana × Hiragana from word break, as well as prefix/posfix 
      for numbers (since they should not block whole-word search).</li>
    <li>Modified sentence break to catch edge conditions.</li>
    <li>Added conformance section, with more warnings throughout that these 
      specifications need to be tailored for different languages/orthographic 
      conventions.</li>
    <li>Tightened up the specifications of the character classes.</li>
    <li>Clarified the rule process.</li>
    <li>Added explanations of the interaction with normalization.</li>
    <li>Added an implementation section (incorporating the previous Random 
      Access section).</li>
  </ul>
  <hr width="50%">
  <p class="copyright">Copyright © 2000-2002 Unicode, Inc. All Rights Reserved. 
  The Unicode Consortium makes no expressed or implied warranty of any kind, and 
  assumes no liability for errors or omissions. No liability is assumed for 
  incidental and consequential damages in connection with or arising out of the 
  use of the information or programs contained or accompanying this technical 
  report.</p>
  <p class="copyright">Unicode and the Unicode logo are trademarks of Unicode, 
  Inc., and are registered in some jurisdictions.</p>
</div>

</body>
