<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<title>UAX #29: Unicode Text Segmentation</title>
<!-- <link rel="stylesheet" href="http://www.unicode.org/reports/reports.css" type="text/css"> -->

<!-- WEB ONLY -->
<link rel="stylesheet" type="text/css" href="../reports-web.css">
<!-- BOOK ONLY 
<link rel="stylesheet" type="text/css" href="../reports-book.css"> -->

</head>
<body><div class="book"><!-- WEB ONLY--><div class="web-only">
<table class="header" width="100%">
  <tr>
    <td class="icon"><a href="http://www.unicode.org">
    <img align="middle" alt="[Unicode]" border="0" src="../logo60s2.gif" width="34" height="33"></a>&nbsp;&nbsp;<a class="bar" href="../index.html">Technical 
    Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>
</table>
</div>
<!-- END WEB ONLY-->
<div class="body">
	<h2 class="uaxtitle"><span class="changed">Proposed Update </span>Unicode Standard Annex&nbsp;#29</h2>
  <h1>Unicode Text Segmentation</h1>
  <!-- START WEB ONLY -->
  <div class="web-only">
  <table class="wide" border="1" cellpadding="2">
    <tr>
      <td valign="top" width="20%">Version</td>
      <td valign="top">Unicode 6.<span class="changed">1</span>.0<span class="changed"> 
	  (draft 4)</span></td>
    </tr>
    <tr>
      <td valign="top"><span class="changed">Editors</span></td>
      <td valign="top">Mark Davis (<a href="mailto:markdavis@google.com">markdavis@google.com</a>)</td>
    </tr>
    <tr>
      <td valign="top">Date</td>
      <td valign="top"><span class="changed">2011-12-20</span></td>
    </tr>
    <tr>
      <td valign="top">This Version</td>
      <td valign="top">
      	<a href="tr29-18.html" class="changed">http://www.unicode.org/reports/tr29/tr29-18.html</a></td>
    </tr>
    <tr>
      <td valign="top">Previous Version</td>
      <td valign="top">
      <a href="tr29-17.html" class="changed">http://www.unicode.org/reports/tr29/tr29-17.html</a></td>
    </tr>
    <tr>
      <td valign="top">Latest Version</td>
      <td valign="top"><a href="../tr29.1">http://www.unicode.org/reports/tr29/</a></td>
    </tr>
    <tr>
      <td valign="top">Latest Proposed Update</td>
      <td valign="top"><a href="proposed.html">
      http://www.unicode.org/reports/tr29/proposed.html</a></td>
    </tr>
    <tr>
      <td valign="top">Revision</td>
      <td valign="top"><a class="changed" href="tr29-18.html#Modifications">18</a></td>
    </tr>
  </table>
  </div>
  <!-- END WEB ONLY -->
  <h4 class="summary">Summary</h4>
  <p><i>This annex describes guidelines for determining default 
	segmentation boundaries between certain 
  significant text elements: grapheme clusters (“user-perceived characters”), words, and sentences. 
  For line break boundaries, see [<a href="../tr41/tr41-7.html#UAX14">UAX14</a>]</i></p>
	<div class="web-only"> 
 <h4 class="status">Status</h4>
 
	  <!-- NOT YET APPROVED -->
	  <p class="changed"><i>This is a<b><font color="#ff3333"> draft </font></b>document which 
      may be updated, replaced, or superseded by other documents at any time. 
      Publication does not imply endorsement by the Unicode Consortium. This is 
      not a stable document; it is inappropriate to cite this document as other 
      than a work in progress.</i></p>
      <!-- END NOT YET APPROVED -->
	  <!-- APPROVED
      <p><i>This document has been reviewed by Unicode members and other 
	  interested parties, and has been approved for publication by the Unicode 
	  Consortium. This is a stable document and may be used as reference 
	  material or cited as a normative reference by other specifications.</i></p>
      END APPROVED -->

  <blockquote>
    <p><i><b>A Unicode Standard Annex (UAX)</b> forms an integral part of the 
	Unicode Standard, but is published online as a separate document. The 
	Unicode Standard may require conformance to normative content in a Unicode 
	Standard Annex, if so specified in the Conformance chapter of that version 
	of the Unicode Standard. The version number of a UAX document corresponds to 
	the version of the Unicode Standard of which it forms a part.</i></p>
  </blockquote>
  <p><i>Please submit corrigenda and other comments with the online reporting 
	form [<a href="../tr41/tr41-7.html#Feedback">Feedback</a>]. Related information that is useful 
	in understanding this annex is found in Unicode Standard Annex #41, “<a href="../tr41/tr41-7.html">Common References for Unicode Standard Annexes</a>.” 
	For the latest version of the Unicode Standard, see [<a href="../tr41/tr41-7.html#Unicode">Unicode</a>]. 
	For a list of current Unicode Technical Reports, see [<a href="../tr41/tr41-7.html#Reports">Reports</a>]. 
	For more information about versions of the Unicode Standard, see [<a href="../tr41/tr41-7.html#Versions">Versions</a>]. 
  For any errata which may apply to this annex, see [<a HREF="../tr41/tr41-7.html#Errata">Errata</a>].</i></p>
  </div>
  <h4 class="contents">Contents</h4>
  <ul class="toc">
    <li>1&nbsp;<a href="tr29-18.html#Introduction">Introduction</a>
    <ul class="toc">
      <li>1.1&nbsp;<a href="tr29-18.html#Notation">Notation</a></li>
    </ul>
    </li>
    <li>2&nbsp;<a href="tr29-18.html#Conformance">Conformance</a></li>
    <li>3&nbsp;<a href="tr29-18.html#Grapheme_Cluster_Boundaries">Grapheme Cluster Boundaries</a><ul class="toc">
    <li>3.1&nbsp; <a href="tr29-18.html#Default_Grapheme_Cluster_Table">Default Grapheme Cluster Boundary Specification</a></li>
    </ul></li>
    <li>4&nbsp;<a href="tr29-18.html#Word_Boundaries">Word Boundaries</a><ul class="toc">
    <li>4.1&nbsp; <a href="tr29-18.html#Default_Word_Boundaries">Default Word Boundary Specification</a></li>
    <li>4.2 <a href="tr29-18.html#Name_Validation">Name Validation</a></li>
    </ul>
    </li>
    <li>5&nbsp;<a href="tr29-18.html#Sentence_Boundaries">Sentence Boundaries</a><ul class="toc">
    <li>5.1&nbsp; <a href="tr29-18.html#Default_Sentence_Boundaries">Default Sentence Boundary Specification</a></li>
    </ul></li>
    <li>6&nbsp;<a href="tr29-18.html#Implementation_Notes">Implementation Notes</a>
    <ul class="toc">
      <li>6.1&nbsp;<a href="tr29-18.html#Normalization">Normalization</a></li>
      <li>6.2&nbsp;<a href="tr29-18.html#Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a></li>
      <li>6.3&nbsp;<a href="tr29-18.html#Regular_Expressions">Regular Expressions</a></li>
      <li>6.4&nbsp;<a href="tr29-18.html#Random_Access">Random Access</a></li>
      <li>6.5&nbsp;<a href="tr29-18.html#Tailoring">Tailoring</a></li>
    </ul>
    </li>
    <li>7&nbsp;<a href="tr29-18.html#Testing">Testing</a></li>
    <li class="changed">8 <a href="tr29-18.html#Hangul_Syllable_Boundary_Determination">Hangul Syllable Boundary Determination</a></li>
    <li><a href="tr29-18.html#Acknowledgments">Acknowledgments</a></li>
    <li><a href="tr29-18.html#References">References</a></li>
    <li><a href="tr29-18.html#Modifications">Modifications</a></li>
  </ul>
  <hr>
  <h2 class="section">1 <a name="Introduction">Introduction</a></h2>
  <p>This annex describes guidelines for determining default boundaries between 
	certain significant text elements: user-perceived 
	characters, words, and sentences. The process of boundary determination is 
	also called <i>segmentation</i>.</p>
  <p>A string of Unicode-encoded text often needs to be broken up into text elements 
  programmatically. Common examples of text elements include what users think of as characters, 
  words, lines (more precisely, where line breaks are allowed), and sentences. The precise 
  determination of text elements may vary according to orthographic conventions for a given script 
  or language. The goal of matching user perceptions cannot always be met exactly because the text 
  alone does not always contain enough information to unambiguously decide boundaries. For example, 
  the <em>period</em> (U+002E <span class="name">FULL STOP</span>) 
	is used ambiguously, sometimes for end-of-sentence purposes, sometimes for 
	abbreviations, and sometimes for numbers. In most cases, however, 
	programmatic text boundaries can match user perceptions quite closely, 
	although sometimes the best that can be done is not to surprise the user. </p>
  <p>Rather than concentrate on algorithmically searching for text elements 
	(often called <i>segments</i>), a simpler 
  and more useful computation instead detects the <i>boundaries</i> (or <i>breaks</i>) 
  between those text elements. The determination of those boundaries is often critical to performance, so it is important to be able to make such a determination as 
  quickly as possible. (For a general discussion of text elements, see <i>Chapter 
	2, General Structure</i>, of [<a href="../tr41/tr41-7.html#Unicode">Unicode</a>].)</p>
  <p>The default boundary determination mechanism specified in this annex provides a 
  straightforward and efficient way to determine some of the most significant boundaries in text: 
  user-perceived characters, words, and sentences. 
	Boundaries used in line breaking (also called word wrapping) are found in 
	[<a href="../tr41/tr41-7.html#UAX14">UAX14</a>].</p>
  <p>The sheer number of characters in the Unicode Standard, together with 
	its representational power, place 
  requirements on both the specification of text element boundaries and the underlying 
  implementation. The specification needs to allow the designation of large sets of characters 
  sharing the same characteristics (for example, uppercase letters), while the implementation must 
  provide quick access and matches to those large sets. The mechanism also must handle special 
  features of the Unicode Standard, such as nonspacing marks and conjoining jamo.</p>
  <p>The default boundary determination builds upon the uniform character representation of the 
  Unicode Standard, while handling the large number of characters and special features such as 
  nonspacing marks and conjoining jamo in an effective manner. As this mechanism lends itself to a 
  completely data-driven implementation, it can be tailored to particular orthographic conventions 
  or user preferences without recoding.</p>
  <p>As in other Unicode algorithms, these specifications provide a <i>logical</i> description of the 
  processes: implementations can achieve the same results without using code or data that follows 
  these rules step-by-step. In particular, many production-grade implementations will use a 
  state-table approach. In that case, the performance does not depend on the complexity or number of 
  rules. Rather, performance is only affected by the number of characters that may match <i>
  after</i> the boundary position in a rule that applies. </p>
  <h3 class="section">1.1 <a name="Notation">Notation</a></h3>
  <p>A boundary specification summarizes boundary property values used in that 
	specification, then lists the rules for boundary determinations in terms of 
	those property values. The summary is provided as a list, where each element 
	of the list is one of the following:</p>
  <ul>
    <li>A literal character</li>
    <li>A range of literal characters</li>
    <li>All characters satisfying a given condition, using properties defined in the Unicode 
    Character Database [<a href="../tr41/tr41-7.html#UCD">UCD</a>]:
    <ul style="list-style-type:none">
      <li>Non-Boolean property values are given as <i>&lt;property&gt;=&lt;property value&gt;</i>, such as 
      General_Category = Titlecase_Letter.</li>
      <li>Boolean properties are given as <i>&lt;property&gt;=true</i>, such as
      Uppercase = true.</li>
      <li>Other conditions are specified textually in terms of UCD properties.</li>
    </ul>
    </li>
    <li>Boolean combinations of the above</li>
    <li>The two special identifiers <i>sot</i> and <i>eot</i> stand for start and end of text, 
	respectively</li>
  </ul>
  <p>For example, the following is such a list:</p>
	<blockquote>
		<blockquote>
			<p>General_Category = Line Separator (Zl), or<br>General_Category = Paragraph Separator (Zp), or<br>General_Category = Control (Cc), or<br>General_Category = Format (Cf)<br>
			<i>and not</i> <span class="charlist">U+000D CARRIAGE RETURN (CR)</span><br>
			<i>and not</i> <span class="charlist">U+000A LINE FEED (LF)</span><br>
			<i>and not</i> <span class="charlist">U+200C ZERO WIDTH NON-JOINER 
      (ZWNJ)</span> <br><i>and not</i> <span class="charlist">U+200D ZERO WIDTH JOINER (ZWJ)</span></p>
		</blockquote>
	</blockquote>
  <p>In the table assigning the boundary property values, all of the values are intended to be 
  disjoint except for the special value <b>Any</b>. In case of conflict, rows higher in the table 
  have precedence in terms of assigning property values to characters. Data files containing 
  explicit assignments of the property values are found in [<a href="../tr41/tr41-7.html#Props">Props</a>].</p>
  <p>Boundary determination is specified in terms of an ordered list of rules, 
	indicating the status of a boundary position. The rules are numbered for reference and are applied in sequence to determine whether 
  there is a boundary at a given offset. That is, there is an implicit “otherwise” at the front of 
  each rule following the first. The rules are processed from top to bottom. As soon as 
  a rule matches and produces a boundary status (boundary or no boundary) for that offset, the 
  process is terminated. </p>
  <p>Each rule consists of a left side, a boundary symbol (see <i>Table 1</i>), and a right side. Either of the sides can 
  be empty. The left and right sides use the boundary property values in regular expressions. 
	The regular expression syntax used is a simplified version of the format 
	supplied in Unicode Technical Standard #18, &#x201C;Unicode Regular Expressions&#x201D;
	[<a href="../tr41/tr41-7.html#RegEx">RegEx</a>].</p>
  <div align="center">
<center>
  <p class="caption"><a name="#Table_Boundary_Symbols"></a>Table 1. <span style="font-weight:400">Boundary Symbols</span></p>
  <table border="0" class="syntax">
    <tr>
      <td>÷</td>
      <td>Boundary (allow break here)</td>
    </tr>
    <tr>
      <td>×</td>
      <td>No boundary (do not allow break here)</td>
    </tr>
    <tr>
      <td>→</td>
      <td>Treat whatever on the left side as if it were what is on the right 
		side&nbsp;</td>
    </tr>
  </table>
  </center>
  </div>
  <p>An <i>underscore</i> (“_”) is used to indicate a space in examples.</p>
  <p>These rules are constrained in three ways, to make implementations significantly simpler and more efficient. 
	These constraints have not been found to be limitations for natural language use. In 
  particular, the rules are formulated so that they can be 
  efficiently implemented, such as 
  with a deterministic finite-state machine based on a small number of property values.</p>
  <ol>
    <li><i>Single boundaries.</i> Each rule has exactly one boundary position. This restriction is 
    more a limitation on the specification methods, because a rule with multiple boundaries could 
    be expressed instead as multiple rules. For example:<ul style="list-style-type:none">
      <li>“a b ÷ c d ÷ e f” could be broken into two rules “a b ÷ c d e f” and “a b c d ÷ e f”</li>
      <li>“a b × c d × e f” could be broken into two rules “a b × c d e f” and “a b c d × e f”</li>
    </ul>
    </li>
    <li><i>Ignore degenerates.</i> No special provisions are made to get marginally better behavior 
    for degenerate cases that never occur in practice, such as an <i>A</i> followed by an Indic 
    combining mark.</li>
	<li><i>Limited negation.</i> Negation of expressions is limited to instances 
	that resolve to a match against single characters, such as “¬(OLetter | 
	Upper | Lower | Sep)”.</li>
  </ol>
  <h2 class="section">2 <a name="Conformance">Conformance</a></h2>
  <p>There are many different ways to divide text elements 
  corresponding to user-perceived 
	characters, words, and sentences, and the Unicode Standard 
	does not restrict the ways in which implementations can produce these 
	divisions.</p>
  <p>This specification defines <i>default</i> mechanisms; more sophisticated 
  implementations can <i>and should</i> tailor them for particular locales or environments. For 
  example, reliable detection of word break boundaries 
	in languages such as Thai, Lao, Chinese, or Japanese requires the use of dictionary 
  lookup, analogous to English hyphenation. An implementation therefore may need to provide means to 
  override or subclass the default mechanisms 
  described in this annex. Note that tailoring can <i>
  either</i> add boundary positions <i>or</i> remove boundary positions, compared to the defaults 
  specified here.</p>
  <blockquote>
    <p><span class="note">Note:</span> Locale-sensitive boundary 
	specifications can be expressed in LDML [<a href="../tr41/tr41-7.html#UTS35">UTS35</a>] 
    and be contained in the Unicode Locales project [<a href="../tr41/tr41-7.html#CLDR">CLDR</a>]. 
	The repository already contains some tailorings, with more to follow.</p>
  </blockquote>
  <p>To maintain canonical equivalence, all of the following specifications are defined on 
	text normalized in form NFD, 
  as defined in Unicode Standard Annex #15, &#x201C;Unicode Normalization Forms&#x201D; 
  [<a href="../tr41/tr41-7.html#UAX15">UAX15</a>]. A boundary exists in 
	text not 
	normalized in form NFD if and only if it would occur at 
  the corresponding position in NFD text. However, the default rules have 
  been written to provide equivalent results for non-NFD text and can be applied directly. Even in 
  the case of tailored rules, the requirement to use NFD is only a logical specification; in 
  practice, implementations can avoid normalization and achieve the same results. For more 
  information, see <span class="section">Section </span><span class="secno">6,</span> <a href="tr29-18.html#Implementation_Notes"><i>Implementation Notes</i></a>.</p>
  <h2><a name="Grapheme_Cluster_Boundaries">3 Grapheme Cluster Boundaries</a></h2>
	<p>It is important to recognize that what the user 
	thinks of as a &quot;character&quot;—a basic unit of a 
	writing system for a language—may not be just a single Unicode code point. 
	Instead, that basic unit may be made up of multiple Unicode code points. To avoid ambiguity with the computer use of the term <i>character,</i> this is 
	called a <i>user-perceived character</i>. For example, “G” + <i>acute-accent</i> is a 
	<i>user-perceived character</i>: users think of it as a single character, yet is 
	actually represented by two Unicode code points. 
	These user-perceived characters are approximated by what is called a <i>grapheme cluster</i>, 
	which can be determined programmatically.</p>
	<p>Grapheme cluster boundaries are 
	important for collation, regular expressions, UI 
	interactions (such as mouse selection, arrow key movement, backspacing), 
	segmentation for vertical text, identification of boundaries for 
	first-letter styling, and counting “character” positions within text. 
	Word boundaries, line boundaries, and sentence boundaries 
	should not occur within a grapheme 
	cluster: in other words, a grapheme cluster should 
	be an atomic unit with 
	respect to the process of determining these other boundaries.</p>
  <p>As far as a user is concerned, the underlying representation of text is not 
	important, but it is important that an editing interface present a uniform 
	implementation of what the user thinks of as characters. Grapheme clusters 
	commonly behave as units in terms of mouse selection, arrow key movement, 
	backspacing, and so on. For example, when a 
	grapheme cluster is represented
	internally by a character sequence
	consisting of base character + accent, then using the right arrow key would skip from 
  the start of the base character to the end of the last character of the cluster.</p>
  <p>However, in some cases editing a grapheme cluster element by element may be 
	preferable. 
  For example, on a given system the <i>backspace key</i> might delete by code point, while the <i>delete 
  key</i>
  may delete an entire cluster. Moreover, there is not a one-to-one relationship between 
  grapheme clusters and keys on a keyboard. A single key on a keyboard may correspond to a whole 
  grapheme cluster, a part of a grapheme cluster, or a sequence of more than one grapheme cluster.</p>
  <p>In those relatively rare circumstances where programmers need to supply end 
	users 
	with user-perceived character counts, the counts should correspond 
  to the number of segments delimited by grapheme clusters. Grapheme clusters<i> 
	may also be</i> used in searching and matching; for 
  more information, see Unicode Technical Standard #10, &#x201C;Unicode Collation Algorithm&#x201D; 
	[<a href="../tr41/tr41-7.html#UTS10">UTS10</a>], and Unicode Technical Standard #18, &#x201C;Unicode 
	Regular Expressions&#x201D; 
	[<a href="../tr41/tr41-7.html#UTS18">UTS18</a>].</p>
	<p>The Unicode Standard provides default 
	algorithms for determining grapheme cluster boundaries, with two variants:
	<b><i>legacy grapheme 
	clusters</i></b> and <b><i>extended grapheme clusters</i></b>.
	<span class="changed">The most appropriate variant depends on the language and operation involved. However, </span>the 
	extended grapheme cluster boundaries are recommended for general processing, 
	while the legacy grapheme cluster boundaries are maintained <span class="changed">primarily </span>for backwards 
	compatibility with earlier versions of this specification.</p>
	<p>These algorithms can be adapted to produce <b>
	<i>tailored grapheme clusters </i></b>for 
  specific locales or other customizations, such as the contractions used in collation tailoring tables. 
	Below are some examples of the differences between these concepts. The tailored 
	examples are only for illustration: what constitutes a grapheme cluster will 
	depend on the customizations used by the particular tailoring in questions.</p>
	<p class="caption"><a name="#Table_Sample_Grapheme_Clusters"></a>Table 1a. Sample Grapheme Clusters</p>   
  <table cellspacing="0" cellpadding="4" border="0" id="table8"> 
	<tr>
      <th valign="top">Ex</th>
      <th valign="top" width="49%">Characters</th>
      <th valign="top" width="49%">Comments</th>
    </tr>
    <tr>
      <th colspan="3"><i>Grapheme 
		clusters (both legacy and extended)</i></th>
    </tr>
    <tr>
      <td>g̈</td>
      <td>U+0067 (&nbsp;g&nbsp;) <span class="name">LATIN SMALL LETTER G</span><br>
	  U+0308 (&nbsp;̈&nbsp;) <span class="name">COMBINING DIAERESIS</span></td>
      <td valign="top">combining character sequences</td>
    </tr>
    <tr>
      <td rowspan="2">각</td>
      <td>U+AC01 (&nbsp;각&nbsp;) <span class="name">HANGUL SYLLABLE GAG</span></td>
      <td valign="top" rowspan="2">Hangul syllables such as<i> 
		gag </i>&nbsp;(which may be a single character, or a sequence of 
		combining jamo)</td>
    </tr>
    <tr>
      <td>U+1100 (&nbsp;ᄀ&nbsp;) <span class="name">HANGUL CHOSEONG KIYEOK</span><br>
	U+1161 (&nbsp;ᅡ&nbsp;) <span class="name">HANGUL JUNGSEONG A</span><br>
	U+11A8 (&nbsp;ᆨ&nbsp;) <span class="name">HANGUL JONGSEONG KIYEOK</span></td>
    </tr>
    <tr>
      <th colspan="3"><i>Extended grapheme clusters</i></th>
    </tr>
    <tr>
      <td>நி </td>
      <td>U+0BA8 ( ந ) <span class="name">TAMIL LETTER NA</span><br>
	U+0BBF ( ி ) <span class="name">TAMIL VOWEL SIGN I</span></td>
      <td valign="top">Tamil <i>ni</i></td>
    </tr>
    <tr>
      <td><span class="changed">เ</span></td>
      <td><span class="changed">U+0E40 (&nbsp;เ&nbsp;) <span class="name">THAI CHARACTER SARA E</span></span></td>
      <td valign="top"><span class="changed">Thai <i>e</i></span></td>
    </tr>
    <tr>
      <td><span class="changed">ก</span></td>
      <td><span class="changed">U+0E01 (&nbsp;ก&nbsp;) <span class="name">THAI CHARACTER KO KAI</span></span></td>
      <td valign="top"><span class="changed">Thai <i>ko</i></span></td>
    </tr>
    <tr>
      <td><span class="changed">กำ</span></td>
      <td><span class="changed">U+0E01 (&nbsp;ก&nbsp;) <span class="name">THAI CHARACTER KO KAI</span><br>
		U+0E33 (&nbsp;ำ&nbsp;) <span class="name">THAI CHARACTER SARA AM</span></span></td>
      <td valign="top"><span class="changed">Thai <i>kam</i></span></td>
    </tr>
    <tr>
      <td>षि</td>
      <td>U+0937 ( ष ) <span class="name">DEVANAGARI LETTER SSA</span><br>
		U+093F ( ि ) <span class="name">DEVANAGARI VOWEL SIGN I</span></td>
      <td valign="top">Devanagari ssi</td>
    </tr>
    <tr>
      <th colspan="3"><span class="changed"><i>Legacy grapheme clusters</i></span></th>
    </tr>
    <tr>
      <td><span class="changed">ก</span></td>
      <td><span class="changed">U+0E01 (&nbsp;ก&nbsp;) <span class="name">THAI CHARACTER KO KAI</span></span></td>
      <td valign="top"><span class="changed">Thai <i>ko</i></span></td>
    </tr>
    <tr>
      <td><span class="changed">ำ</span></td>
      <td><span class="changed">U+0E33 (&nbsp;ำ&nbsp;) <span class="name">THAI CHARACTER SARA AM</span></span></td>
      <td valign="top"><span class="changed">Thai <i>am</i></span></td>
    </tr>
    <tr>
      <td><span class="changed">ष</span></td>
      <td><span class="changed">U+0937 ( ष ) <span class="name">DEVANAGARI LETTER SSA</span></span></td>
      <td valign="top"><span class="changed">Devanagari <i>ssa</i></span></td>
    </tr>
    <tr>
      <td><span class="changed">ि</span></td>
      <td><span class="changed">U+093F ( ि ) <span class="name">DEVANAGARI VOWEL SIGN I</span></span></td>
      <td valign="top"><span class="changed">Devanagari <i>i</i></span></td>
    </tr>
    <tr>
      <th colspan="3"><i>Tailored grapheme clusters</i></th>
    </tr>
    <tr>
      <td>ch</td>
      <td>U+0063 (&nbsp;c&nbsp;) <span class="name">LATIN SMALL LETTER C</span><br>
	U+0068 (&nbsp;h&nbsp;) <span class="name">LATIN SMALL LETTER H</span></td>
      <td valign="top">Slovak <i>ch</i> digraph</td>
    </tr>
    <tr>
      <td>k<sup>w</sup></td>
      <td>U+006B (&nbsp;k&nbsp;) <span class="name">LATIN SMALL LETTER K</span><br>
	U+02B7 (&nbsp;ʷ&nbsp;) <span class="name">MODIFIER LETTER SMALL W</span></td>
      <td valign="top">sequence with letter modifier</td>
    </tr>
    <tr>
      <td>क्षि</td>
      <td>U+0915 ( क ) <span class="name">DEVANAGARI LETTER KA</span><br>
	U+094D ( ् ) <span class="name">DEVANAGARI SIGN VIRAMA</span><br>
	U+0937 ( ष ) <span class="name">DEVANAGARI LETTER SSA</span><br>
	U+093F ( ि ) <span class="name">DEVANAGARI VOWEL SIGN I</span></td>
      <td valign="top">Devanagari <i>kshi</i></td>
    </tr>
    </table>
	<p><i>See also: <a href="http://www.unicode.org/standard/where/">Where is my Character?</a>,
		<a href="http://unicode.org/Public/UNIDATA/NamedSequences.txt">NamedSequences.txt</a>, 
		and <a href="http://unicode.org/Public/UNIDATA/NamedSequencesProv.txt">NamedSequencesProv.txt</a>.</i></p>
	<p>A <b><i>legacy grapheme cluster</i></b> is defined as a base (such as A or カ) followed 
	by zero or more continuing characters. One way to think of this is as a sequence of 
	characters that form a &quot;stack&quot;.</p>
	<p>The base can be single 
	characters, or be any sequence of Hangul Jamo characters that 
	form a Hangul Syllable, as defined by D118 in The Unicode Standard.</p>
	<p>The continuing characters include
	nonspacing marks, plus the Join Controls (<code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=200C">U+200C</a></code> 
	(&nbsp;&nbsp;) ZERO WIDTH NON-JOINER and <code>
	<a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=200D">
	U+200D</a></code> (&nbsp;&nbsp;) ZERO WIDTH JOINER used in Indic languages, and a few spacing 
	combining marks to ensure canonical equivalence. Additional cases need to be added for completeness, 
	so that any string of text can be divided up into a sequence of grapheme clusters. Some of these 
	may be <i>degenerate</i> cases, such as a control code, or an isolated combining mark.</p>
	<p>An <b><i>extended grapheme cluster</i></b> is the same as a legacy grapheme cluster, with the 
	addition of some other characters. The continuing characters are extended to 
	include all spacing combining marks, such as the spacing (but 
	dependent) vowel signs in Indic scripts, as continuing characters. For 
	example, this includes U+093F (ि) DEVANAGARI VOWEL SIGN I.
	<span class="changed">The extended grapheme clusters should be used in implementations in preference
	to legacy grapheme clusters, because they provide better results for Indic scripts such as Tamil or
	Devanagari in which editing by orthographic syllable is typically preferred. For scripts such as Thai,
	Lao, and certain other southeast Asian scripts, editing by visual unit is typically preferred, so for
	those scripts the behavior of extended grapheme clusters is similar to (but not identical to) the
	behavior of legacy grapheme clusters.</span>
	<span class="removed">The definition also includes certain visual order Thai and Lao vowels that may
	come before the base. The extended grapheme clusters should be used in implementations in preference to 
	legacy grapheme clusters, because they provide better results for Indic scripts such as Tamil or Devanagari,
	and for Southeast Asian scripts such as Thai and Lao.</span>
	</p>
  <p>For the rules defining the boundaries for grapheme clusters, 
  see <i><a href="tr29-18.html#Default_Grapheme_Cluster_Table">Table 2</a></i>. For more information on the composition of Hangul 
	syllables, 
  see <i>Chapter 3, Conformance</i>, of [<a href="../tr41/tr41-7.html#Unicode">Unicode</a>].</p>
  <blockquote>
    <p><i>Note: The boundary between default Unicode grapheme clusters can be 
    determined by just the two adjacent characters. See Section 7, <a href="tr29-18.html#Testing">Testing</a>, 
    for a chart showing the interactions of pairs of characters.</i></p>
  </blockquote>
	<p>A key feature of default 
	Unicode grapheme clusters 
	(both legacy and extended) is that they remain 
	unchanged across all canonically equivalent forms of the underlying text. Thus the boundaries 
	remain unchanged whether the text is in NFC or NFD. Using a grapheme cluster 
	as the fundamental unit of matching thus provides a very clear and easily 
	explained basis for canonically equivalent matching. This is important for 
	applications from searching to regular expressions.</p>
	<p>Another key feature is that 
	default Unicode grapheme clusters are atomic units with 
	respect to the process of determining the Unicode default line, word, and 
	sentence boundaries.</p>
	<p>Grapheme clusters can be 
	tailored to meet further requirements. Such tailoring is permitted, but the 
	possible rules are outside of the scope of this document. One example of such a tailoring would be for the 
	<i>aksaras</i>,
or <i>orthographic syllables</i>, used in many Indic scripts. Aksaras usually consist of a consonant, sometimes with
an inherent vowel and sometimes followed by an explicit,
dependent vowel whose rendering may end up on any side
of the consonant letter base. Extended grapheme clusters
include such simple combinations.</p>
	<p>However, aksaras may also include
one or more additional prefixed consonants, typically with a <i>virama</i>
(halant) character between each consonant in the sequence.
Such consonant cluster aksaras are not incorporated
into the default rules for extended grapheme clusters, in
part because not all such sequences are considered to
be single "characters" by users. Indic scripts vary considerably
in how they handle the rendering of such aksaras—in some
cases stacking them up into combined forms known as
consonant conjuncts, and in other cases stringing them out
horizontally, with visible renditions of the halant on
each consonant in the sequence. There is even greater
variability in how the typical liquid consonants (or "medials"),
<i>ya, ra, la,</i> and <i>wa</i>, are handled for display in combinations in
aksaras. So tailorings for aksaras may need to be
script-, language-, font-, or context-specific to be useful.	</p>
	<blockquote>
		<p><i>Note: Font-based information may be required to determine the appropriate unit to use for UI purposes, such as identification of 
		boundaries for first-letter paragraph styling. For example, such a unit 
		could be a ligature formed of two grapheme clusters, such as لا (Arabic </i>lam<i> + </i>alef<i>).</i></p>
	</blockquote>
	<p>The Unicode definitions of grapheme clusters are 
	defaults: not meant to exclude the use of 
	more sophisticated definitions of tailored grapheme clusters where 
	appropriate. Such definitions may more precisely match the user expectations 
	within individual languages for given processes. For example, “ch” may be 
	considered a grapheme cluster in Slovak, for processes such as collation. The default definitions are, however, designed to provide 
	a much more accurate match to overall user expectations for what the user 
	perceives of as <i>characters</i> than is provided by individual Unicode 
	code points.</p>
  <blockquote>
    <p><i>Note: The default Unicode grapheme 
	clusters were previously 
	referred to 
    as “locale-independent graphemes.” The term cluster is used to emphasize that the 
    term grapheme is used differently in linguistics. For simplicity and 
	to align terminology with Unicode Technical Standard #10, &#x201C;Unicode Collation Algorithm&#x201D; 
	[<a href="../tr41/tr41-7.html#UTS10">UTS10</a>], 
    the terms default and tailored are preferred over locale-independent 
    and locale-dependent, respectively.</i></p>
  </blockquote>
  <p><b><i>Display of Grapheme Clusters.</i></b> Grapheme clusters are not the 
	same as ligatures. For example, the grapheme cluster “ch” in Slovak is not 
	normally a ligature and, conversely, the ligature “fi” is not a grapheme 
	cluster. Default grapheme clusters do not necessarily reflect text display. 
	For example, the sequence &lt;f, i&gt; may be displayed as a single glyph on the 
	screen, but would still be two grapheme clusters.</p>
  <p>For information on the matching of grapheme clusters with regular 
	expressions, see Unicode Technical Standard #18, “Unicode Regular 
	Expressions” [<a href="../tr41/tr41-7.html#UTS18">UTS18</a>].</p>
  <p><b><i>Degenerate Cases.</i></b> The 
  default specifications are designed to be simple to implement, and provide an algorithmic 
  determination of grapheme clusters. However, they do <i>
  not</i> have to 
	cover edge cases that 
  will not occur in practice. For the purpose of segmentation, they may 
	also include degenerate cases that are not thought of as grapheme clusters, such as an isolated 
	control character or combining mark.  In this, they differ from the combining 
	character sequences and extended combining character sequences defined in 
	[<a href="../tr41/tr41-7.html#Unicode">Unicode</a>].<span class="changed"> In addition, Unassigned  (Cn) and Private Use (Co) characters are given property values that  anticipate potential usage.</span></p>
	<p>For comparison, <i>Table 1b</i> shows the relationship between 
	combining character sequences and grapheme clusters, using regex notation. Note that 
	given alternates (X|Y), the first match is taken.</p>
	<p class="caption">
	<a name="#Table_Combining_Char_Sequences_and_Grapheme_Clusters"></a>Table 1b. Combining character sequences and grapheme clusters</p>
  <table cellspacing="0" cellpadding="4" border="0" id="table7"> 
	<tr>
      <th valign="top">Term</th>
      <th valign="top" width="49%">Regex</th>
      <th valign="top" width="49%">Notes</th>
    </tr>
    <tr>
      <td valign="top">combining character sequence</td>
      <td><code>base? ( Mark | ZWJ | ZWNJ )+</code></td>
      <td>A single base character is <i>not</i> a 
		combining character sequence. 
		However, a single 
		combining mark <i>is</i> a (degenerate) combining character sequence.</td>
    </tr>
    <tr>
      <td valign="top">extended combining character 
		sequence</td>
      <td><code>extended_base? ( Mark | ZWJ | ZWNJ )+</code></td>
      <td>extended_base includes Hangul Syllables</td>
    </tr>
    <tr>
      <td valign="top">legacy grapheme cluster</td>
      <td><code>( CRLF <br>
		| ( Hangul-syllable | !Control ) <br>
&nbsp;&nbsp; Grapheme_Extend* <br>
		| . )</code></td>
      <td>A single base character is a grapheme 
		cluster. Degenerate cases include any isolated non-base characters, 
		and non-base characters like controls.</td>
    </tr>
    <tr>
      <td valign="top">extended grapheme cluster</td>
      <td><code>( CRLF <br>
		| <b>Prepend*</b> ( Hangul-syllable | !Control ) <br>
&nbsp; ( Grapheme_Extend <b>| Spacing_Mark</b>)*<br>
		| . )</code></td>
      <td>Extended grapheme clusters add prepending and spacing marks</td>
    </tr>
    </table>
  <p>&nbsp;</p>
  <h3 class="section">3.1 <a name="Default_Grapheme_Cluster_Table">Default Grapheme Cluster 
	Boundary Specification</a></h3>
	<p>The Grapheme_Cluster_Break property value assignments are explicitly 
	listed in the corresponding data file<span class="changed"> in </span>[<a href="../tr41/tr41-7.html#Props">Props</a>].<span class="changed"> The values in that file are the normative property values.</span></p>
	<p class="changed">For illustration, property values are summarized in <a href='tr29-18.html#Grapheme_Cluster_Break_Property_Values'>Table 2</a>, but the lists of characters are illustrative.	</p>
	<div align="center">
  <center>
   <p class="caption"><a name="Grapheme_Cluster_Break_Property_Values"></a>Table 2. Grapheme_Cluster_Break Property Values</p>   
  <table cellspacing="0" cellpadding="4" border="0"> <tr>
      <th valign="top">Value</th>
      <th valign="top">Summary List of Characters</th>
    </tr>
    <tr>
      <td valign="top"><b><a name="CR">CR</a></b></td>
      <td><span class="charlist">U+000D CARRIAGE RETURN (CR)</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="LF">LF</a></b></td>
      <td><span class="charlist">U+000A LINE FEED (LF)</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Control">Control</a></b></td>
      <td>General_Category = Line Separator (Zl), or<br>
      General_Category = Paragraph Separator (Zp), or<br>
      General_Category = Control (Cc), or<br>
      <span class="changed">General_Category = Control (Cn) and Default_Ignorable_Code_Point (DI), or<br>
      General_Category = Control (Cs), or<br>
      </span>General_Category = Format (Cf)<br>
      <i>and not</i> <span class="charlist">U+000D CARRIAGE RETURN (CR)</span><br>
      <i>and not</i> <span class="charlist">U+000A LINE FEED (LF)</span><br>
      <i>and not</i> <span class="charlist">U+200C ZERO WIDTH NON-JOINER 
      (ZWNJ)</span> <br>
      <i>and not</i> <span class="charlist">U+200D ZERO WIDTH JOINER (ZWJ) </span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Extend">Extend</a></b></td>
      <td>Grapheme_Extend = true<br><br>
		<i>This includes:</i><br>
		General_Category = Nonspacing_Mark<br>
		General_Category = Enclosing_Mark<br>
		<span class="charlist">U+200C ZERO WIDTH NON-JOINER<br>
		U+200D ZERO WIDTH JOINER<br>
		</span>plus a few Spacing Marks needed for canonical equivalence.</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Prepend">Prepend</a></b></td>
      <td><span class="changed">(Currently there are no characters with this value)</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="SpacingMark">SpacingMark</a></b></td>
      <td>Grapheme_Cluster_Break ≠ Extend, <em>and</em><br>
        General_Category = Spacing Mark<em>, or</em><br>
        <span class="changed">any of the following (which have General_Category = Other Letter):</span><br>
        <span class="charlist">
          <span class="removed">U+0E30 (&nbsp;ะ&nbsp;) THAI CHARACTER SARA A</span><br>
          <span class="removed">U+0E32 (&nbsp;า&nbsp;) THAI CHARACTER SARA AA</span><br>
          U+0E33 (&nbsp;ำ&nbsp;) THAI CHARACTER SARA AM<br>
          <span class="removed">U+0E45 (&nbsp;ๅ&nbsp;) THAI CHARACTER LAKKHANGYAO</span><br>
          <span class="removed">U+0EB0 (&nbsp;ະ&nbsp;) LAO VOWEL SIGN A</span><br>
          <span class="removed">U+0EB2 (&nbsp;າ&nbsp;) LAO VOWEL SIGN AA</span><br>
          U+0EB3 (&nbsp;ຳ&nbsp;) LAO VOWEL SIGN AM<br>
        </span><br>
        <span class="changed">Exceptions: The following (which have General_Category = Spacing Mark
        and would otherwise be included) are specifically excluded:</span><br>
        <span class="charlist"><span class="changed">
		  U+102B (&nbsp;ါ&nbsp;) MYANMAR VOWEL SIGN TALL AA<br>
		  U+102C (&nbsp;ာ&nbsp;) MYANMAR VOWEL SIGN AA<br>
		  U+1038 (&nbsp;း&nbsp;) MYANMAR SIGN VISARGA<br>
		  U+1062 (&nbsp;ၢ&nbsp;) MYANMAR VOWEL SIGN SGAW KAREN EU<br>
		  ..U+1064 (&nbsp;ၤ&nbsp;) MYANMAR TONE MARK SGAW KAREN KE PHO<br>
		  U+1067 (&nbsp;ၧ&nbsp;) MYANMAR VOWEL SIGN WESTERN PWO KAREN EU<br>
		  ..U+106D (&nbsp;ၭ&nbsp;) MYANMAR SIGN WESTERN PWO KAREN TONE-5<br>
		  U+1083 (&nbsp;ႃ&nbsp;) MYANMAR VOWEL SIGN SHAN AA<br>
		  U+1087 (&nbsp;ႇ&nbsp;) MYANMAR SIGN SHAN TONE-2<br>
		  ..U+108C (&nbsp;ႌ&nbsp;) MYANMAR SIGN SHAN COUNCIL TONE-3<br>
		  U+108F (&nbsp;ႏ&nbsp;) MYANMAR SIGN RUMAI PALAUNG TONE-5<br>
		  U+109A (&nbsp;ႚ&nbsp;) MYANMAR SIGN KHAMTI TONE-1<br>
		  ..U+109C (&nbsp;ႜ&nbsp;) MYANMAR VOWEL SIGN AITON A<br>
		  U+19B0 (&nbsp;ᦰ&nbsp;) NEW TAI LUE VOWEL SIGN VOWEL SHORTENER<br>
		  ..U+19B4 (&nbsp;ᦴ&nbsp;) NEW TAI LUE VOWEL SIGN UU<br>
		  U+19B8 (&nbsp;ᦸ&nbsp;) NEW TAI LUE VOWEL SIGN OA<br>
		  U+19B9 (&nbsp;ᦹ&nbsp;) NEW TAI LUE VOWEL SIGN UE<br>
		  U+19BB (&nbsp;ᦻ&nbsp;) NEW TAI LUE VOWEL SIGN AAY<br>
		  ..U+19C0 (&nbsp;ᧀ&nbsp;) NEW TAI LUE VOWEL SIGN IY<br>
		  U+19C8 (&nbsp;ᧈ&nbsp;) NEW TAI LUE TONE MARK-1<br>
		  U+19C9 (&nbsp;ᧉ&nbsp;) NEW TAI LUE TONE MARK-2<br>
		  U+1A61 (&nbsp;ᩡ&nbsp;) TAI THAM VOWEL SIGN A<br>
		  U+1A63 (&nbsp;ᩣ&nbsp;) TAI THAM VOWEL SIGN AA<br>
		  U+1A64 (&nbsp;ᩤ&nbsp;) TAI THAM VOWEL SIGN TALL AA<br>
		  U+AA7B (&nbsp;ꩻ&nbsp;) MYANMAR SIGN PAO KAREN TONE<br>
        </span></span>
      </td>
    </tr>
    <tr>
      <td valign="top"><b><a name="L">L</a></b></td>
      <td>Hangul_Syllable_Type=L, that is:<br>
        <span class="charlist">
        U+1100 ( ᄀ ) HANGUL CHOSEONG KIYEOK<br>
		..U+115F ( <b>ᅟ</b> ) HANGUL CHOSEONG FILLER<br>
        U+A960 ( ꥠ ) HANGUL CHOSEONG TIKEUT-MIEUM<br>
		..U+A97C ( ꥼ ) HANGUL CHOSEONG SSANGYEORINHIEUH<br>
		</span>
      </td>
    </tr>
    <tr>
      <td valign="top" style="border-top:solid"><b><a name="V">V</a></b></td>
      <td style="border-top:solid">Hangul_Syllable_Type=V, that is:<br>
          <span class="charlist">
          U+1160 ( <b>ᅠ</b> ) HANGUL JUNGSEONG FILLER<br>
          ..U+11A2 ( ᆢ ) HANGUL JUNGSEONG SSANGARAEA<br>
    	  U+D7B0 ( ힰ ) HANGUL JUNGSEONG O-YEO<br>
          ..U+D7C6 ( ퟆ ) HANGUL JUNGSEONG ARAEA-E
          </span>
      </td>
    </tr>
    <tr>
      <td valign="top"><b><a name="T">T</a></b></td>
      <td>Hangul_Syllable_Type=T, that is:<br>
          <span class="charlist">
          U+11A8 ( ᆨ ) HANGUL JONGSEONG KIYEOK<br>
          ..U+11F9 ( ᇹ ) HANGUL JONGSEONG YEORINHIEUH<br>
          U+D7CB ( ퟋ ) HANGUL JONGSEONG NIEUN-RIEUL<br>
          ..U+D7FB ( ퟻ ) HANGUL JONGSEONG PHIEUPH-THIEUTH
          </span>
      </td>
    </tr>
    <tr>
      <td valign="top"><b><a name="LV">LV</a></b></td>
      <td>Hangul_Syllable_Type=LV, that is:<br>
      <span class="charlist">U+AC00 (</span><span class="symbol">가</span><span class="charlist">) 
      HANGUL SYLLABLE GA<br>
      U+AC1C (</span><span class="symbol">개</span><span class="charlist">) HANGUL SYLLABLE GAE<br>
      U+AC38 (</span><span class="symbol">갸</span><span class="charlist">) HANGUL SYLLABLE GYA<br>
      ...</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="LVT">LVT</a></b></td>
      <td>Hangul_Syllable_Type=LVT, that is:<br>
      <span class="charlist">U+AC01 (</span><span class="symbol">각</span><span class="charlist">) 
      HANGUL SYLLABLE GAG<br>
      U+AC02 (</span><span class="symbol">갂</span><span class="charlist">) HANGUL SYLLABLE GAGG<br>
      U+AC03 (</span><span class="symbol">갃</span><span class="charlist">) HANGUL SYLLABLE GAGS<br>
      U+AC04 (</span><span class="symbol">간</span><span class="charlist">) HANGUL SYLLABLE GAN<br>
      ...</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="AnyGC">Any</a></b></td>
      <td><i>This is not a property value; it is used in the rules to 
		represent any code point.</i></td>
    </tr>
  </table>
  </center>
</div>
  <div class="web-only"><p>&nbsp;</p></div>
  <h4>Grapheme Cluster Boundary Rules</h4>
	<p>The same rules are used for the Unicode 
	specification of boundaries for both legacy grapheme clusters and extended grapheme 
	clusters, with one exception. The extended grapheme clusters add rules
	<a href="tr29-18.html#GB9a">GB9a</a> and <a href="tr29-18.html#GB9b">GB9b</a>, while the 
	legacy grapheme clusters omit it.</p>
	<p>When citing the Unicode definition of grapheme clusters, it must be clear which of the two alternatives are being 
	specified: extended versus legacy.</p>
  <table cellspacing="0" cellpadding="4" border="0" class="nb">
    <tr>
      <td class="nb" colspan="4">
      <p class="rule">Break at the start and end of text.</td>
    </tr>
    <tr>
      <td class="nb" width="1%">
		<a name="GB1">GB1</a>.</td>
      <td class="nb" style="text-align:right" width="45%">sot</td>
      <td class="nb" style="text-align:center" width="2%">÷</td>
      <td class="nb" width="40%"></td>
    </tr>
    <tr>
      <td class="nb"><a name="GB2">GB2</a>.</td>
      <td class="nb" style="text-align:right"></td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">eot</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule">Do not break between a CR and LF. Otherwise, break before and after 
      controls.</td>
    </tr>
    <tr>
      <td class="nb"><a name="GB3">GB3</a>.</td>
      <td class="nb" style="text-align:right">CR</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">LF</td>
    </tr>
    <tr>
      <td class="nb"><a name="GB4">GB4</a>.</td>
      <td class="nb" style="text-align:right">( Control | CR | LF )</td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">&nbsp;</td>
    </tr>
    <tr>
      <td class="nb"><a name="GB5">GB5</a>.</td>
      <td class="nb" style="text-align:right"></td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">( Control | CR | LF )</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule">Do not break Hangul syllable sequences.</td>
    </tr>
    <tr>
      <td class="nb"><a name="GB6">GB6</a>.</td>
      <td class="nb" style="text-align:right">L</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">( L | V | LV | LVT )</td>
    </tr>
    <tr>
      <td class="nb"><a name="GB7">GB7</a>.</td>
      <td class="nb" style="text-align:right">( LV | V )</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">( V | T )</td>
    </tr>
    <tr>
      <td class="nb"><a name="GB8">GB8</a>.</td>
      <td class="nb" style="text-align:right">( LVT | T)</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">T</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule">Do not break before extending characters.</td>
    </tr>
	<tr>
      <td class="nb"><a name="GB9">GB9</a>.</td>
      <td class="nb" style="text-align:right">&nbsp;</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Extend</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><b>Only for 
		extended grapheme clusters:</b><br>
		Do not break before 
		SpacingMarks, 
		or after Prepend characters.</td>
    </tr>
    <tr>
      <td class="nb"><b><a name="GB9a">GB9a</a>.</b></td>
      <td class="nb" style="text-align:right">&nbsp;</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">SpacingMark</td>
    </tr>
    <tr>
      <td class="nb"><b><a name="GB9b">GB9b</a>.</b></td>
      <td class="nb" style="text-align:right">Prepend</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">&nbsp;</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule">Otherwise, break everywhere.</td>
    </tr>
    <tr>
      <td class="nb"><a name="GB10">GB10</a>.</td>
      <td class="nb" style="text-align:right">Any</td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">Any</td>
    </tr>
  </table>
  <p><em>Notes:</em></p>
  <ul>
    <li>Grapheme Cluster Boundaries can be easily tested 
      by looking at immediately adjacent characters. They can also be transformed 
      into simple regular expressions, as well. For more information, see <i>
        <a href="tr29-18.html#Regular_Expressions">Section 6.3 Regular Expressions</a></i>.</li>
    <li><span class="removed">Even where the legacy grapheme clusters are used, it may be useful to tailor Thai and Lao to
    add U+0E33 ( ำ ) THAI CHARACTER SARA AM and U+0EB3 ( ຳ ) LAO VOWEL SIGN AM to the Extend type.</span></li>
    <li>A tailoring for basic <em>aksara</em> support would add a rule of the form Virama × Base before GB10, where Virama and Base matched the appropriate characters for the Indic language in question. Typically the behavior of grapheme clusters does not matter for ill-formed text, so the Virama and Base types can be set to broader categories without problem, such as <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=\p{ccc:virama} ">\p{ccc:virama}</a> and <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=\p{gc:letter}">\p{gc:letter}</a>, respectively.</li>
    <li class="changed">The Grapheme_Base and Grapheme_Extend properties predated the development of the Grapheme_Cluster_Break property. The set of characters with Grapheme_Extend=Yes is the same as  the set of characters with Grapheme_Cluster_Break=<span class="nb">Extend</span>. However, the Grapheme_Base property proved to be insufficient for determining grapheme cluster boundaries. Grapheme_Base is no longer used by this specification.</li>
  </ul>
  <h2 class="section"><a name="Word_Boundaries">4 Word Boundaries</a></h2>
  <p>Word boundaries are used in a number of different contexts. The most familiar ones are 
  selection (double-click mouse selection or “move to next word” control-arrow keys) 
  and the dialog option “Whole Word Search” for search and replace. They are also used in database queries, to 
  determine whether elements are within a certain number of words of one another.
	Searching may also use word boundaries in determining matching 
	items. Word break boundaries are not restricted to whitespace and 
	punctuation. Indeed, some languages do not use spaces at all.</p>
  <p>Word boundaries can also be used in <i>intelligent cut and paste</i>. With this 
  feature, if the user cuts a selection of text on word boundaries, adjacent spaces are collapsed to a 
  single space. For example, cutting “quick” from “The_quick_fox” would leave “The_&nbsp;_fox”. 
  Intelligent cut and paste collapses this text to “The_fox”.<i> Figure 1</i> gives an example of word boundaries.</p>
  <div align="center">
<center>
   <p class="caption"><a name="Figure_Word_Boundaries"></a>Figure 1. <span style="font-weight: 400">Word Boundaries</span></p>
     <table cellspacing="0" cellpadding="0" border="1">
      <tr>
        <td>The</td>
        <td>&nbsp;</td>
        <td>quick</td>
        <td>&nbsp;</td>
        <td>(</td>
        <td>“</td>
        <td>brown</td>
        <td>”</td>
        <td>)</td>
        <td>&nbsp;</td>
        <td>fox</td>
        <td>&nbsp;</td>
        <td>can’t</td>
        <td>&nbsp;</td>
        <td>jump</td>
        <td>&nbsp;</td>
        <td>32.3</td>
        <td>&nbsp;</td>
        <td>feet</td>
        <td>,</td>
        <td>&nbsp;</td>
        <td>right</td>
        <td>?</td>
      </tr>
    </table>
    </center>
  </div>
  <p>There is a boundary, for example, on either side of the word <i>brown</i>. These are the 
  boundaries that users would expect, for example, if they chose Whole Word Search. Matching <i>
  brown</i> with Whole Word Search works because there is a boundary on either side. Matching <i>brow</i> 
  does not. Matching <i>“brown”</i> also works because there are boundaries between the parentheses 
  and the quotation marks.</p>
  <p>Proximity tests in searching determines whether, for example, “quick” is within 
	three words of “fox”. 
  That is done with the above boundaries by ignoring any words that do not contain a letter, as in 
  <i><a href="tr29-18.html#Figure_Extracted_Words">Figure 2</a></i>. Thus, for proximity, “fox” is within three words of “quick”. This same technique 
  can be used for “get next/previous word” commands or keyboard arrow keys. Letters are not the only 
  characters that can be used to determine the “significant” words; different implementations may 
  include other types of characters such as digits or perform other analysis of the characters.</p>
  <div align="center">
<center>
    <p class="caption"><a name="Figure_Extracted_Words"></a>Figure 2. <span style="font-weight: 400">Extracted Words</span></p>
    <table cellspacing="0" cellpadding="0" border="1">
      <tr>
        <td>The</td>
        <td>quick</td>
        <td>brown</td>
        <td>fox</td>
        <td>can’t</td>
        <td>jump</td>
        <td>32.3</td>
        <td>feet</td>
        <td>right</td>
      </tr>
    </table>
    </center>
  </div>
  <p>Word boundaries are related to line boundaries, but are distinct: there are some 
  word break boundaries that are not line break boundaries, and vice versa. A 
	line break boundary is usually a word break boundary, but there are 
	exceptions such as a word containing a 
  SHY (soft hyphen): it will break across lines, yet is a single word.</p>
  <p>As with the other default specifications, implementations 
	may override 
    (tailor) the results to meet the requirements of different environments or particular languages. 
    For some languages, it may also be necessary to have different tailored word break 
    rules for selection versus Whole Word Search.</p>
	<p>In particular, the characters with the Line_Break property values of Contingent_Break 
    (CB), Complex_Context (SA/South East Asian), and XX (Unknown) are assigned word boundary 
    property values based on criteria outside of the scope of this annex.
	That means that satisfactory treatment of 
	languages like Chinese or Thai requires special handling.</p>  
  <div class="book-only">&nbsp;</div>
  <h3 class="section">4.1 <b><a name="Default_Word_Boundaries">Default Word Boundary 
	Specification</a></b></h3>
	<p>The Word_Break property value assignments are explicitly listed in the 
	corresponding data file <span class="changed"> in </span>[<a href="../tr41/tr41-7.html#Props">Props</a>].<span class="changed"> The values in that file are the normative property values.</span></p>
    <p class="changed">For illustration, property values are summarized in <a href='tr29-18.html#Table_Word_Break_Property_Values'>Table 3</a>, but the lists of characters are illustrative.</p>
	<div align="center">
  <center>
  <p class="caption"><a name="Table_Word_Break_Property_Values"></a>Table 3. Word_Break Property Values</p>
  <table cellspacing="0" cellpadding="4" border="0">
       <tr>
  <th valign="top">Value</th>
  <th valign="top">Summary List of Characters</th>
    	</tr>
    	<tr>
      <td valign="top"><b><a name="CR0">CR</a></b></td>
      <td> <span class="charlist">U+000D CARRIAGE RETURN (CR)</span></td>
    	</tr>
		<tr>
      <td valign="top"><b><a name="LF0">LF</a></b></td>
      <td> <span class="charlist">U+000A LINE FEED (LF)</span></td>
    	</tr>
		<tr>
      <td valign="top"><b><a name="Newline">Newline</a></b></td>
      <td>
      <span class="charlist">U+000B LINE TABULATION<br>
		U+000C FORM FEED (FF)<br>
		U+0085 NEXT LINE (NEL)<br>
		U+2028 LINE SEPARATOR<br>
		U+2029 PARAGRAPH SEPARATOR</span></td>
    		</tr>
		<tr>
      <td valign="top"><b><a name="Extend0">Extend</a></b></td>
      <td>
      Grapheme_Extend = true, or<br>
		General_Category = Spacing Mark</td>
    		</tr>
    <tr>
      <td valign="top"><b><a name="Format">Format</a></b></td>
      <td>General_Category = Format (Cf)<br>
		<i>and not</i> <span class="charlist">U+200B ZERO WIDTH SPACE (ZWSP)</span><br>
      <i>and not</i> <span class="charlist">U+200C ZERO WIDTH NON-JOINER (ZWNJ)</span><br>
      <i>and not</i> <span class="charlist">U+200D ZERO WIDTH JOINER (ZWJ) </span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Katakana">Katakana</a></b></td>
      <td>Script = KATAKANA, <i>or<br>
     </i> any of the following:<br>
      <span class="charlist">U+3031 (</span><span class="symbol">〱</span><span class="charlist">) VERTICAL KANA REPEAT MARK<br>
      U+3032 (</span><span class="symbol">〲</span><span class="charlist">) VERTICAL KANA REPEAT WITH VOICED SOUND MARK<br>
      U+3033 (</span><span class="symbol">〳</span><span class="charlist">) VERTICAL KANA REPEAT MARK UPPER HALF<br>
      U+3034 (</span><span class="symbol">〴</span><span class="charlist">) VERTICAL KANA REPEAT WITH VOICED SOUND MARK UPPER HALF<br>
      U+3035 (</span><span class="symbol">〵</span><span class="charlist">) VERTICAL KANA REPEAT MARK LOWER HALF<br>
      U+309B (</span><span class="symbol">゛</span><span class="charlist">) KATAKANA-HIRAGANA VOICED SOUND MARK<br>
      U+309C (</span><span class="symbol">゜</span><span class="charlist">) KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK<br>
      U+30A0 (</span><span class="symbol">゠</span><span class="charlist">) KATAKANA-HIRAGANA DOUBLE HYPHEN<br>
      U+30FC (</span><span class="symbol">ー</span><span class="charlist">) KATAKANA-HIRAGANA 
      PROLONGED SOUND MARK<br>
      U+FF70 (</span><span class="symbol">ｰ</span><span class="charlist">) HALFWIDTH 
      KATAKANA-HIRAGANA PROLONGED SOUND MARK</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="ALetter">ALetter</a></b></td>
      <td>Alphabetic = true, <i>or<br>
     </i><span class="charlist">U+05F3 (׳) HEBREW PUNCTUATION GERESH</span><br>
      <i>and</i> Ideographic = false<br>
      <i>and</i> Word_Break <span class="mathsym2">≠ </span>Katakana<br>
      <i>and</i> LineBreak <span class="mathsym2">≠</span> Complex_Context (SA)<br>
      <i>and</i> Script <span class="mathsym2">≠</span> Hiragana<br>
      <i>and</i> Word_Break ≠ Extend</td>
    </tr>
    	<tr>
      <td valign="top"><b>MidNumLet</b></td>
      <td><span class="charlist">U+0027 (</span> &#39; <span class="charlist">) APOSTROPHE<br>
		U+002E (</span> . <span class="charlist">) FULL STOP<br>
		U+2018 (</span> &#39; <span class="charlist">) LEFT SINGLE QUOTATION MARK<br>
		U+2019 (</span> &#39; <span class="charlist">) RIGHT SINGLE QUOTATION MARK<br>
		U+2024 (</span> ․ <span class="charlist">) ONE DOT LEADER<br>
		U+FE52 (</span> ﹒ <span class="charlist">) SMALL FULL STOP<br>
		U+FF07 (</span> ＇ <span class="charlist">) FULLWIDTH APOSTROPHE<br>
		U+FF0E (</span> ． <span class="charlist">) FULLWIDTH FULL STOP</span></td>
    	</tr>
    <tr>
      <td valign="top"><b><a name="MidLetter">MidLetter</a></b></td>
      <td>Any of the following:<span class="charlist"><br>
      U+00B7 (</span> <span class="symbol">·</span> <span class="charlist">) MIDDLE DOT<br>
      U+05F4 (</span> <span class="charlist"><span class="symbol">״</span></span>
		<span class="charlist">) HEBREW PUNCTUATION GERSHAYIM<br>
		U+2027 (</span> <span class="symbol">‧</span> <span class="charlist">) HYPHENATION POINT<br>
      U+003A (</span> <span class="symbol">:</span> <span class="charlist">) COLON (used in Swedish)<br>
		U+0387 (</span> · <span class="charlist">) GREEK ANO TELEIA<br>
		U+FE13 (</span> ︓ <span class="charlist">) PRESENTATION FORM FOR VERTICAL COLON<br>
		U+FE55 (</span> ﹕ <span class="charlist">) SMALL COLON<br>
		U+FF1A (</span> ： <span class="charlist">) FULLWIDTH COLON</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="MidNum">MidNum</a></b></td>
      <td>Line_Break = Infix_Numeric, <i>or<br>
     </i> any of the following:<br>
		<span class="charlist">U+066C (</span> ٬ <span class="charlist">) ARABIC THOUSANDS SEPARATOR<br>
		U+FE50 (</span> ﹐ <span class="charlist">) SMALL COMMA<br>
		U+FE54 (</span> ﹔ <span class="charlist">) SMALL SEMICOLON<br>
		U+FF0C (</span> ， <span class="charlist">) FULLWIDTH COMMA<br>
		U+FF1B (</span> ； <span class="charlist">) FULLWIDTH SEMICOLON</span><i><br>
		and not</i> <span class="charlist">U+003A (</span> <span class="symbol">:</span> <span class="charlist">) COLON<br>
		</span><i>and not</i> <span class="charlist">U+FE13 (</span> ︓ <span class="charlist">
		) PRESENTATION FORM FOR VERTICAL COLON</span><br>
		<i>and not</i> <span class="charlist">U+002E (</span> . <span class="charlist">
		) FULL STOP</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Numeric">Numeric</a></b></td>
      <td>Line_Break = Numeric<br>
		and not <span class="charlist">U+066C ( ٬ ) ARABIC THOUSANDS SEPARATOR</span>
    </tr>
    <tr>
      <td valign="top"><b><a name="ExtendNumLetWB">ExtendNumLet</a></b></td>
      <td>General_Category = Connector_Punctuation</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="AnyWB">Any</a></b></td>
      <td><i>This is not a property value; it is used in the rules to 
		represent any code point.</i></td>
    </tr>
  </table>
  </center>
</div>
  <p>&nbsp;</p>
  <h4>Word Boundary Rules</h4>
  <table cellspacing="0" cellpadding="4" border="0" class ="nbwide">
    <tr>
      <td colspan="4" class="nb">
      <p class="rule"><i>Break at the start and end of text.</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB1">WB1</a>.</td>
      <td width="45%"class="nb" style="text-align: right">sot</td>
      <td class="nb" style="text-align:center" width="2%">÷</td>
      <td width="40%" class="nb"></td>
    </tr>
    <tr>
      <td class="nb" style="text-align:left">
		<a name="WB2">WB2</a>.</td>
      <td class="nb"></td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">eot</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break within CRLF.</i></td>
    </tr>
	<tr>
      <td class="nb">
		<a name="WB3">WB3</a>.</td>
      <td class="nb" style="text-align:right">CR</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">LF</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule">Otherwise break before and after 
		Newlines (including CR and LF)</td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB3a">WB3a</a>.</td>
      <td class="nb" style="text-align:right">(Newline 
		| CR | LF)</td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">&nbsp;</td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB3b">WB3b</a>.</td>
      <td class="nb" style="text-align:right">&nbsp;</td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">(Newline | CR | LF)</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Ignore Format and Extend characters, except when they appear at the beginning of a region of 
      text.<br>
		(See <span class="section">Section </span><span class="secno">6.2,</span>&nbsp;<a href="tr29-18.html#Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a>.)</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB4">WB4</a>.</td>
      <td class="nb" style="text-align:right">X (Extend | Format)*</td>
      <td class="nb" style="text-align:center">→</td>
      <td class="nb">X</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break between most letters.</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB5">WB5</a>.</td>
      <td class="nb" style="text-align: right">
		ALetter</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">ALetter</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break letters across certain punctuation.</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB6">WB6</a>.</td>
      <td class="nb" style="text-align:right">ALetter</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">(MidLetter | MidNumLet) ALetter</td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB7">WB7</a>.</td>
      <td class="nb" style="text-align:right">ALetter (MidLetter | 
		MidNumLet)</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">ALetter</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break within sequences of digits, or digits adjacent to letters 
      (“3a”, or “A3”).</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB8">WB8</a>.</td>
      <td class="nb" style="text-align:right">Numeric</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Numeric</td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB9">WB9</a>.</td>
      <td class="nb" style="text-align:right">ALetter</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Numeric</td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB10">WB10</a>.</td>
      <td class="nb" style="text-align:right">Numeric</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">ALetter</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break within sequences, such as “3.2” or “3,456.789”.</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB11">WB11</a>.</td>
      <td class="nb" style="text-align:right">Numeric (MidNum | MidNumLet)</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Numeric</td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB12">WB12</a>.</td>
      <td class="nb" style="text-align:right">Numeric</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">(MidNum | MidNumLet) Numeric</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break between Katakana.</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB13">WB13</a>.</td>
      <td class="nb" style="text-align:right">Katakana</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Katakana</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
		<p class="rule"><i>Do not break from extenders.</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB13a">WB13a</a>.</td>
      <td class="nb" style="text-align:right">(ALetter | Numeric | Katakana | ExtendNumLet) </td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">ExtendNumLet</td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB13b">WB13b</a>.</td>
      <td class="nb" style="text-align:right">ExtendNumLet</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">(ALetter | Numeric | Katakana) </td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Otherwise, break everywhere (including around ideographs).</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="WB14">WB14</a>.</td>
      <td class="nb" style="text-align:right">Any</td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">Any</td>
    </tr>
  </table>
  <p><br>
  <span class="note">Notes:</span> </p>
  <ul>
    <li>
    <p>It is not possible to provide a uniform set of rules that 
	resolves all issues across languages or that handles all ambiguous 
	situations within a given 
    language. The goal for the specification presented in this annex is to 
	provide a workable default; 
    tailored implementations can be more sophisticated.</li>
    <li>
    <p>For Thai, Lao, Khmer, Myanmar, and other scripts that do not use typically use 
    spaces between words, a good implementation should not depend on the default word boundary 
    specification. It should use a more sophisticated mechanism, as is also 
	required for line breaking. Ideographic 
    scripts such as Japanese and Chinese are even more complex. Where Hangul text is written without 
    spaces, the same applies. However, in the absence of a more sophisticated mechanism, the 
    rules specified in this annex supply a well-defined default.</li>
    <li>
    <p>The correct interpretation of hyphens in the context of word 
	boundaries is challenging. It is quite common for separate words to be 
	connected with a hyphen: “out-of-the-box,” “under-the-table,” “Italian-American,” 
	and so on. A significant number are hyphenated names, such as “Smith-Hawkins.” 
	When doing a Whole Word Search or query, users expect to find the word 
	within those hyphens. While there are some cases where they are separate 
	words (usually to resolve some ambiguity such as “re-sort” as opposed to “resort”), it 
	is better 
    overall to keep the hyphen out of the default definition. Hyphens include 
	U+002D <span class="name">HYPHEN-MINUS</span>, U+2010 <span class="name">HYPHEN</span>, possibly also
    U+058A (<span class="charlist"> ֊ </span>) <span class="name">ARMENIAN HYPHEN</span>, and U+30A0<span class="charlist">
	</span><span class="name">KATAKANA-HIRAGANA DOUBLE HYPHEN</span>.</li>
    <li>
    <p>Implementations may build on the information 
	supplied by word boundaries. For example, a spell-checker would first check 
	that each word was valid according to the above definition, checking the four 
	words in “out-of-the-box.” If any of the words failed, it could build the 
	compound word and check if it as a whole sequence was in the dictionary (even if all 
	the components were not in the dictionary), such as with “re-iterate.” Of 
	course, spell-checkers for highly inflected or agglutinative languages will 
	need much more sophisticated algorithms.</li>
    <li>
    <p>The use of the apostrophe is ambiguous. It is usually considered part of one word (“can’t” 
	or 
    “aujourd’hui”) but it may also be considered as part of two words (“l’objectif”). 
	A further complication is the use of the same character as an apostrophe and 
	as a quotation mark. Therefore leading or trailing apostrophes are 
	best excluded from the default definition of a word. In some languages, such 
	as French and Italian, tailoring to break words when the character after the 
	apostrophe is a vowel may yield better results in more cases. This can be 
	done by adding a rule WB5a.</p>
    <table cellspacing="0" cellpadding="4" border="0" style="border:none">
      <tr>
        <td class="nb" colspan="4">
        <p class="rule"><i>Break between apostrophe and vowels (French, Italian).</i></td>
      </tr>
      <tr>
        <td class="nb">
			WB5a.</td>
        <td class="nb" style="text-align:right" width="45%"><i>apostrophe</i> </td>
        <td class="nb" style="text-align:center">÷</td>
        <td class="nb" width="40%">vowels</td>
      </tr>
    </table>
    <p>and defining appropriate property values for apostrophe and vowels. Apostrophe includes
    U+0027 (<span class="symbol">&#39;</span>) 
    <span class="name">APOSTROPHE</span> and U+2019 (<span class="symbol">’</span>) 
	<span class="name">RIGHT SINGLE QUOTATION MARK</span><span class="charlist"> </span>(curly apostrophe<span class="charlist">)</span>. Finally, in some transliteration schemes, apostrophe is 
    used at the beginning of words, requiring special tailoring.<br>
    </li>
    <li>
    <p>To allow acronyms like “U.S.A.”, a tailoring may include U+002E
	<span class="name">FULL STOP</span>
    in <a name="ExtendNumLetSB">ExtendNumLet</a>.</li>
    <li>
    <p>Certain cases such as colons in words (c:a) are included in the default 
    even though they may be specific to relatively small user communities (Swedish) because they do 
    not occur otherwise, in normal text, and so do not cause a problem for other languages.</li>
    <li>
    <p>For Hebrew, a tailoring may include a double quotation mark between letters, 
    because legacy data may contain that in place of <span class="charlist">U+05F4 (״) gershayim</span>. 
    This can be done by adding double quotation mark to MidLetter. <span class="charlist">U+05F3 (׳) 
    </span><span class="name">HEBREW PUNCTUATION GERESH</span> may also be included in a tailoring.</li>
    <li>
    <p>Format characters are included if they are not initial. Thus &lt;LRM&gt;&lt;ALetter&gt; will 
    break before the &lt;letter&gt;, but there is no break in &lt;ALetter&gt;&lt;LRM&gt;&lt;ALetter&gt; or &lt;ALetter&gt;&lt;LRM&gt;.</li>
    <li>
    <p>Characters such as hyphens, apostrophes, quotation 
    marks, and colon should be taken into account when using identifiers that are intended to 
    represent words of one or more natural languages. See <span class="section">Section </span><span class="secno">2.4,</span> <i>Specific 
    Character Adjustments</i>, of [<a href="../tr41/tr41-7.html#UAX31">UAX31</a>]. 
    Treatment of hyphens, in particular, may be different in the case of processing identifiers than 
    when using word break analysis for a Whole Word Search or query, because when handling 
    identifiers the goal will be to parse maximal units corresponding to natural language “words,” 
    rather than to find smaller word units within longer lexical units connected by hyphens.</li>
	<li>
    <p>Normally word breaking does not require breaking between different 
	scripts. However, adding that capability may be useful in combination with other extensions of 
	word segmentation. For example, in Korean the sentence &quot;I live in Chicago.&quot; is written as three 
	segments delimited by spaces:<ul>
    <li>나는&nbsp; Chicago에&nbsp; 산다.</li>
  </ul>
  	<p>According to Korean standards, the grammatical suffixes, such as 
	&#39;에&#39; meaning &#39;in&#39;, are considered separate words. Thus the above sentence would be broken into 
	the following five words:
  <ul>
    <li>나,&nbsp; 는,&nbsp; Chicago,&nbsp; 에, and&nbsp; 산다.</li>
  </ul>
  	<p>Separating the first two words requires a dictionary lookup, but 
	for Latin text (&quot;Chicago&quot;) the separation is trivial based on the script boundary. </li>
	<li>Modifier letters (Lm) are almost all included in the ALetter 
	class, by virtue of their Alphabetic property value. Thus, by default, modifier letters do not 
	cause word breaks and should be included in word selections. Modifier symbols (Sk) are not in 
	the ALetter class and so do cause word breaks by default.</li>
	<li>Some or all of the following characters may be tailored to be in MidLetter, depending on the environment:
	  <ul>
	    <li>U+002D ( - ) HYPHEN-MINUS<br>
	      U+055A ( ՚ ) ARMENIAN APOSTROPHE<br>
	      U+058A ( ֊ ) ARMENIAN HYPHEN<br>
	      U+0F0B ( ་ ) TIBETAN MARK INTERSYLLABIC TSHEG<br>
	      U+1806 ( ᠆ ) MONGOLIAN TODO SOFT HYPHEN<br>
	      U+2010 ( ‐ ) HYPHEN<br>
	      U+2011 ( ‑ ) NON-BREAKING HYPHEN<br>
	      U+201B ( ‛ ) SINGLE HIGH-REVERSED-9 QUOTATION MARK<br>
	      U+30A0 ( ゠ ) KATAKANA-HIRAGANA DOUBLE HYPHEN<br>
	      U+30FB ( ・ ) KATAKANA MIDDLE DOT<br>
	      U+FE63 ( ﹣ ) SMALL HYPHEN-MINUS<br>
	      U+FF0D ( － ) FULLWIDTH HYPHEN-MINUS</li>
	    <li>In UnicodeSet notation, this is: <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\u002D\uFF0D\uFE63\u058A\u1806\u2010\u2011\u30A0\u30FB\u201B\u055A\u0F0B]">[\u002D\uFF0D\uFE63\u058A\u1806\u2010\u2011\u30A0\u30FB\u201B\u055A\u0F0B]</a></li>
	    <li><span class="changed">For example, some  writing systems  use a hyphen character between syllables within a word. An example is the Iu Mien language written with the Thai script. Such words should behave as single words for the purpose of selection ("double-click"), indexing, and so forth, meaning that they should not word-break on the hyphen.</span><br>
	      </li>
	    </ul>
	  </li>
	<li>
	  Some or all of the following characters may be tailored to be in MidNum, depending on the environment, to allow for 
	  languages that use spaces as thousands separators, such as <font face="Arial">€</font>1 234,56.
	  <ul>
	    <li>U+0020 ( ) SPACE<br>
	      U+00A0 ( &nbsp; ) NO-BREAK SPACE <br>
	      U+2007 (   ) FIGURE SPACE<br>
	      U+2008 (   ) PUNCTUATION SPACE<br>
	      U+2009 (   ) THIN SPACE<br>
	      U+202F (   ) NARROW NO-BREAK SPACE
	      </li>
	    <li >In UnicodeSet notation, this is: <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\u0020\u00A0\u2007\u2008\u2009\u202F]">[\u0020\u00A0\u2007\u2008\u2009\u202F]</a></li>
	    </ul>
	  </li>
	</ul>
  <h3>4.2 <a name="Name_Validation">Name Validation</a></h3>
  <p>Related to word determination is the issue of <em>personal name validation</em>. Implementations sometimes need to validate fields in which personal names are entered.  The goal is  to distinguish between characters like those in &quot;James Smith-Faley, Jr.&quot; and those in &quot;!#@♥≠&quot;. It is important to be reasonably lenient, because users  need to be able to add legitimate names, like &quot;di Silva&quot;, even if the names contain characters such as <em>space</em>. Typically, these personal name validations should not be language-specific; someone might be using a Web site in one language while his name is in a different language, for example. A basic set of name validation characters consists the characters allowed in words according to the above definition, plus a number of exceptional characters:</p>
  <p><em>Basic Name Validation Characters</em></p>
  <ul>
    <li><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\p{name%3D%2FCOMMA%2F}\p{name%3D%2FFULL+STOP%2F}%26\p{p}%0D%0A\p{whitespace}-\p{c}%0D%0A\p{alpha}%0D%0A\p{wb%3DKatakana}\p{wb%3DExtend}\p{wb%3DALetter}\p{wb%3DMidLetter}\p{wb%3DMidNumLet}%0D%0A[\u002D\u055A\u058A\u0F0B\u1806\u2010\u2011\u201B\u2E17\u30A0\u30FB\uFE63\uFF0D]]">[\p{name=/COMMA/}\p{name=/FULL STOP/}&amp;\p{p}<br>
      \p{whitespace}-\p{c}<br>
      \p{alpha}<br>
      \p{wb=Katakana}\p{wb=Extend}\p{wb=ALetter}\p{wb=MidLetter}\p{wb=MidNumLet}<br>
[\u002D\u055A\u058A\u0F0B\u1806\u2010\u2011\u201B\u2E17\u30A0\u30FB\uFE63\uFF0D]]</a></li>
  </ul>
<p>This is  only a basic set of validation characters; in particular, the following points should be kept in mind:</p>
<ul>
  <li> It is a lenient, non-language-specific set, and could be tailored where only a limited set of languages are permitted, or for other environments. For example, the set can be narrowed if name fields are separated: &quot;,&quot; and &quot;.&quot; may not be necessary if titles are not allowed.</li>
  <li>It includes characters that may not be appropriate for identifiers, and some that would not be parts of words. It also permits some characters that may be part of words in a broad sense, but not part of names, such as in &quot;c:a&quot; in Swedish, or hyphenation points used in dictionary words.</li>
  <li>Additional tests may be needed in cases where security is at issue. In particular, names may be validated by transforming them to NFC format, and then testing to ensure that no characters in the result of the transformation  change under NFKC. A second test is to use the information in<em> Table 5. Recommended Scripts</em> in  <em>Unicode Identifier and Pattern Syntax</em> [<a href="../tr41/tr41-7.html#UAX31">UAX31</a>]. If the name has one or more characters with explicit script values that are not in Table 5, then reject the name.</li>
</ul>
<h2 class="section"><a name="Sentence_Boundaries">5 Sentence Boundaries</a></h2>
  <p>Sentence boundaries are often used for triple-click or some other method of selecting or 
  iterating through blocks of text that are larger than single words. They are also used to 
  determine whether words occur within the same sentence in database queries.</p>
  <p>Plain text provides inadequate information for determining good sentence 
	boundaries. Periods can signal the end of a sentence, indicate 
	abbreviations, or be used for decimal points, for example. Without much more 
	sophisticated analysis, one cannot distinguish between the two following 
	examples of the sequence &lt;?, ”, space, uppercase-letter&gt;.
	In the first example, they mark the end of a 
	sentence, while in the second they do not.</p>
  <blockquote>
    <table cellspacing="0" cellpadding="0" border="1">
      <tr>
        <td>He said, “Are you going?”&nbsp;</td>
        <td>John shook his head.</td>
      </tr>
    </table><br>
<table cellspacing="0" cellpadding="0" border="1">
      <tr>
        <td>“Are you going?” John asked.</td>
      </tr>
    </table>
  </blockquote>
  <p>Without analyzing the text 
  semantically, it is impossible to be certain which of these usages is intended (and sometimes 
  ambiguities still remain). However, in most cases a straightforward mechanism 
  works well.</p>
  <blockquote>
    <p><span class="note">Note:</span> As with the other default specifications, implementations are free to override 
    (tailor) the results to meet the requirements of different environments or particular languages.</p>
  </blockquote>
  <div class="book-only"><p>&nbsp;</p></div>
  <h3 class="section">5.1 <a name="Default_Sentence_Boundaries">Default Sentence Boundary 
	Specification</a></h3>
	<p>The Sentence_Break property value assignments are explicitly listed in 
	the corresponding data file<span class="changed"> in </span>[<a href="../tr41/tr41-7.html#Props">Props</a>].<span class="changed"> The values in that file are the normative property values.</span></p>
    <p class="changed">For illustration, property values are summarized in <a href='tr29-18.html#Table_Sentence_Break_Property_Values'>Table 4</a>, but the lists of characters are illustrative.</p>
	<div align="center">
  <center>
   <p class="caption"><a name="#Table_Sentence_Break_Property_Values"></a>Table 4. Sentence_Break Property Values</p>    
  <table cellspacing="0" cellpadding="4" border="0" class="nbwide">
  <tr>    
  <th valign="top">Value</th>
  <th valign="top">Summary List of Characters</th>
    </tr>
    <tr>
      <td valign="top"><b><a name="CR1">CR</a></b></td>
      <td><span class="charlist">U+000D CARRIAGE RETURN (CR)</span></td>
    </tr>
	<tr>
      <td valign="top"><b><a name="LF1">LF</a></b></td>
      <td><span class="charlist">U+000A LINE FEED (LF)</span></td>
    </tr>
	<tr>
      <td valign="top"><b><a name="Extend1">Extend</a></b></td>
      <td>
      Grapheme_Extend = true, or<br>
		General_Category = Spacing Mark</td>
    	</tr>
    <tr>
      <td valign="top"><b><a name="Sep">Sep</a></b></td>
      <td>Any of the following characters:<span class="charlist"><br>
      U+0085 NEXT LINE (NEL)<br>
      U+2028 LINE SEPARATOR (LS)<br>
      U+2029 PARAGRAPH SEPARATOR (PS)</span></td>
    </tr>
    <tr>
      <td valign="top"><b>Format</b></td>
      <td>General_Category = Format (Cf)<i><br>
      and not</i> <span class="charlist">U+200C ZERO WIDTH NON-JOINER (ZWNJ)
      </span><br>
      <i>and not</i> <span class="charlist">U+200D ZERO WIDTH JOINER (ZWJ) </span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Sp">Sp</a></b></td>
      <td>Whitespace = true<br>
      <i>and</i> Sentence_Break<span class="mathsym2"> ≠</span> Sep<br>
		<i>and </i>Sentence_Break<span class="mathsym2"> ≠</span> CR<br>
		<i>and </i>Sentence_Break<span class="mathsym2"> ≠</span> LF</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Lower">Lower</a></b></td>
      <td>Lowercase = true<br>
      <i>and</i> GRAPHEME EXTEND = false</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Upper">Upper</a></b></td>
      <td>General_Category = Titlecase_Letter (Lt), <i>or</i><br>
      Uppercase = true</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="OLetter">OLetter</a></b></td>
      <td>Alphabetic = true, <i>or<br>
     </i> <span class="charlist">U+00A0 (</span><b>&nbsp;</b><span class="charlist">) NO-BREAK SPACE (NBSP)</span>,<i>
      or</i><br>
      <span class="charlist">U+05F3 (</span><span class="symbol">׳</span><span class="charlist">) HEBREW PUNCTUATION GERESH<br>
      </span><i>and</i> Lower = false<br>
      <i>and</i> Upper = false<br>
      <i>and</i> Sentence_Break ≠ Extend</td>
    </tr>
    <tr>
      <td valign="top"><b>Numeric</b></td>
      <td>Linebreak = Numeric (NU)</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="ATerm">ATerm</a></b></td>
      <td><span class="charlist">U+002E (</span><span class="symbol">.</span><span class="charlist">) 
      FULL STOP<br>
		U+2024 (</span> ․ <span class="charlist">) ONE DOT LEADER<br>
		U+FE52 (</span> ﹒ <span class="charlist">) SMALL FULL STOP<br>
		U+FF0E (</span> ． <span class="charlist">) FULLWIDTH FULL STOP</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="SContinue">SContinue</a></b></td>
      <td><span class="charlist">U+002C (</span>&nbsp;,&nbsp;<span class="charlist">) COMMA<br>
		U+002D (</span>&nbsp;-&nbsp;<span class="charlist">) HYPHEN-MINUS<br>
		U+003A (</span>&nbsp;:&nbsp;<span class="charlist">) COLON<br>
		U+055D (</span>&nbsp;՝&nbsp;<span class="charlist">) ARMENIAN COMMA<br>
		U+060C (</span>&nbsp;،&nbsp;<span class="charlist">) ARABIC COMMA<br>
		U+060D (</span>&nbsp;‎؍‎&nbsp;<span class="charlist">) ARABIC DATE SEPARATOR<br>
		U+07F8 (</span>&nbsp;߸&nbsp;<span class="charlist">) NKO COMMA<br>
		U+1802 (</span>&nbsp;᠂&nbsp;<span class="charlist">) MONGOLIAN COMMA<br>
		U+1808 (</span>&nbsp;᠈&nbsp;<span class="charlist">) MONGOLIAN MANCHU COMMA<br>
		U+2013 (</span>&nbsp;–&nbsp;<span class="charlist">) EN DASH<br>
		U+2014 (</span>&nbsp;—&nbsp;<span class="charlist">) EM DASH<br>
		U+3001 (</span>&nbsp;、&nbsp;<span class="charlist">) IDEOGRAPHIC COMMA<br>
		U+FE10 (</span>&nbsp;︐&nbsp;<span class="charlist">) PRESENTATION FORM FOR VERTICAL COMMA<br>
		U+FE11 (</span>&nbsp;︑&nbsp;<span class="charlist">) PRESENTATION FORM FOR VERTICAL IDEOGRAPHIC COMMA<br>
		U+FE13 (</span>&nbsp;︓&nbsp;<span class="charlist">) PRESENTATION FORM FOR VERTICAL COLON<br>
		U+FE31 (</span>&nbsp;︱&nbsp;<span class="charlist">) PRESENTATION FORM FOR VERTICAL EM DASH<br>
		U+FE32 (</span>&nbsp;︲&nbsp;<span class="charlist">) PRESENTATION FORM FOR VERTICAL EN DASH<br>
		U+FE50 (</span>&nbsp;﹐&nbsp;<span class="charlist">) SMALL COMMA<br>
		U+FE51 (</span>&nbsp;﹑&nbsp;<span class="charlist">) SMALL IDEOGRAPHIC COMMA<br>
		U+FE55 (</span>&nbsp;﹕&nbsp;<span class="charlist">) SMALL COLON<br>
		U+FE58 (</span>&nbsp;﹘&nbsp;<span class="charlist">) SMALL EM DASH<br>
		U+FE63 (</span>&nbsp;﹣&nbsp;<span class="charlist">) SMALL HYPHEN-MINUS<br>
		U+FF0C (</span>&nbsp;，&nbsp;<span class="charlist">) FULLWIDTH COMMA<br>
		U+FF0D (</span>&nbsp;－&nbsp;<span class="charlist">) FULLWIDTH HYPHEN-MINUS<br>
		U+FF1A (</span>&nbsp;：&nbsp;<span class="charlist">) FULLWIDTH COLON<br>
		U+FF64 (</span>&nbsp;､&nbsp;<span class="charlist">) HALFWIDTH IDEOGRAPHIC COMMA</span></td>
    </tr>
    <tr>
      <td valign="top"><b><a name="STerm">STerm</a></b></td>
      <td>STerm = true</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="Close">Close</a></b></td>
      <td>General_Category = Open_Punctuation (Po), <i>or</i><br>
      General_Category = Close_Punctuation (Pe), <i>or</i><br>
      Linebreak = Quotation (QU)<br>
      <i>and not</i> <span class="charlist">U+05F3 (</span> <span class="symbol">׳</span>
		<span class="charlist">) HEBREW PUNCTUATION GERESH<br>
      </span><i>and</i> ATerm = false<br>
      <i>and</i> STerm = false</td>
    </tr>
    <tr>
      <td valign="top"><b><a name="AnySB">Any</a></b></td>
      <td><i>This is not a property value; it is used in the rules to 
		represent any code point.</i></td>
    </tr>
  </table></center>
</div>
  <p>&nbsp;</p>
  <h4>Sentence Boundary Rules</h4>
  <table cellspacing="0" cellpadding="4" border="0" class="nb">
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Break at the start and end of text.</i></td>
    </tr>
    <tr>
      <td class="nb" width="1%">
		<a name="SB1">SB1</a>.</td>
      <td class="nb" style="text-align:right" width="45%">sot</td>
      <td class="nb" style="text-align:center" width="2%">÷</td>
      <td class="nb" width="40%"></td>
    </tr>
    <tr>
      <td class="nb"><a name="SB2">SB2</a>.</td>
      <td class="nb" style="text-align:right"></td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">eot</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Do not break within CRLF.</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="SB3">SB3</a>.</td>
      <td class="nb" style="text-align:right">CR</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">LF</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Break after paragraph separators.</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="SB4">SB4</a>.</td>
      <td class="nb" style="text-align:right">Sep | CR | LF</td>
      <td class="nb" style="text-align:center">÷</td>
      <td  class="nb">&nbsp;</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Ignore Format and Extend characters, except when they appear at the beginning of a region of 
      text.
		(See <span class="section">Section </span><span class="secno">6.2,</span>&nbsp;<a href="tr29-18.html#Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a>.)</i></td>
    </tr>
    <tr>
      <td class="nb">
		<a name="SB5">SB5</a>.</td>
      <td class="nb" style="text-align:right">X (Extend | Format)*</td>
      <td class="nb" style="text-align:center">→</td>
      <td  class="nb">X</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule">Do not break after ambiguous terminators like period, if they are immediately 
		followed by a number or lowercase letter, if they are between uppercase letters,
		if the first following letter (optionally after certain 
		punctuation) is lowercase, or if they are followed by 
		“continuation” punctuation such as comma, colon, or semicolon. For example, a period 
		may be an abbreviation or numeric period, and thus may not mark the end of a sentence.</td>
    </tr>
    <tr>
      <td class="nb"><a name="SB6">SB6</a>.</td>
      <td class="nb" style="text-align:right">ATerm</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Numeric</td>
    </tr>
    <tr>
      <td class="nb"><a name="SB7">SB7</a>.</td>
      <td class="nb" style="text-align:right">Upper ATerm</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Upper</td>
    </tr>
    <tr>
      <td class="nb"><a name="SB8">SB8</a>.</td>
      <td class="nb" style="text-align:right">ATerm Close* Sp*</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">( ¬(OLetter | Upper | Lower | Sep | CR | LF | STerm | ATerm) )* Lower</td>
    </tr>
    <tr>
      <td class="nb">
		<a name="SB8a">SB8a</a>.</td>
      <td class="nb" style="text-align:right">(STerm | ATerm) Close* Sp*</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">(SContinue | STerm | ATerm)</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Break after sentence terminators, but include closing punctuation, trailing 
      spaces, and a paragraph separator (if present). [See note below.]</i></td>
    </tr>
    <tr>
      <td class="nb"><a name="SB9">SB9</a>.</td>
      <td class="nb" style="text-align:right">( STerm | ATerm ) Close*</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">( Close | Sp | Sep | CR | LF )</td>
    </tr>
    <tr>
      <td class="nb"><a name="SB10">SB10</a>.</td>
      <td class="nb" style="text-align:right">( STerm | ATerm ) Close* Sp*</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">( Sp | Sep | CR | LF )</td>
    </tr>
    <tr>
      <td class="nb"><a name="SB11">SB11</a>.</td>
      <td class="nb" style="text-align:right">( STerm | ATerm ) Close* Sp* 
		( Sep | CR | LF )?</td>
      <td class="nb" style="text-align:center">÷</td>
      <td class="nb">&nbsp;</td>
    </tr>
    <tr>
      <td class="nb" colspan="4">
      <p class="rule"><i>Otherwise, do not break.</i></td>
    </tr>
    <tr>
      <td class="nb"><a name="SB12">SB12</a>.</td>
      <td class="nb" style="text-align:right">Any</td>
      <td class="nb" style="text-align:center">×</td>
      <td class="nb">Any</td>
    </tr>
  </table>
    <div class="book-only"><p style="font-size:50%">&nbsp;</p></div>
	<p><span class="note">Notes:</span></p>
  <ul>
    <li>
    <p>Rules SB6-8 are designed to forbid breaks within strings such as</p>
	<div align="center"><center>
		<table cellspacing="0" cellpadding="0" border="1">
			<tr>
				<td class="nb" style="text-align:center">c.d&nbsp;</td>
			</tr>
			<tr>
				<td class="nb" style="text-align:center">3.4</td>
			</tr>
			<tr>
				<td class="nb" style="text-align:center">U.S.</td>
			</tr>
			<tr>
				<td class="nb" style="text-align:center">... the resp. leaders are ...</td>
			</tr>
			<tr>
				<td class="nb" style="text-align:center">... etc.)’&nbsp;‘(the ...</td>
			</tr>
		</table>
		<p></p></center></div>
	<p>They permit breaks in strings such as</p>
	<div align="center"><center>
		<table cellspacing="0" cellpadding="0" border="1">
			<tr>
				<td class="nb" style="text-align:left">&nbsp;She said “See spot run.”&nbsp;</td>
				<td>John shook his head. ...</td>
			</tr>
			<tr>
				<td class="nb" style="text-align:left">... etc.</td>
				<td>它们指...</td>
			</tr>
			<tr>
				<td class="nb" style="text-align:left">...理数字.</td>
				<td>它们指...</td>
			</tr>
		</table></center></div>
	<p>They cannot detect cases such as “...Mr. Jones...”; more 
    sophisticated tailoring would be required to detect such cases.</li>
  	<li>Rules SB9-11 are designed to allow breaks after sequences of the 
	following form, but not within them:<ul>
    <li>( STerm | ATerm ) Close* Sp* ( Sep | CR | LF )?</li>
  </ul>
  	</li>
  </ul>
  <h2 class="section"><a name="Implementation_Notes">6 Implementation Notes</a></h2>
  <h3 class="section">6.1 <a name="Normalization">Normalization</a></h3>
  <p>The boundary specifications are stated in terms of text normalized 
	according to Normalization Form NFD (see Unicode Standard Annex #15, &#x201C;Unicode 
	Normalization Forms&#x201D; [<a href="../tr41/tr41-7.html#UAX15">UAX15</a>]). In practice, normalization of the input is not 
  required. To ensure that the same results are returned for canonically equivalent text (that is, 
  the same boundary positions will be found, although those may be represented by different 
  offsets), the grapheme cluster boundary specification has the following features:</p>
  <ul>
	<li>There is never a break within a sequence of nonspacing marks.</li>
	<li>There is never a break between a base character and subsequent 
	nonspacing marks. </li>
	</ul>
  <p>The specification also avoids certain problems by explicitly assigning the 
	Extend property value to certain characters, such as U+09BE (<span class="symbol">া</span>) 
  <span class="name">BENGALI VOWEL SIGN AA</span>, to deal with particular compositions.</p>
  <p>The other default boundary specifications never break within grapheme clusters, and 
	they always use 
  a consistent property value for each grapheme cluster as a whole.</p>
  <h3 class="section">6.2 <a name="Grapheme_Cluster_and_Format_Rules">Replacing Ignore Rules</a></h3>
  <p>An important rule for the default word and sentence specifications ignores 
	Extend and Format characters. The main purpose of this rule is to always 
	treat a grapheme cluster as a single character—that is, as if it were simply 
	the first character of the cluster. Both word and sentence specifications do 
	not distinguish between L, V, T, LV, and LVT: 
	thus it does not matter whether 
  there is a sequence of these or a single one. In addition, there is a specific 
  rule to disallow breaking within CRLF. Thus ignoring Extend is sufficient to disallow breaking 
  within a grapheme cluster. Format characters are also ignored by default, because these characters 
  are normally irrelevant to such boundaries.</p>
  <p>The “Ignore” rule is then equivalent to making the 
	following changes in the rules:</p>
  <table border="0" id="table4" class="nb" cellspacing="0" cellpadding="4" >
	<tr>
		<td class="nb" colspan="3">
		<p class="rule">Replace the “Ignore” rule by the following, to disallow 
	breaks within sequences (except after CRLF and related characters):</p></td>
	</tr>
	<tr>
		<th class="nb" style="text-align: right">Original</th>
		<th class="nb" style="text-align:center"><span class="transform">→</span></th>
		<th class="nb">Modified</th>
	</tr>
	<tr>
		<td class="nb" style="text-align: right">
		  X (Extend | Format)*→X</td>
		<td class="nb" style="text-align:center"><b><span class="transform">→</span></b></td>
		<td class="nb">(¬Sep) × <u>(Extend | Format)</u></td>
	</tr>
	<tr>
		<td class="nb" colspan="3">
		<p class="rule">In 
			<i>all</i> subsequent rules, insert (Extend | Format)* after every boundary property value, 
		except in negations (such as ¬(OLetter | Upper ...). (It is not 
	necessary to do this after the final property, on the right side of the break symbol.) For example:</td>
	</tr>
	<tr>
		<th class="nb" style="text-align: right">Original</th>
		<th class="nb" style="text-align:center"><span class="transform">→</span></th>
		<th class="nb">Modified</th>
	</tr>
	<tr>
		<td class="nb" style="text-align: right">X Y × Z W</td>
		<td class="nb" style="text-align:center"><b><span class="transform">→</span></b></td>
		<td class="nb">X 
		<u>(Extend | Format)*</u> 
        Y <u>(Extend | Format)*</u>
		× Z <u>(Extend | 
        Format)*</u> W</td>
	</tr>
	<tr>
		<td class="nb" style="text-align: right">X Y ×</td>
		<td class="nb"  style="text-align:center"><b><span class="transform">→</span></b></td>
		<td class="nb">X 
		<u>(Extend | Format)*</u> 
        Y <u>(Extend | Format)*</u> 
        	×</td>
	</tr>
	<tr>
		<td class="nb" colspan="3">
		<p class="rule">An alternate expression that resolves to a single 
		character is treated as a 
    whole. For example:</td>
	</tr>
		<tr>
			<th class="nb" style="text-align: right">Original</th>
			<th class="nb" style="text-align:center"><span class="transform">→</span></th>
			<th class="nb">Modified</th>
		</tr>
		<tr>
			<td class="nb">
			<p style="text-align: right">(STerm | ATerm)</td>
			<td class="nb" style="text-align:center"><b><span class="transform">→</span></b></td>
			<td class="nb">(STerm | ATerm)
			<u>(Extend | 
      Format)*</u></td>
		</tr>
		<tr>
			<td class="nb">
			<p style="text-align: right"><i><b>not</b></i></td>
			<td class="nb" style="text-align:center"><b><span class="transform">→</span></b></td>
			<td class="nb">(STerm <u>(Extend | Format)*</u> 
			| ATerm <u>(Extend | Format)*</u>)</td>
		</tr>
	</table>
  <p>The Ignore rules should not be overridden by tailorings, with the 
  possible exception of remapping some of the Format characters to other classes.</p>
  <h3 class="section">6.3 <a name="Regular_Expressions">Regular Expressions</a></h3>
  <p>The preceding rules can be converted into regular expressions that will produce the same results. 
  The regular expression must be evaluated starting at a known boundary (such as the start of the 
  text) and take the longest match (except in the case of sentence boundaries, where the shortest 
  match needs to be used).</p>
  <p>The conversion into a regular expression is 
	fairly straightforward for the grapheme cluster boundaries&nbsp; of <i>
	<a href="tr29-18.html#Default_Grapheme_Cluster_Table">
	Table 1</a> </i>. For example, they can be transformed into the following 
	regular expression: </p>
	<blockquote >
		<pre >( CR LF )
| ( Prepend*
    ( L+ | (L* ( ( V | LV ) V* | LVT ) T*) | T+ | [^ Control CR LF ] )
    ( Extend | SpacingMark )*
   )
| .</pre></blockquote>
	<p >Such a regular expression can also be turned 
	into a fast, deterministic finite-state machine. Similar regular expressions 
	are possible for Word boundaries. Line and Sentence boundaries are 
	more complicated, and more difficult to represent with regular expressions. 
	For more information on Unicode Regular Expressions, see Unicode Technical 
	Standard #18, “Unicode Regular Expressions” [<a href="../tr41/tr41-7.html#UTS18">UTS18</a>].</p>
  <h3 class="section"><a name="Random_Access">6.4 Random Access</a></h3>
  <p>Random access introduces a further complication. When iterating through a string from 
  beginning to end, a regular expression or state machine works well. From each boundary to find the 
  next boundary is very fast. By constructing a state table for the reverse direction from the same 
  specification of the rules, reverse iteration is possible.</p>
  <p>However, suppose that the user wants to iterate starting at a random point in the text, or 
  detect whether a random point in the text is a boundary. If the starting point does not provide 
  enough context to allow the correct set of rules to be applied, then one could fail to find a 
  valid boundary point. For example, suppose a user clicked after the first space after the question 
  mark in “Are_you_there? _ _ No,_I&#x2019;m_not”. On a forward iteration searching for a sentence 
  boundary, one would fail to find the boundary before the “N”, because the “?” had 
	not been seen 
  yet.</p>
  <p>A second set of rules to determine a “safe” starting point provides a solution. Iterate 
  backward with this second set of rules until a safe starting point is located, then iterate 
  forward from there. Iterate forward to find boundaries that were located between the safe point 
  and the starting point; discard these. The desired boundary is the first one that is not less than 
  the starting point. The safe rules must be designed so that they function correctly no matter what 
  the starting point is, so they have to be conservative in terms of finding boundaries, 
	and only find those boundaries that can be determined by a small context (a 
	few neighboring characters).</p>
  <p class="caption"><a name="Figure_Random_Access"></a>Figure 3. <span style="font-weight: 400">Random Access</span></p>
  <div class="web-only">
  <p align="center" style="text-align: center"><img src="images/random_access.jpg" alt="random access diagram"></p>
  </div><div class="book-only">
  <p align="center" style="text-align: center"><img src="print-images/random_access.jpg" alt="random acces diagram" width="181" height="109"></p>
  </div>
  <p>This process would represent a significant performance cost if it had to be performed on every 
  search. However, this functionality can be wrapped up in an iterator object, which preserves the 
  information regarding whether it currently is at a valid boundary point. Only if it is reset to an 
  arbitrary location in the text is this extra backup processing performed. The iterator may even 
  cache local values that it has already traversed.</p>
  <h3 class="section">6.5 <a name="Tailoring">Tailoring</a></h3>
  <p>Rule-based implementation can also be combined with a 
  code-based or table-based tailoring mechanism. For typical state machine 
  implementations, for example, a Unicode character is 
  typically passed to a mapping table that maps characters to boundary property values. This mapping 
  can use an efficient mechanism such as a trie. Once a boundary property value is produced, it 
  is passed to the state machine.</p>
  <p>The simplest customization is to adjust the values coming out of the character mapping 
  table. For example, to mark the appropriate quotation marks for a given language as having the 
  sentence boundary property value Close, artificial property values can be introduced for different 
  quotation marks. A table can be applied after the main mapping table to map those artificial 
  character property values to the real ones. To change languages, a different small table is 
  substituted. The only real cost is then an extra array lookup.</p>
  <p>For code-based tailoring a different special range of property values can be added. The state 
  machine is set up so that any special property value causes the state machine to halt and return 
  a particular exception value. When this exception value is detected, the higher-level process can 
  call specialized code according to whatever the exceptional value is. This can all be encapsulated 
  so that it is transparent to the caller.</p>
  <p>For example, Thai characters can be mapped to a special property value. When the state machine 
  halts for one of these values, then a Thai word break implementation
  is invoked internally, to produce boundaries within the subsequent string of Thai 
  characters. These boundaries can then be cached so that subsequent calls for next 
	or previous 
  boundaries merely return the cached values. Similarly Lao characters can be mapped to a different 
  special property value, causing a different implementation to be 
  invoked.</p>
  <h2 class="section">7 <a name="Testing">Testing</a></h2>
  <p>There is no requirement that Unicode-conformant implementations implement these default 
  boundaries. As with the other default specifications, implementations are also free to override 
  (tailor) the results to meet the requirements of different environments or particular languages. 
  For those who do implement the default boundaries as specified in this annex, and wish to check that that 
  their implementation matches that specification, three test files have been made available 
  in [<a href="../tr41/tr41-7.html#Tests29">Tests29</a>].</p>
  <p>These tests cannot be exhaustive, because of the large number of possible 
	combinations; but they do provide 
  samples that test all pairs of property values, using a representative character for each value, 
  plus certain other sequences.</p>
  <p>A sample HTML file is also available for each that shows various combinations in chart form, 
  in [<a href="../tr41/tr41-7.html#Charts29">Charts29</a>]. The header cells of the chart consist of a property 
  value, followed by a representative code point number. The body cells in the chart show the <i>
  break status</i>: whether a break occurs between the row property value and the column property 
  value. If the browser supports tool-tips, then hovering the mouse over the code point number will 
  show the character name, General_Category, Line_Break, and Script property values. Hovering over 
  the break status will display the number of the rule responsible for that status.</p>
  <blockquote>
    <p><span class="note">Note:</span><i> Testing two adjacent characters is 
	insufficient for determining a boundary, except for the case of the default grapheme clusters.</i></p>
  </blockquote>
  <p>The chart may be followed by some test cases. These test cases consist of various strings with 
  the break status between each pair of characters shown by blue lines for breaks and 
	by whitespace 
  for non-breaks. Hovering over each character (with tool-tips enabled) shows the character name and 
  property value; hovering over the break status shows the number of the rule responsible for that 
  status.</p>
	<p>Due to the way they have been mechanically processed for generation, the 
	test rules do not match the rules in this annex precisely. In particular:</p>
	<ol>
		<li>The rules are cast into a more regex-style.</li>
		<li>The rules “sot ÷”, “÷ eot”, and “÷ Any” are added mechanically and 
		have artificial numbers. </li>
		<li>The rules are given decimal numbers without prefix, so rules such as 
		WB13a are given 
		a number using tenths, such as 13.1.</li>
		<li>Where a rule has multiple parts (lines), each one is numbered using 
		hundredths, such as<ul>
			<li>21.01) × $BA</li>
			<li>21.02) × $HY</li>
			<li>...</li>
		</ul>
		</li>
		<li>Any “treat as” or “ignore” rules are handled as discussed in this annex, and thus 
		reflected in a transformation of the rules not visible in the tests.</li>
	</ol>
	<p>The mapping from the rule numbering in this annex to the numbering for 
	the test rules is 
	summarized in <i>Table 5.</i></p>	<div class="center"><center><p class="caption">
			<a name="#Table_Numbering_of_Rules"></a>Table 5.
	<span style="font-weight: 400">Numbering of Rules</span></p>    

	<table border="1" cellpadding="2" cellspacing="0" id="table5">
	<tr>
		<th>Rule in This Annex</th>
		<th>Test Rule</th>
		<th>Comment</th>
	</tr>
	<tr>
		<td align="right">xx1</td>
		<td align="right">0.1</td>
		<td>start of text</td>
	</tr>
	<tr>
		<td align="right">xx2</td>
		<td align="right">0.2</td>
		<td>end of text</td>
	</tr>
	<tr>
		<td align="right">SB8a</td>
		<td align="right">8.1</td>
		<td rowspan="3" style="vertical-align: middle">letter style</td>
	</tr>
	<tr>
		<td align="right">WB13a</td>
		<td align="right">13.1</td>
	</tr>
	<tr>
		<td align="right">WB13b</td>
		<td align="right">13.2</td>
	</tr>
	<tr>
		<td align="right">GB10</td>
		<td align="right" rowspan="2" style="vertical-align: middle">
		999</td>
		<td rowspan="2" style="vertical-align: middle">any&nbsp; </td>
	</tr>
	<tr>
		<td align="right">WB14</td>
	</tr>
	</table>
	</center></div><br>
    <h2 class="changed">8. <a name="Hangul_Syllable_Boundary_Determination"></a>Hangul Syllable Boundary Determination</h2>
    <p class="reviewnote">[Editorial Note: add links/anchors for tables and headers, number the subsections and include them in the TOC, and clean up formatting.]</p>
<p class="changed" >In rendering, a sequence of jamos is displayed as a series of syllable blocks. The following rules specify how to divide up an arbitrary sequence of jamos (including nonstandard sequences) into these syllable blocks. The symbols  L, V, T, LV, LVT represent the  corresponding Hangul_Syllable_Type property values; the symbol M for combining marks.</p> 
<p class="changed" >The precomposed Hangul syllables are of two types: LV or LVT. In determining the syllable boundaries, the LV behave as if they were a sequence of jamo L V, and the LVT behave as if they were a sequence of jamo L V T.</p>
<p class="changed" >Within any sequence of characters, a syllable break never occurs between the pairs of characters shown in<i> </i><a href="tr29-18.html#Hangul_Syllable_No_Break_Rules">Table 6</a>. In all cases other than those shown in <i>Table 6</i>, a syllable break occurs before and after any jamo or precomposed Hangul syllable. As for other characters, any combining mark between two conjoining jamos prevents the jamos from forming a syllable block.</p>
<p class="changed caption">Table 6. <a name="Hangul_Syllable_No_Break_Rules"></a>Hangul Syllable No-Break Rules</p> 
<table cellspacing="0" cellpadding="0" align="center"> 
  <tbody> 
    <tr> 
      <td colspan='2' valign="middle" class="changed">Do Not Break Between        </td> 
      <td valign="middle" class="changed">Examples</td> 
    </tr> 
    <tr> 
      <td valign="top" class="changed">L      </td> 
      <td valign="top" class="changed">L, V, or precomposed Hangul syllable      </td> 
      <td valign="top" class="changed">L × L<br>
          L × V<br>
          L × LV<br>
          L × LVT</td> 
    </tr> 
    <tr> 
      <td valign="top" class="changed">V or LV      </td> 
      <td valign="top" class="changed">V or T      </td> 
      <td valign="top" class="changed">V × V<br>
          V × T<br>
          LV × V<br>
          LV × T</td> 
    </tr> 
    <tr> 
      <td valign="top" class="changed">T or LVT      </td> 
      <td valign="top" class="changed">T      </td> 
      <td valign="top" class="changed">T × T<br>
          LVT × T</td> 
    </tr> 
    <tr> 
      <td valign="top" class="changed">Jamo or precomposed Hangul syllable      </td> 
      <td valign="top" class="changed">Combining marks      </td> 
      <td valign="top" class="changed">L × M<br>
          V × M<br>
          T × M<br>
          LV × M<br>
          LVT × M</td> 
    </tr> 
  </tbody> 
</table> 
<p class="changed" >Even in Normalization Form NFC, a syllable block may contain a precomposed Hangul syllable in the middle. An example is L LVT T. Each well-formed modern Hangul syllable, however, can be represented in the form L V T? (that is one L, one V and optionally one T) and consists of a single encoded character in NFC.</p> 
<p class="changed" >For information on the behavior of Hangul compatibility jamo in syllables, see <i>Section 12.6, Hangul</i> of [Unicode].</p> 
<h3 class="changed">Standard Korean Syllables</h3> 
<ul > 
  <li class="changed" ><i>Standard Korean syllable block:</i> A sequence of one or more L followed by a sequence of one or more V and a sequence of zero or more T, or any other sequence that is canonically equivalent.</li> 
</ul> 
<ul > 
  <li class="changed" >All precomposed Hangul syllables, which have the form LV or LVT, are standard Korean syllable blocks.</li> 
  <li class="changed" >Alternatively, a standard Korean syllable block may be expressed as a sequence of a choseong and a jungseong, optionally followed by a jongseong.</li> 
  <li class="changed" >A choseong filler may substitute for a missing leading consonant, and a jungseong filler may substitute for a missing vowel.</li> 
</ul> 
<p class="changed" >Using regular expression notation, a canonically decomposed standard Korean syllable block is of the following form:</p> 
<p align="center" class="changed" >L+ V+ T*</p> 
<p class="changed" >Arbitrary standard Korean syllable blocks have a somewhat more complex form because they include any canonically equivalent sequence, thus including precomposed Korean syllables. The regular expressions for them have the following form:</p> 
<p align="center" class="changed" >(L+ V+ T*) | (L* LV V* T*) | (L* LVT T*)</p> 
<p class="changed" >All standard Korean syllable blocks used in modern Korean are of the form &lt;L V T&gt; or &lt;L V&gt; and have equivalent, single-character precomposed forms. <span class="removed">Such syllables cover the requirements of modern Korean, but do not provide for syllables that are used in Old Korean.</span></p> 
<p class="removed" >Using canonically decomposed text may facilitate further processing such as searching and sorting when dealing with Old Korean data, because the text then consists only of sequences of jamos (L+ V+ T*), and not mixtures of precomposed Hangul syllables and jamos.</p>
<p class="changed" >Old Korean characters are represented by a series of combining Jamo. While the Unicode Standard allows for two L, V, or T characters as part of a syllable, KS X 1026-1 only allows single instances. Implementations that need to conform to KS X 1026-1 can tailor the default rules in <em>Section 3.1&nbsp; <a href="tr29-18.html#Default_Grapheme_Cluster_Table">Default Grapheme Cluster Boundary Specification</a></em> accordingly.</p> 
<h3 class="changed">Transforming into Standard Korean Syllables</h3> 
<p class="changed" >A sequence of jamos that do not all match the regular expression for a standard Korean syllable block can be transformed into a sequence of standard Korean syllable blocks by the correct insertion of choseong fillers (L<i><sub>f</sub></i> ) and jungseong fillers (V<i><sub>f</sub></i> ). This transformation of a string of text into standard Korean syllables is performed by determining the syllable breaks as explained in the earlier subsection "Hangul Syllable Boundaries," then inserting one or two fillers as necessary to transform each syllable into a standard Korean syllable. Thus</p> 
<p align="center" class="changed" >L [^V] → L V<i><sub>f</sub></i> [^V]</p> 
<p align="center" class="changed" >[^L] V → [^L] L<i><sub>f</sub></i> V</p> 
<p align="center" class="changed" >[^V] T → [^V] L<i><sub>f</sub></i> V<i><sub>f</sub></i> T</p> 
<p class="changed" >where [^X] indicates a character that is not X, or the absence of a character.</p> 
<p class="changed" ><i>Examples.</i></p> 
<p class="changed" >In<i> </i><a href="tr29-18.html#Korean_Syllable_Break_Examples">Table 7</a>, the first row shows syllable breaks in a standard sequence, the second row shows syllable breaks in a nonstandard sequence, and the third row shows how the sequence in the second row could be transformed into standard form by inserting fillers into each syllable. Syllable breaks are shown by <i>middle dots</i> "·".</p>
<p class='changed caption'><a name="Korean_Syllable_Break_Examples"></a>Table 7. Korean Syllable Break Examples</p> 
<table cellspacing="0" cellpadding="0" align='center'> 
  <tbody> 
    <tr> 
      <td valign="middle" class="changed">No.        </td> 
      <td valign="middle" class="changed">Sequence        </td> 
      <td valign="middle" class="changed"> 
        </td> 
      <td valign="middle" class="changed">Sequence with Syllable Breaks Marked        </td> 
    </tr> 
    <tr> 
      <td valign="top" class="changed">1      </td> 
      <td valign="top" class="changed">LVTLVLVLV<i><sub>f</sub></i>L<i><sub>f</sub></i>VL<i><sub>f</sub></i>V<i><sub>f</sub></i>T      </td> 
      <td valign="top" class="changed">→      </td> 
      <td valign="top" class="changed">LVT · LV · LV · LV<i><sub>f</sub></i> · L<i><sub>f</sub></i>V · L<i><sub>f</sub></i>V<i><sub>f</sub></i>T      </td> 
    </tr> 
    <tr> 
      <td valign="top" class="changed" >2      </td> 
      <td valign="top" class="changed">LLTTVVTTVVLLVV      </td> 
      <td valign="top" class="changed">→      </td> 
      <td valign="top" class="changed">LL · TT · VVTT · VV · LLVV      </td> 
    </tr> 
    <tr> 
      <td valign="top" class="changed">3      </td> 
      <td valign="top" class="changed">LLTTVVTTVVLLVV      </td> 
      <td valign="top" class="changed">→      </td> 
      <td valign="top" class="changed">LLV<i><sub>f</sub></i> · L<i><sub>f</sub></i>VfTT · L<i><sub>f</sub></i>VVTT · L<i><sub>f</sub></i>VV · LLVV      </td> 
    </tr> 
  </tbody> 
</table><br>
<h2 class="nonumber"><a name="Acknowledgments">Acknowledgments</a></h2>
  <p>Mark Davis is the author of the initial version and has added to and 
	maintained the text of this annex.</p>
	<p>Thanks to Julie Allen, Asmus Freytag, Ted Hopp, <span class="changed">Martin Hosken, </span>Andy Heninger, Michael Kaplan, Steve Tolkin, Ken Whistler, and Eric Mader 
  for their feedback on this annex, including earlier versions.</p>
  <h2 class="nonumber"><a name="References">References</a></h2>
    <p>For references for this annex, see Unicode Standard Annex #41, “<a href="../tr41/tr41-7.html">Common 
	References for Unicode Standard Annexes</a>.”</p>
  <h2 class="nonumber"><a name="Modifications">Modifications</a></h2>
	<!-- BOOK ONLY -->
	<div class="book-only">
	<p>For details of the change history, see the online copy of this annex at http://www.unicode.org/reports/tr29/.</p>
	</div>
  <!--START WEB ONLY></START-->
  <div class="web-only">
  <p>The following summarizes modifications from the previous versions of this 
	annex.</p>
	
      <h3 class="changed"><b>Revision 18.</b></h3>
		<ul class="changed">
			<li><strong>Draft 4</strong></li>
			<li>Changed Cn in <a href='tr29-18.html#Grapheme_Cluster_Break_Property_Values'>Table 2</a> to Cn&amp;DI</li>
			<li>Minor editing in 8 <a href="tr29-18.html#Hangul_Syllable_Boundary_Determination">Hangul Syllable Boundary Determination</a></li>
			<li><strong>Draft 3</strong></li>
			<li>Added Cs and Cn to Control in Table 2, so that they do not join with following Extend characters.</li>
			<li>Removed older statements about Old Korean, replacing them with descriptions of restrictions in KS X 1026-1, and emphasizing that Unicode text segmentation can be tailored for it.</li>
			<li>Added example for word-interior hyphens in the Iu Mien language (written with the Thai script).</li>
			<li>Clarified the relation of Grapheme_Cluster_Break to the Grapheme_Base and Grapheme_Extend properties.</li>
			<li>In Table 2 Grapheme_Cluster_Break Property Values, changed Prepend and SpacingMark class so for Thai, Lao and certain other SE Asian scripts,
			extended grapheme clusters behave like legacy grapheme clusters (except for handling of Thai SARA AM and Lao AM). In Table 1a. Sample Grapheme
			Clusters, adjusted examples and added more to illustrate the new behavior. Removed the language added in draft 2 that put legacy and extended
			grapheme clusters on the same level. Added language in the extended grapheme cluster definition indicating the difference in user expectation
			for grapheme clusters between Indic scripts and SE Asian scripts.</li>
			<li><strong> Draft 2</strong></li>
			<li>Made it clear that the lists of characters are illustrative; the normative values are in the data files.</li>
			<li>Puts extended and legacy GCBs on the same level</li>
			<li>Moves the discussion of Hangul Syllable segmentation from the core standard to a new section of this document.</li>
			<li><strong>Draft 1</strong></li>
            <li>Proposed update for Unicode 6.1.0.</li>
		</ul>

<h3><b>Revision 17.</b></h3>
		<ul>
			<li><b>Reissued</b> for Unicode 6.0.0.</li>
			<li>Added anchors to tables and figures that did not have them.</li>
			<li>Moved explicitly listed Thai/Lao characters from Grapheme_Cluster_Break:Extend to Grapheme_Cluster_Break:SpacingMark to preserve behavior of legacy Grapheme clusters.</li>
			<li>Added TAI VIET characters to Grapheme_Cluster_Break:Prepend</li>
			<li>Added Hangul characters to the description of Grapheme_Cluster_Break property values for L, V, and T. (These property values were in 5.2, but the descriptive text hadn't been updated to match.)</li>
			<li>Added notes on  tailoring grapheme clusters for  <em>sara am</em> and <em>sign am</em> for Thai/Lao, and for <em>aksaras</em>.</li>
		</ul>
		<p>Revision 16 being a proposed update, only changes between versions 15 and 13 are noted here.</p>
		
<h3><b>Revision 15.</b></h3>
		<ul>
			<li><strong>Reissued</strong> for Unicode 5.2.0</li>
			<li>Added characters that may be tailored to be in MidLetter.</li>
			<li>Added section 4.2 Name Validation</li>
			<li>Revised 6.3&nbsp;<a href="tr29-18.html#Regular_Expressions">Regular Expressions</a></li>
			<li>Added a pointer from 3.1&nbsp; 
			<a href="tr29-18.html#Default_Grapheme_Cluster_Table">Default Grapheme Cluster Boundary Specification</a></li>
			<li>Many small wording changes.</li>
			<li>Changed property of ZWSP to XX (Any) in 4.1&nbsp;
			<a href="tr29-18.html#Default_Word_Boundaries">Default Word Boundary Specification</a></li>
		</ul>
  <h3 style="font-weight: normal">Revision 14 being a proposed update, only changes between versions 15 and 
	13 are noted here.</h3>
			<h3>Revision 13.</h3>
  <ul>
 	<li>Updated for Unicode 5.1.0.</li>
	<li>Revised the contents of <a href="tr29-18.html#SContinue">SContinue</a>.</li>
	<li>Added <a href="tr29-18.html#Newline">Newline</a>, and rules <a href="tr29-18.html#WB3a">WB3a</a> and
	<a href="tr29-18.html#WB3b">WB3b</a>.</li>
	<li>Added <a href="tr29-18.html#Prepend">Prepend</a>, and rule <a href="tr29-18.html#GB9b">GB9b</a>.</li>
	<li>Note that the GraphemeBreakTest now tests  grapheme clusters, since those are more 
	inclusive.</li>
	<li>Major revision of the 3&nbsp;<a href="tr29-18.html#Grapheme_Cluster_Boundaries">Grapheme Cluster Boundaries</a>, 
	to reflect UTC decisions. Includes use of the name <i>extended grapheme 
	cluster</i>, and significant reordering and enhancement of the text.</li>
	<li>Added note on breaking between scripts in 4.1&nbsp; <a href="tr29-18.html#Default_Word_Boundaries">Default Word Boundary Specification</a>.</li>
	<li>Added note on modifier letters.</li>
	<li>Added note on SB9-11.</li>
	<li>Added SContinue (sentence-continue) to improve sentence segmentation.</li>
	<li>Added MidNumLet to improve word segmentation, by allowing certain 
	characters to &quot;bridge&quot; both numbers and alphabetic words.</li>
	<li>Added informative note on the use of space in numbers.</li>
	<li>Made changes to property values for Word/Sentence break.</li>
	<li>Added CR, LF, Extend, Control as needed under Word and Sentence boundaries. 
	This caused all rules containing Sep to be changed.</li>
	<li>Clarified use of &quot;Any&quot;.</li>
	<li>Updated MidLetter to include U+2018.</li>
	<li>Fixed items that were noted in proof for 5.0.0.</li>
  </ul>
	<p>Revision 12 being a proposed update, only changes between versions 13 and 
	11 are noted here.</p>
  <h3>Revision 11.</h3>
  <ul>
	<li>Removed NBSP from ALetter.</li>
	<li>Added note on problem with Sentence Break rules SB8 and SB11.</li>
    <li>Changed table format, minor edits.</li>
	<li>Cleaned up description of how to handle Ignore Rules</li>
	<li>Added more details on the test file formats (for the html files).</li>
	<li>Added note about identifiers and natural language.</li>
	<li>Added reference to LDML/CLDR.</li>
	<li>Modified GC treatment to 
    use the equivalent (but more straightforward) use of Extend* in Section 4,&nbsp;<i><a href="tr29-18.html#Word_Boundaries">Word 
    Boundaries</a></i>, and Section 5,&nbsp;<i><a href="tr29-18.html#Sentence_Boundaries">Sentence 
    Boundaries</a></i>. (This is equivalent because breaks are 
    not allowed within Hangul syllables by the other rules anyway.) Also unify the application of 
    Extend*&nbsp; and Format*. This combines two rules into one in each set of rules (former 3 and 4 
    in Word Boundaries, 4 and 5 in Sentence Boundaries).</li>
	<li>Clarified how to apply “ignore” rules in Section 6.2,&nbsp;<i><a href="tr29-18.html#Grapheme_Cluster_and_Format_Rules">Grapheme 
    Cluster and Format Rules</a></i>, and combined Extend and Format</li>
	<li>Added “Do not break within CRLF” to Section 4,&nbsp;<i><a href="tr29-18.html#Word_Boundaries">Word 
    Boundaries</a></i>, and Section 5,&nbsp;<i><a href="tr29-18.html#Sentence_Boundaries">Sentence Boundaries</a></i>.</li>
	<li>Added 8a in Section 5,&nbsp;<i><a href="tr29-18.html#Sentence_Boundaries">Sentence Boundaries</a></i>, 
    to address an edge condition and fix a typo in #10.</li>
	<li>Replaced “user character” by “user-perceived character”.</li>
	<li>Reformed ALetter in Section 4,&nbsp;<i><a href="tr29-18.html#Word_Boundaries">Word 
    Boundaries</a></i>, to depend on LineBreak. Fixed references within properties.</li>
	<li>Removed Rule 0 of Section 4,&nbsp;<i><a href="tr29-18.html#Word_Boundaries">Word 
    Boundaries</a>.</i></li>
	<li>Clarified discussion of NFD, spelling checkers, and cleaned up 
    language around “engines” and “state machines” versus “implementations”.</li>
  </ul>
	<p>Revision 10 being a proposed update, only changes between versions 11 and 
	9 are noted here.</p>
  <h3>Revision 9.</h3>
  <ul>
    <li>Reworded introduction slightly, moved last half of Notation into the introduction.</li>
    <li>Added line above each boundary property value table pointing to the data files for the 
    precise definition of the properties.</li>
    <li>Added note to clarify that grapheme clusters are not broken in word or sentence boundaries.</li>
    <li>Clarified examples in <i>“1. Single boundaries”.</i></li>
    <li>Added pointer to UTS #10</li>
    <li>Change the “and not” formulation for clarity.<ul>
      <li>“and not X = true”<span class="mathsym3">→</span> “and X = false”</li>
      <li>“and not X = Y”<span class="mathsym3">→</span> “and X
      <span class="mathsym2">≠</span> Y”</li>
    </ul>
    </li>
  </ul>
  <p><b>Revision 8.</b></p>
  <ul>
    <li>Modified the tables so as to make the property values orthogonal.</li>
    <li>Added Joiner/Non-Joiner.</li>
    <li>Added additional katakana characters.</li>
    <li>Removed MidNumLet, and added ExtendedNumLet (with corresponding changes to the rules).</li>
    <li>Moved the test files to the references.</li>
    <li>Fixed up the property file references.</li>
  </ul>
  <p><b>Revision 7.</b></p>
  <ul>
    <li>Incorporated corrigendum for Hangul_Syllable_Type=L explanation, and adjusted for the 
    change in status of the Joiner characters.</li>
    <li>Added override for CB, SA, SG, and XX in wordbreak.</li>
    <li>Added “Any” entries, and note about precedence.</li>
    <li>Added NBSP, and removed GRAPHEME EXTEND = true from the “alphabetics”.</li>
    <li>Added data files with explicit property values.</li>
  </ul>
  <h3>Revision 6.</h3>
  <ul>
    <li>Changed <a href="tr29-18.html#STerm">Term</a> to be the 4.0.1 UCD property STerm. Note: the new property 
    provides minor corrections as well.</li>
  </ul>
  <h3>Revision 4.</h3>
  <ul>
    <li>
    <p>Updated boilerplate.</li>
    <li>Use the Grapheme_Extend property. Dropped note on Other_Grapheme_Extend, 
    because those changes are in UCD 4.0.0</li>
    <li>Deleted note on relation to 3.0 text. Replace reference to 3.2 with one 
    to 4.0.</li>
    <li>Replaced the lists of Korean chars by reference to the 
    Hangul_Syllable_Type, with the lists kept as examples. Added reference to the UCD.</li>
    <li>Simplified ALetter and OLetter, because some characters are changing from 
    Sk to Lm, and thus get included; other Sk are not really candidates for words.</li>
    <li>Subtracted characters from certain classes so they wouldn&#x2019;t overlap:
    <ul>
      <li>CR and LF from Control in Grapheme Break</li>
      <li>Soft hyphen from MidLetter in Word Break (because it is Cf in 4.0)</li>
      <li>ATerm, Term and <span class="charlist"></span><span class="name">GERESH</span> from Close in 
      Sentence Break</li>
    </ul>
    </li>
    <li>Added note about finite-state machine; highlighted notes about adjacent 
    characters.</li>
    <li>Fixed the term “interior” (didn&#x2019;t match the rules); and some character 
    names.</li>
  </ul>
  <h3>Revision 3.</h3>
  <ul>
    <li>Removal of two open issues, resolved by UTC</li>
    <li>Changed name of “character class” to “property value” for consistency</li>
    <li>Other_Grapheme_Extend now includes characters for canonical closure</li>
    <li>Minor changes to some other property values</li>
    <li>Some additional notes on tailoring words for French, Italian, and Hebrew</li>
    <li>Added Section 7, <i><a href="tr29-18.html#Testing">Testing</a>.</i></li>
    <li>Minor editing.</li>
  </ul>
  <h3>Revision 2.</h3>
  <ul>
    <li>Simplified grapheme cluster.</li>
    <li>Handled format characters appropriately.</li>
    <li>Removed Hiragana × Hiragana from word break, as well as prefix/posfix for numbers (because 
    they should not block Whole-Word Search).</li>
    <li>Modified sentence break to catch edge conditions.</li>
    <li>Added conformance section, with more warnings throughout that these specifications need to 
    be tailored for different languages/orthographic conventions.</li>
    <li>Tightened up the specifications of the character classes.</li>
    <li>Clarified the rule process.</li>
    <li>Added explanations of the interaction with normalization.</li>
    <li>Added an implementation section (incorporating the previous Random Access section).</li>
  </ul>
  <hr width="50%">
  <p class="copyright">Copyright © 2000-201<span class="changed">1</span> Unicode, Inc. All Rights 
  Reserved. The Unicode Consortium makes no expressed or implied warranty of any kind, and assumes 
  no liability for errors or omissions. No liability is assumed for incidental and consequential 
  damages in connection with or arising out of the use of the information or programs contained or 
  accompanying this technical report. The Unicode <a href="http://www.unicode.org/copyright.html">
  Terms of Use</a> apply.</p>
  <p class="copyright">Unicode and the Unicode logo are trademarks of Unicode, Inc., and are 
  registered in some jurisdictions.</p>
  </div> <!-- WEB ONLY -->
 </div> <!-- BODY -->
</div> <!-- BOOK -->

</body>

</html>
