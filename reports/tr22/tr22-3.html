<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"   "http://www.w3.org/TR/REC-html40/loose.dtd"> 
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<link rel="stylesheet" href="../../unicode/reports/reports.css" type="text/css">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>UTR #22: Character Mapping Tables</title>
</head>

<body bgcolor="#ffffff">

<table class="header" width="100%">
  <tr>
    <td class="icon"><a href="http://www.unicode.org"><img align="middle" alt="[Unicode]" border="0" src="../../webscripts/logo60s2.gif" width="34" height="33"></a>&nbsp;&nbsp;<a class="bar" href="http://www.unicode.org/unicode/reports">Technical 
      Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>
</table>
<div class="body">
  <h2 align="center">Unicode Technical Report&nbsp;#22</h2>
  <h1 align="center">Character Mapping Markup Language</h1>
  <h2 align="center">(CharMapML)</h2>
  <table class="wide" border="1" width="100%">
    <tr>
      <td width="120">Version</td>
      <td>3</td>
    </tr>
    <tr>
      <td width="120">Authors</td>
      <td>Mark Davis (<a href="mailto:mark.davis@us.ibm.com">mark.davis@us.ibm.com</a>, 
        <a href="http://www.macchiato.com">home</a>)</td>
    </tr>
    <tr>
      <td width="120">Date</td>
      <td>2002-08-16</td>
    </tr>
    <tr>
      <td width="120">This Version</td>
      <td><a href="tr22-3.html">http://www.unicode.org/reports/tr22/tr22-3.html</a></td>
    </tr>
    <tr>
      <td width="120">Previous Version</td>
      <td><a href="http://www.unicode.org/unicode/tr22/tr22-2.2.html">http://www.unicode.org/reports/tr22/tr22-2.2.html</a></td>
    </tr>
    <tr>
      <td width="120">Latest Version</td>
      <td><a href="index.html">http://www.unicode.org/reports/tr22/</a></td>
    </tr>
  </table>
  <br>
  <h3><i>Summary</i></h3>
  <p><i><em>This document specifies an XML format for the interchange of mapping 
  data for character encodings, and describes some of the issues connected with 
  the use of character conversion. It provides a complete description for such 
  mappings in terms of a defined mapping to and from Unicode, and a description 
  of alias tables for the interchange of mapping table names.</em></i></p>
  <h3><i>Status</i></h3>
  <p><i>This document has been reviewed by Unicode members and other interested 
  parties, and has been approved by the Unicode Technical Committee as a <b>Unicode 
  Technical Report</b>. It is a stable document and may be used as reference 
  material or cited as a normative reference from another document.</i></p>
  <blockquote>
    <p><i>A <b>Unicode Technical Report</b> (UTR) may contain either informative 
    material or normative specifications, or both. Each UTR may specify a base 
    version of the Unicode Standard. In that case, conformance to the UTR 
    requires conformance to that version or higher.</i></p>
  </blockquote>
  <p><i>A list of current Unicode Technical Reports is found on [<a href="tr22-3.html#Reports">Reports</a>]. 
  For more information about versions of the Unicode Standard, see [<a href="tr22-3.html#Versions">Versions</a>]. 
  Please mail corrigenda and other comments to the author(s).</i> <i>The <a href="tr22-3.html#References">References</a> 
  provide related information that is useful in understanding this document.</i></p>
  <h3><em><strong>Contents</strong></em></h3>
  <ul>
    <li><a href="tr22-3.html#Introduction">1 Introduction</a>
      <ul>
        <li><a href="tr22-3.html#Illegal_and_Unassigned">1.1 Illegal and Unassigned Codes</a>
          <ul>
            <li><a href="tr22-3.html#Best-Fit_Mappings">1.1.1 Best-Fit Mappings</a></li>
            <li><a href="tr22-3.html#Dual_Substitution_Handling">1.1.2 Dual Substitution 
              Handling</a></li>
          </ul>
        </li>
        <li><a href="tr22-3.html#Completeness">1.2 Completeness</a></li>
        <li><a href="tr22-3.html#Canonical_Equivalence">1.3 Canonical Equivalence</a></li>
        <li><a href="tr22-3.html#Charset_Alias_Matching">1.4 Charset Alias Matching</a></li>
      </ul>
    </li>
    <li><a href="tr22-3.html#XML_Format">2 Character Mapping Table Format</a>
      <ul>
        <li><a href="tr22-3.html#Header">2.1 Header</a></li>
        <li><a href="tr22-3.html#History">2.2 History</a></li>
        <li><a href="tr22-3.html#Validity_Specification">2.3 Validity Specification</a>
          <ul>
            <li><a href="tr22-3.html#Simple_SI_SO-Stateful_Encodings">2.3.1 Simple SI/SO- 
              Stateful Encodings</a></li>
          </ul>
        </li>
        <li><a href="tr22-3.html#Assignments">2.4 Assignments</a></li>
        <li><a href="tr22-3.html#ISO_2022">2.5 ISO 2022</a></li>
      </ul>
    </li>
    <li><a href="tr22-3.html#Names">3 Alias Table Format</a></li>
    <li><a href="tr22-3.html#Samples">4 Samples</a>
      <ul>
        <li><a href="tr22-3.html#Full_Sample">4.1 Full Sample</a></li>
        <li><a href="tr22-3.html#UTF8_Sample">4.2 UTF-8 Sample</a>
          <ul>
            <li><a href="tr22-3.html#Partial_Validity_Checks">4.2.1 Partial Validity Checks</a></li>
            <li><a href="tr22-3.html#Full_Validity_Checks">4.2.2 Full Validity Checks</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="tr22-3.html#Data_Files">Data Files</a></li>
    <li><a href="tr22-3.html#References">References</a></li>
    <li><a href="tr22-3.html#Modifications">Modification History</a></li>
  </ul>
  <hr>
  <h2>1 <a name="Introduction">Introduction</a></h2>
  <p>The ability to seamlessly handle multiple character encodings is crucial in 
  today's world, where a server may need to handle many different client 
  character encodings covering many different markets. No matter how characters 
  are represented, servers need to be able to process them appropriately. 
  Unicode provides a common model and representation of characters for all the 
  languages of the world. Because of this, Unicode is being adopted by more and 
  more systems as the internal storage processing code. Rather than trying to 
  maintain data in literally hundreds of different encodings, a program can 
  translate the source data into Unicode on entry, process it as required, and 
  translate it into a target character set on request.</p>
  <p>Even where Unicode is not used as a process code, it is often used as a <i>pivot</i> 
  encoding. Data can be converted first to Unicode and then into the eventual 
  target encoding. This requires only a hundred tables, rather than ten 
  thousand.</p>
  <p>Whether or not Unicode is used, it is ever more vital to maintain the 
  consistency of data across conversions between different character encodings. 
  Because of the fluidity of data in a networked world, it is easy for it to be 
  converted from, say, CP930 on a Windows platform, sent to a UNIX server as 
  UTF-8, processed, and converted back to CP930 for representation on another 
  client machine. This requires implementations to have identical mappings for a 
  character encoding, no matter what platform they are working on. It also 
  requires them to use the <i>same</i> name for the same encoding, and <i>different</i> 
  names for different encodings. This is difficult to do unless there is a 
  standard specification for the mappings so that it can be precisely determined 
  what the encoding actually maps to.</p>
  <p>This technical report provides such a standard specification for the 
  interchange of mapping data for character encodings. By using this 
  specification, implementations can be assured of providing precisely the same 
  mappings as other implementations on different platforms.</p>
  <blockquote>
    <p align="left"><b>Note:</b> It is expected that future versions of this 
    specification will also include provisions for complex mappings such as 2022 
    and glyph-based mappings.</p>
  </blockquote>
  <h3>1.1 <a name="Illegal_and_Unassigned">Illegal and Unassigned Codes</a></h3>
  <p>Client software needs to distinguish the different types of mismatches that 
  can occur when converting data between different character encodings. These 
  fall into the following categories:</p>
  <ol>
    <li>The sequence is <i>illegal.</i> There are two variants of this.<br>
      First is where the sequence is <i>incomplete</i>. For example,
      <ul>
        <li>0xA3 is incomplete in CP950.
          <ul>
            <li>Unless followed by another byte of the right form, it is 
              illegal.</li>
          </ul>
        </li>
        <li>0xD800 is incomplete in Unicode.
          <ul>
            <li>Unless followed by another value of the right form, it is 
              illegal.</li>
          </ul>
        </li>
        <li>0xDC00 is incomplete in Unicode.
          <ul>
            <li>Unless preceded by another value of the right form, it is 
              illegal.</li>
          </ul>
        </li>
      </ul>
      The second variant is where the sequence is complete, but explicitly 
      illegal. For example,
      <ul>
        <li>0xFFFF is illegal in Unicode. This value can never occur in valid 
          Unicode text, and will never be assigned.</li>
      </ul>
    </li>
    <li>The source sequence represents a valid code point, but is <i>unassigned</i> 
      (aka <i>undefined</i>). This sequence may be given an assignment in some 
      future <i>(evolved)</i> version of the character encoding.<br>
      For example,
      <ul>
        <li>0xA3 0xBF is unassigned in CP950, as of 1999.</li>
        <li>0x0EDE is unassigned in Unicode, V3.0</li>
      </ul>
    </li>
    <li>The source sequence is assigned, but <i>unmappable:</i> there is no 
      corresponding code point in the target encoding to accurately represent 
      the source sequence.<br>
      For example,
      <ul>
        <li>The long dash is assigned in Unicode, but cannot be mapped to 
          ISO-8859-1.</li>
      </ul>
    </li>
  </ol>
  <p>In the case of illegal source sequences, a conversion routine will 
  typically provide the following options:</p>
  <ul>
    <li>stop (or throw an exception)
      <ul>
        <li>in particular, stopping is commonly used by higher level character 
          encoding schemes, such as ISO 2022 conversions, to know when to stop 
          converting into one encoding and pick another to convert to.</li>
        <li>in either case, the information as to length of the bad sequence 
          should be available and the conversion should be resumable (after the 
          caller handles the bad sequence).</li>
      </ul>
    </li>
    <li>skip the source sequence
      <ul>
        <li>while this is commonly an option, it can also hide corruption 
          problems in the source text.</li>
      </ul>
    </li>
    <li>map to a substitution character
      <ul>
        <li>such as the Unicode U+FFFD (�) REPLACEMENT CHARACTER.</li>
      </ul>
    </li>
  </ul>
  <blockquote>
    <b>Note: </b>There is an important difference between the case where a 
    sequence represents a real REPLACEMENT CHARACTER in a legacy encoding, as 
    opposed to just being unassigned, and thereby mapped to REPLACEMENT 
    CHARACTER (using an API substitution option).
    <p><b>Note: </b>An API may choose to signal an illegal sequence in a legacy 
    character set by mapping it to one of the explicit NOT A CHARACTER code 
    points in Unicode (any of the form xxFFFE or xxFFFF). However, this 
    mechanism runs the risk of these values being transmitted in Unicode text 
    (which is thus non-conformant), and should be used with caution.
  </blockquote>
  <p>Unassigned sequences can be handled with any of the above options, plus 
  some additional ones. They should always be treated as a single code point: 
  for example, 0xA3BF is treated as a single code point when mapping into 
  Unicode from CP950. Especially because unassigned characters may actually come 
  from a more recent version of the character encoding, it is often important to 
  preserve round-trip mappings if possible. This can be done with additional 
  options:</p>
  <ul>
    <li>map to private use space
      <ul>
        <li>Unicode (and some other character encodings) provides a large area 
          of Private Use characters. These can be used to provide round-trip 
          mappings for private use characters from other character encodings, as 
          well as provisional mappings for characters that have not yet been 
          encoded in Unicode.</li>
      </ul>
    </li>
    <li>represent by a hex escape sequence
      <ul>
        <li>for example, when mapping from U+1234 to other code pages, it can be 
          represented by &quot;&amp;#x1234;&quot; in XML or HTML, 
          &quot;\u1234&quot; in Java, C99 or C++, or &quot;\x{1234}&quot; in 
          Perl.</li>
      </ul>
    </li>
  </ul>
  <p>For unmappable sequences, all of the above options and one additional 
  option may be available:</p>
  <ul>
    <li>map to a fallback character sequence
      <ul>
        <li>In this case, an unmappable sequence is given a &quot;best fit&quot; 
          mapping. For example, an encoding might not have curly quotes; the 
          generic quotes could be used as a fallback; or if em dash is 
          unmappable, a sequence of two HYPHEN-MINUS characters could be used as 
          a fallback.</li>
      </ul>
    </li>
  </ul>
  <p>It is <i>very important</i> that systems be able to distinguish between the 
  fallback mappings and regular mappings. Systems like XML require the use of 
  hex escape sequences (NCRs) to preserve round-trip integrity; use of fallback 
  characters in that case corrupts the data.</p>
  <p>Because illegal values represent some corruption of the data stream, 
  conversion routines may be directed to handle them in a different way than by 
  replacement characters. For example, a routine might map unassigned characters 
  to a substitution character, but throw an exception on illegal values.</p>
  <h4>1.1.1 <a name="Best-Fit_Mappings">Best-Fit Mappings</a></h4>
  <p>There may be cases where a specified character mapping table is not 
  available. In such cases, a best-fit mapping table can be used. However, this 
  technique should be used with caution, since otherwise data can be corrupted. 
  For example, in XML there are different strategies depending on whether the 
  process is parsing or generating.</p>
  <blockquote>
    <p>Suppose that you have two sets X and SUB_X, where X is a superset of 
    SUB_X. (That is, every roundtrip mapping that is in SUB_X is also in X, and 
    X may contain additional round-trip mappings.) Then:</p>
    <ul>
      <li>It is ok to parse with X when the file is tagged as SUB_X. Since X is 
        a superset, all the characters will be read correctly. Any characters 
        that are not in SUB_X will be encoded as NCRs (e.g. &amp;#xABCD;), and 
        will work.</li>
      <li>It is ok to generate the file with SUB_X, and tag the file as X. As 
        long as you convert the characters that are not in SUB_X into NCRs, 
        everything works.</li>
      <li>What is NOT ok is to parse with SUB_X when the file is tagged with X 
        — characters will be corrupted.</li>
      <li>What is NOT ok is to generate the file with X, and tag the file with 
        SUB_X — characters will be corrupted.</li>
    </ul>
  </blockquote>
  <p>So looking up a best-fit character mapping needs to do two different 
  things, depending on whether a subset or a superset is required. The <a href="http://www.unicode.org/unicode/reports/tr22/tr22-2.2.html#Names">alias</a> 
  table describes data that can be used for this.</p>
  <h4>1.1.2 <a name="Dual_Substitution_Handling">Dual Substitution Handling</a></h4>
  <p>Some mapping tables for multibyte codepages define an additional, alternate 
  codepage substitution character &quot;subchar1&quot; which is always a 
  single-byte code. In this case, the regular substitution character is always a 
  double-byte code. These mapping tables then also list in the mapping section 
  which unassigned code points should map to this alternate subchar1 instead of 
  to the regular substitution character.</p>
  <p>The XML character mapping table format allows to specify the 
  &quot;subchar1&quot; byte sequence as a <code>sub1</code> attribute of the <code>assignments</code> 
  element, and to use <code>sub1</code> elements to specify which Unicode code 
  points should map to &quot;subchar1&quot; instead of to the regular 
  substitution character.</p>
  <p>Usage:</p>
  <p>In this context characters are thought of as being &quot;wide&quot; or 
  &quot;narrow&quot;. In legacy codepages, this is identified with the codes 
  being single-byte or double-byte codes.</p>
  <p>In mappings between two legacy codepages: When a wide (double-byte) 
  character is unassigned, it results in a double-byte substitution character. 
  When a narrow (single-byte) character is unassigned, it results in a 
  single-byte &quot;subchar1&quot;.</p>
  <p>This is emulated in Unicode↔codepage mapping tables by</p>
  <ul>
    <li>declaring the additional &quot;subchar1&quot;, and by</li>
    <li>adding one-way mappings from Unicode to the codepage-&quot;subchar1&quot; 
      where desired for &quot;narrow&quot; characters; also by</li>
    <li>using U+001a as a &quot;Unicode subchar1&quot;</li>
  </ul>
  <p>Typically, all unassigned Latin-1 characters (Unicode&lt;=U+00ff) have 
  subchar1 mappings, but also some other code points do.</p>
  <p>This means that</p>
  <ul>
    <li>when one converts from Unicode to such a codepage and finds an 
      unassigned code point, then
      <ul>
        <li>if a &quot;subchar1&quot; mapping is defined for this code point, 
          output the &quot;subchar1&quot; byte sequence</li>
        <li>otherwise output the regular substitution character</li>
      </ul>
    </li>
    <li>when one converts from such a codepage to Unicode and finds an 
      unassigned code, then
      <ul>
        <li>if the input sequence is of length 1 <em>and</em> a 
          &quot;subchar1&quot; is specified for the codepage, output U+001a</li>
        <li>otherwise output U+fffd</li>
      </ul>
    </li>
  </ul>
  <p>Some converter implementations seem to not distinguish between 
  roundtrip/fallback/subchar[1] and just have the desired default results in the 
  Unicode↔codepage runtime mapping tables.</p>
  <h3>1.2 <a name="Completeness">Completeness</a></h3>
  <p>It is important that a mapping file be a complete description. From the 
  data in the file, it must be possible to tell for any sequence of bytes 
  whether that sequence is assigned, unassigned, or illegal. It must also be 
  possible to tell if characters need to be rearranged to be in Unicode standard 
  order (visual order, combining marks after base forms, etc). In addition,</p>
  <ul>
    <li>All control values (C0 controls, DELETE, and C1 controls) must be 
      explicitly mapped.</li>
    <li>All legacy private use (e.g. user defined) characters must be explicitly 
      mapped, either to the private use zone in Unicode, or to the correct 
      characters outside of that zone.</li>
    <li>Only a real legacy replacement character can be mapped explicitly to 
      REPLACEMENT CHAR in the body of the mapping table; unassigned characters 
      must not be mapped <i>explicitly</i> to it. (They may be mapped implicitly 
      in conversion, depending on conversion parameters.)</li>
    <li>Similarly, when mapping back from Unicode, only the REPLACEMENT CHAR can 
      be mapped to SUBSTITUTE or other legacy equivalent.</li>
    <li>Incomplete sequences and other illegal sequences must be explicitly 
      indicated.</li>
    <li>All fallback mappings must be clearly indicated. This is especially 
      important for modern software that guarantees round-trip conversion to and 
      from Unicode.</li>
  </ul>
  <p>If two byte sequences are considered to be duplicate encodings, then they 
  can map to the same Unicode value (with one of them being a fallback).</p>
  <div align="center">
    <center>
    <table border="0" cellspacing="0" cellpadding="2">
      <tr>
        <th>Legacy</th>
        <th></th>
        <th>Unicode</th>
      </tr>
      <tr>
        <td align="center" valign="top"><font size="5">X</font></td>
        <td><img alt="?" border="0" src="NWSE-arrow.gif" width="117" height="47"></td>
        <td align="center" rowspan="2"><font size="5">X</font></td>
      </tr>
      <tr>
        <td align="center" valign="bottom"><font size="5">X'</font></td>
        <td><img alt="?" border="0" src="NE-arrow.gif" width="117" height="41"></td>
      </tr>
    </table>
    </center>
  </div>
  <p>If they are not, they must map to distinct Unicode values (e.g. using a PU 
  character). Otherwise they will get loss of data when converting to and from 
  Unicode.</p>
  <div align="center">
    <center>
    <table border="0" cellspacing="0" cellpadding="2">
      <tr>
        <th>Legacy</th>
        <th></th>
        <th>Unicode</th>
      </tr>
      <tr>
        <td align="center" valign="top"><font size="5">X</font></td>
        <td><img alt="?" border="0" src="EW-arrow.gif" width="124" height="32"></td>
        <td align="center"><font size="5">X</font></td>
      </tr>
      <tr>
        <td align="center" valign="bottom"><font size="5">X'</font></td>
        <td><img alt="?" border="0" src="EW-arrow.gif" width="124" height="32"></td>
        <td align="center"><font size="5">PUx'</font></td>
      </tr>
    </table>
    </center>
  </div>
  <p>If a future version of Unicode incorporates a character that was 
  represented by a PU character, the mapping should be changed as follows:</p>
  <h4>Old Version</h4>
  <div align="center">
    <center>
    <table border="0" cellspacing="0" cellpadding="2">
      <tr>
        <th>Legacy</th>
        <th></th>
        <th>Unicode</th>
      </tr>
      <tr>
        <td align="center"><font size="5">X'</font></td>
        <td><img alt="?" border="0" src="EW-arrow.gif" width="124" height="32"></td>
        <td align="center"><font size="5">PUx'</font></td>
      </tr>
    </table>
    </center>
  </div>
  <h4>New Version</h4>
  <div align="center">
    <center>
    <table border="0" cellspacing="0" cellpadding="2">
      <tr>
        <th>Legacy</th>
        <th></th>
        <th>Unicode</th>
      </tr>
      <tr>
        <td rowspan="2" align="center"><font size="5">X'</font></td>
        <td><img alt="?" border="0" src="NESW-arrow.gif" width="117" height="47"></td>
        <td valign="top" align="center"><font size="5">X'</font></td>
      </tr>
      <tr>
        <td><img alt="?" border="0" src="NW-arrow.gif" width="117" height="41"></td>
        <td valign="bottom" align="center"><font size="5">PUx'</font></td>
      </tr>
    </table>
    </center>
  </div>
  <p>&nbsp;</p>
  <h3>1.3 <a name="Canonical_Equivalence">Canonical Equivalence</a></h3>
  <p>The Unicode Standard has two equivalent ways of representing composite 
  characters such as <i>â</i>. The standard provides for two normalized formats 
  that provide for unique representations of data in <a href="http://www.unicode.org/unicode/reports/tr15/">UAX 
  #15: Unicode Normalization Forms</a> [<a href="tr22-3.html#BIDI">Normal</a>]. Where 
  possible, the code points mapped to should be in Normalization Form C. 
  However, this does not guarantee that the result of conversion into Unicode 
  will be normalized, since individual characters in the source encoding may 
  separately map to an unnormalized sequence.</p>
  <blockquote>
    <p>For example, suppose the source encoding maps 0x83 to U+030A in Unicode (<i>combining 
    ring above</i>), and 0x61 to U+0061 (<i>a</i>). Then the sequence 
    &lt;0x61,0x83&gt; will map to &lt;U+0061, U+030A&gt; in Unicode, which is 
    not in Normalization Form C.</p>
  </blockquote>
  <p>This problem will only arise when the source encoding has separate 
  characters that, in the proper context, would not be present in normalized 
  text. If a process wishes to guarantee that the result is in a particular 
  Unicode normalization form, then it should normalize after conversion. 
  Information is provided below that can determine whether this step is 
  required.</p>
  <h3>1.4 <a name="Charset_Alias_Matching">Charset Alias Matching</a></h3>
  <p>Names and aliases of charsets are often spelled with small variations. In 
  order to recognize accidental but unambiguous misspellings and to avoid adding 
  each possible variation to a list of recognized names, it is customary to 
  match names case-insensitively and to ignore some punctuation. For best 
  results, it is recommended to compare names after applying the following 
  transformations:</p>
  <ol>
    <li>Delete all characters except a-z, A-Z, and 0-9.</li>
    <li>Map uppercase A-Z to the corresponding lowercase a-z.</li>
    <li>From left to right, delete each 0 that is not preceded by a digit.</li>
  </ol>
  <p>For example, the following names should match: &quot;UTF-8&quot;, 
  &quot;utf8&quot;, &quot;u.t.f-008&quot;, but not &quot;utf-80&quot; or 
  &quot;ut8&quot;.</p>
  <h2>2 <a name="XML_Format">Character Mapping Table Format</a></h2>
  <p>A character mapping specification file starts with the following lines. 
  Note that there is a difference between the encoding of the XML file, and the 
  encoding of the mapping data. The encoding of the file can be any valid XML 
  encoding. Only the ASCII repertoire of characters is required in the 
  specification of the mapping data, but comments may be in other character 
  encodings. The example below happens to use UTF-8.</p>
  <pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;!DOCTYPE characterMapping

  SYSTEM &quot;http://www.unicode.org/unicode/reports/tr22/CharacterMapping.dtd&quot;&gt;</pre>
  <blockquote>
    <p><b>Note: </b>In the rest of this specification, very short attribute and 
    element names are used just to conserve space where there may be a large 
    number of items, or for consistency with other elements that may have a 
    large number of items.</p>
  </blockquote>
  <h3>2.1 <a name="Header">Header</a></h3>
  <p>A mapping file begins with a header. Here is an (artificial) example:</p>
  <pre>&lt;characterMapping
 id=&quot;windows-1252-2000&quot;
 version=&quot;2&quot;
 description=&quot;Sun variant of CP942 for Japanese&quot;
 contact=&quot;mailto:somebody@unicode.org&quot;
 registrationAuthority=&quot;Microsoft&quot;
 registrationName=&quot;cp666&quot;
 copyright=&quot;Microsoft&quot;
 bidiOrder=&quot;logical&quot;
 normalization=&quot;NFC&quot;
&gt;</pre>
  <p><b>characterMapping</b> (required) is the root. It contains a number of 
  attributes:</p>
  <p><b>id</b> (required) is a canonical id which uniquely identifies this 
  mapping table from all others. This id has the form: &lt;source&gt;-&lt;name_on_source&gt;-&lt;version&gt;, 
  such as &quot;iso-8859-1999&quot;.</p>
  <table border="1" width="100%">
    <tr>
      <td>&lt;source&gt;</td>
      <td>Name of standards authority, government, vendor, or product</td>
    </tr>
    <tr>
      <td>&lt;name_on_source&gt;</td>
      <td>Most common name used on source. If the name is used ambiguously on 
        the source, it should be qualified for uniqueness: e.g. 
        &quot;cp936_Alt1&quot;</td>
    </tr>
    <tr>
      <td>&lt;version&gt;</td>
      <td>Version number, typically the first year the encoding was introduced. 
        If this is not sufficient for uniqueness, an additional letter can be 
        appended: &quot;1999a&quot;, &quot;1999b&quot;, etc.</td>
    </tr>
  </table>
  <p>All three fields must be present, except in the case of Unicode encodings 
  themselves, which do not need a version field. Fields are limited to ASCII 
  letters, digits and &quot;_&quot;. Any other characters should be converted to 
  &quot;_&quot; or letters. The <b>id</b> value is matched leniently as 
  recommended for all charset names, see <a href="tr22-3.html#Charset_Alias_Matching">Section 
  1.4</a>. It must be unique; if two mapping tables differ in the mapping of any 
  characters, in the specification of illegal characters, in their bidi 
  ordering, in their combining character ordering, etc. then their ids must not 
  match according to the algorithm in <a href="tr22-3.html#Charset_Alias_Matching">Section 
  1.4</a>.</p>
  <blockquote>
    <p><b>Note: </b>The id syntax was chosen so that the resulting string can be 
    used as a filename on most systems.
    <p><b>Note: </b>If a source only has one id for two mappings that differ by 
    bidi-order, one must be given a qualification. E.g. &quot;cp543_RTL&quot; 
    (see below).</p>
    <p><b>Note: </b>These ids are <i>not</i> meant to compete with the <a href="http://www.isi.edu/in-notes/iana/assignments/character-sets">IANA 
    character set registry</a> [<a href="tr22-3.html#IANA">IANA</a>], which is the most 
    useful collection of cross-platform names available. We foresee registration 
    of many of these mappings in the future with IANA since, unfortunately, the 
    current usage of IANA names is not sufficiently precise. For example, very 
    many character set mappings advertise themselves as being 
    &quot;Shift-JIS&quot;, but actually have different mappings to and from 
    Unicode on different platforms.</p>
  </blockquote>
  <p>Some sources do not rename a character set when they add mappings: that is 
  provide mappings for characters that were previously unmapped, or were 
  previously mapped to private use characters. These added mappings can be 
  incorporated into the same mapping file, using a version attribute (see 
  below). If only additions are made, then the same id can be retained. However, 
  if mappings are changed in other ways (e.g. not pure additions), then a new id 
  <i>must</i> be used. Any change in the validity of character sequences also 
  requires a new id.</p>
  <p><b>version</b> (required) is the version of the data, a small integer 
  normally starting at one. Any time the data is modified, the value must be 
  increased.</p>
  <p><b>description</b> (optional) is a string which describes the mapping 
  enough to distinguish it from other similar mappings. This string must be 
  limited to the Unicode range U+0020 - U+007E and should be in English. The 
  string normally contains the set of mappings, the script, language, or locale 
  for which it is intended, and optionally the variation. For instance, 
  &quot;Windows Japanese JIS-1990&quot;, &quot;EBCDIC Latin 1 with Euro&quot;, 
  &quot;PC Greek&quot;.</p>
  <p><b>contact</b> (optional) is the person to contact in case errors are found 
  in the data. This must be a URL.</p>
  <p><b>registrationAuthority</b> (optional) is the organization responsible for 
  the encoding.</p>
  <p><b>registrationName</b> (optional) is a string that provides the name and 
  version of the mapping, as known to that authority.</p>
  <p><b>copyright</b> (optional) provides the copyright information. While this 
  can be provided in comments, use of a element allows copyright propagation 
  when converting to a binary form of the table. (Typically the right to use the 
  information is granted, but not the right to erase the copyright or pretend 
  that you created the information.)</p>
  <p><b>bidiOrder</b> (optional) specifies whether the character encoding is to 
  be interpreted in one of three orders: &quot;RTL&quot;, &quot;LTR&quot;, or 
  &quot;logical&quot;. Unicode text is always stored and processed in<i> logical 
  order</i> (basically keystroke order). Application of the Unicode 
  Bidirectional Algorithm is required to map to a visual-order character 
  encoding; application of a reverse bidirectional algorithm is required to map 
  back to Unicode. The default value for this attribute is &quot;logical&quot;. 
  It is only relevant for character encodings for the Middle East (Arabic and 
  Hebrew). For more information, see <a href="http://www.unicode.org/unicode/reports/tr9/">UAX 
  #9: The Bidirectional Algorithm</a> [<a href="tr22-3.html#BIDI">BIDI</a>]. If mapping 
  tables differ only in bidiOrder, this should be reflected in the &lt;name_from_source&gt;, 
  e.g. &quot;cp999&quot;, &quot;cp999_RTL&quot;, &quot;cp999_LTR&quot;.</p>
  <p><b>normalization</b> (optional) specifies whether the result of conversion 
  into Unicode using this mapping will be automatically in Normalization Form C 
  or D. The possible values are &quot;<b>undetermined</b>&quot; (the default), 
  &quot;<b>neither</b>&quot;, &quot;<b>NFC</b>&quot;, &quot;<b>NFD</b>&quot;, or 
  &quot;<b>NFC_NFD</b>&quot;. While this information can be derived from an 
  analysis of the assignment statements (see <a href="http://www.unicode.org/unicode/reports/tr15/">UAX 
  #15: Unicode Normalization Forms</a> [<a href="tr22-3.html#BIDI">Normal</a>]), providing 
  the information in the header is a useful validity check, and saves 
  processing. Most mappings specifications will have the value &quot;NFC&quot;. 
  Character encodings that contain neither composite characters nor combining 
  marks (such as 7-bit ASCII) will have the value &quot;NFC_NFD&quot;.</p>
  <h3>2.2 <a name="History">History</a></h3>
  <pre> &lt;history&gt;
  &lt;modified version=&quot;2&quot; date=&quot;1999-09-25&quot;&gt;
   Added Euro.
  &lt;/modified&gt;
  &lt;modified version=&quot;1&quot; date=&quot;1997-01-01&quot;&gt;
   Made out of whole cloth for illustration.
  &lt;/modified&gt;
 &lt;/history&gt;</pre>
  <p><b>history</b> (optional) provides information about the changes to the 
  file and relations to other encodings. This is an optional element.</p>
  <p><b>modified</b> provides information about the changes to the file, 
  coordinated with the version. The latest version should be first.</p>
  <h3>2.3 <a name="Validity_Specification">Validity Specification</a></h3>
  <p>As discussed above, it is important to be able to distinguish when 
  characters are unassigned vs. when they are invalid. Valid and invalid 
  sequences are specified by the <b>validity</b> element. Here is an example of 
  what this might look like, for the validity specification for Microsoft's SJIS 
  (&quot;windows-932-2000&quot;):</p>
  <pre>&lt;validity&gt;
  &lt;state type=&quot;FIRST&quot; next=&quot;VALID&quot; s=&quot;00&quot; e=&quot;80&quot; /&gt; 
  &lt;state type=&quot;FIRST&quot; next=&quot;VALID&quot; s=&quot;A0&quot; e=&quot;DF&quot; /&gt; 
  &lt;state type=&quot;FIRST&quot; next=&quot;VALID&quot; s=&quot;FD&quot; e=&quot;FF&quot; /&gt; 
  &lt;state type=&quot;FIRST&quot; next=&quot;LAST&quot; s=&quot;81&quot; e=&quot;9F&quot; /&gt; 
  &lt;state type=&quot;FIRST&quot; next=&quot;LAST&quot; s=&quot;E0&quot; e=&quot;FC&quot; /&gt; 
  &lt;state type=&quot;LAST&quot; next=&quot;VALID&quot; s=&quot;40&quot; e=&quot;7E&quot; /&gt; 
  &lt;state type=&quot;LAST&quot; next=&quot;VALID&quot; s=&quot;80&quot; e=&quot;FC&quot; max=&quot;FFFF&quot;/&gt; 
&lt;/validity&gt;</pre>
  <p>The subelements are <b>states</b>. Their attributes are:</p>
  <ul>
    <li><b>type </b>(required) the type of the given bytes. There is one 
      distinguished value for this attribute: <b>FIRST</b>. Other values can be 
      assigned, as long as they do not cause an error condition as listed below.</li>
    <li><b>s </b>(required) the start of the byte range.</li>
    <li><b>e </b>(optional) the end of the byte range.
      <ul>
        <li>A missing value is interpreted as being the same as the value for <b>s</b> 
          (thus is a range with one single value).</li>
      </ul>
    </li>
    <li><b>next </b>(required) the resulting type. There are three distinguished 
      values, listed below. Other values can be assigned, as long as they do not 
      cause an error condition.
      <ul>
        <li><b>VALID</b> indicates valid completion. This is the default.</li>
        <li><b>INVALID</b> indicates that the sequence is invalid.</li>
        <li><b>UNASSIGNED</b> indicates that the sequence is valid, but that 
          none of the matching byte sequences are assigned.</li>
      </ul>
    </li>
    <li><b>max</b> (optional) can only occur if the <b>next</b> value is <b>VALID</b>. 
      Its value greater or equal to the largest possible Unicode code point for 
      any matching byte sequence.</li>
  </ul>
  <p>For a pure definition of the mapping tables, neither <b>max</b> nor <b>UNASSIGNED</b> 
  are necessary. They could both be determined by analyzing the assignment 
  statements in the table. However, their inclusion allows implementations to 
  optimize their internal tables.</p>
  <p>All values referring to code units are hexadecimal. If we look at the above 
  table, the first three lines tell us that the single bytes 00-80, A0-DF, FD-FF 
  are illegal. The next two lines say that the bytes in the ranges 81-9F and 
  E0-FC are legal, <i>if</i> they are followed by a byte of <b>type=&quot;LAST&quot;</b>. 
  The next two lines show that the LAST byte must be in 40-7E, 80-FC More 
  detailed samples for a complex validity specification are given in <a href="tr22-3.html#Samples">Samples</a>.</p>
  <p>The validity specification is interpreted by setting the current state to <b>FIRST</b>, 
  and using the following process.</p>
  <ul>
    <li>Fetch a byte.</li>
    <li>From the current state and that byte, find the <b>next</b> value.</li>
    <li>If it is <b>VALID</b>, then the sequence is valid.</li>
    <li>If it is <b>INVALID</b> or there is no state, then the sequence is 
      invalid.</li>
    <li>Otherwise set the current state to the <b>next</b> value.</li>
  </ul>
  <p>The following is a sample of how this could be implemented in Java. It 
  would be very similar in C or C++ except that <code>type</code> would be an 
  output parameter and not an array, and the mask with <code>0xFF</code> is 
  unnecessary if byte is a typedef for <code>unsigned char</code>.</p>
  <table border="1" width="100%">
    <caption>Sample Validity Checking</caption>
    <tr>
      <td width="100%">
        <pre>/**
* Checks byte stream for validity
* @return number of valid bytes, and sets a flag.
* @param type VALID, INVALID, PARTIAL indicates invalid sequence.
* PARTIAL occurs at the end of a buffer, and indicates that a new buffer needs to be loaded.
* If there are no more bytes, it is equivalent to INVALID.
* @param length the number of bytes up to &lt;b&gt;and including&lt;/b&gt; the final byte
* that caused the problem.
*/



public int check(byte[] source, int position, int limit, byte[] type) {
  int p = position;
  byte state = FIRST;

  try {
    while (p &lt; limit) {  
      state = stateMap[state][source[p++] &amp; 0xFF]; // mask in Java
      if (state &lt; FIRST) { // VALID and INVALID are negative values 
        type[0] = state;
        return p-position;
      }
    }
  } catch (ArrayIndexOutOfBoundsException e) {} // fall through

  type[0] = (state &lt; FIRST) ? state : PARTIAL;
  return p - position;
}

static final byte FIRST = 0;</pre>
      </td>
    </tr>
  </table>
  <h4>Error Conditions</h4>
  <p>The following describes conditions under which a validity specification is 
  invalid.</p>
  <ul>
    <li>Two <b>state</b> elements conflict if they have the same <b>type</b> and 
      their byte ranges intersect.</li>
    <li>If a <b>type</b> attribute has the value <b>VALID</b>, <b>UNASSIGNED</b>, 
      or <b>INVALID</b>, then it conflicts.</li>
    <li>If there is a <b>type</b> value&nbsp; (other than <b>FIRST</b>) with no 
      matching <b>next</b> value in another element, the element is incomplete.</li>
    <li>If there is a <b>next</b> value (other than <b>VALID</b> or <b>UNASSIGNED</b>) 
      with no matching <b>type</b> value in another element, the element is 
      incomplete.</li>
    <li><i>If there are any conflicts or any incomplete elements, or if there is 
      not at least one valid byte sequence, the file is invalid.</i></li>
  </ul>
  <h4><a name="Simple_SI_SO-Stateful_Encodings">2.3.1 Simple SI/SO-Stateful 
  Encodings</a></h4>
  <p>EBCDIC-based multi-byte encodings use exactly two states and change between 
  them with SI and SO (Shift-In/Shift-Out) ISO control codes. There are a few 
  ASCII-based SI/SO encodings as well. (As it happens, the byte values for SI 
  and SO are the same in EBCDIC and ASCII.)</p>
  <p>Such stateful encodings are announced and tracked with a single CCSID (IBM 
  encoding ID) and are listed in the ICU Unicode conversion table repository [<a href="tr22-3.html#ConvRef">Conv</a>] 
  with one single mapping table that lists mappings for both states together. 
  The mappings are implicitly (and at runtime) distinguished by their numbers of 
  bytes per character: 1 in the initial state, and 2 in the other state. Note 
  that the double-byte lead byte ranges overlap a lot with the single-byte 
  codes.</p>
  <p>This are expressed in the XML character mapping tables by defining two 
  validity specifications, one for the single-byte state, and one for the 
  double-byte state. A <code>stateful_siso</code> element is used instead of the 
  normal <code>validity </code>element, and <code>stateful_siso</code> itself 
  contains two <code>validity</code> elements.</p>
  <p>In the assignment elements below, the mappings for the two states need not 
  be in any particular order.</p>
  <p>Example:</p>
  <pre>
  &lt;!-- EBCDIC Mixed SBCS/DBCS validity specification --&gt;
  &lt;stateful_siso&gt;
    &lt;!-- SBCS part --&gt;
    &lt;validity&gt;
      &lt;!-- all byte values are valid except for SI/SO, which are handled algorithmically --&gt;
      &lt;state type=&quot;FIRST&quot; next=&quot;VALID&quot; s=&quot;00&quot; e=&quot;0d&quot; /&gt;
      &lt;state type=&quot;FIRST&quot; next=&quot;VALID&quot; s=&quot;10&quot; e=&quot;ff&quot; /&gt;
    &lt;/validity&gt;

    &lt;!-- DBCS part --&gt;
    &lt;validity&gt;
      &lt;!-- DBCS space: 4040 --&gt;
      &lt;state type=&quot;FIRST&quot; next=&quot;SPACE_LAST&quot; s=&quot;40&quot; /&gt;
      &lt;state type=&quot;SPACE_LAST&quot; next=&quot;VALID&quot; s=&quot;40&quot; /&gt;

      &lt;!-- DBCS characters other than space: 4141..FEFE --&gt;
      &lt;state type=&quot;FIRST&quot; next=&quot;LAST&quot; s=&quot;41&quot; e=&quot;ff&quot; /&gt;
      &lt;state type=&quot;LAST&quot; next=&quot;VALID&quot; s=&quot;41&quot; e=&quot;ff&quot; /&gt;
    &lt;/validity&gt;
  &lt;/stateful_siso&gt;
</pre>
  <h3>2.4 <a name="Assignments">Assignments</a></h3>
  <p>The main part of the table provides the assignments of mappings between 
  byte sequences and Unicode characters. Here is an example:</p>
  <pre> &lt;assignments sub=&quot;FC FC&quot; sub1=&quot;1A&quot;&gt;

  &lt;!--Roundtrip mappings--&gt;
  &lt;a b=&quot;A1&quot; u=&quot;FF61&quot; c=&quot;｡&quot; /&gt;
  &lt;a b=&quot;A2&quot; u=&quot;FF62&quot; c=&quot;｢&quot; /&gt;
  &lt;a b=&quot;A3&quot; u=&quot;FF63&quot; c=&quot;｣&quot; /&gt;
  &lt;a b=&quot;A4&quot; u=&quot;E000&quot; /&gt;
  &lt;a b=&quot;A4&quot; u=&quot;FF64&quot; c=&quot;､&quot; v=&quot;source-someName-1995&quot;/&gt;
  &lt;a b=&quot;81 41&quot; u=&quot;3001&quot; c=&quot;、&quot; /&gt;
  &lt;a b=&quot;81 42&quot; u=&quot;3002&quot; c=&quot;。&quot; /&gt;
  &lt;a b=&quot;81 43&quot; u=&quot;FF0C&quot; c=&quot;，&quot; /&gt;
  &lt;a b=&quot;81 44&quot; u=&quot;FF0E FF03&quot; c=&quot;．&quot; /&gt; 

  &lt;!--Fallbacks--&gt;
  &lt;fub u=&quot;00A1&quot; b=&quot;21&quot; ru=&quot;0021&quot; c=&quot;¡&quot; rc=&quot;!&quot; /&gt;
  &lt;fub u=&quot;00A2&quot; b=&quot;81 91&quot; ru=&quot;FFE0&quot; c=&quot;¢&quot; rc=&quot;￠&quot; /&gt;
  &lt;fub u=&quot;00A3&quot; b=&quot;81 92&quot; ru=&quot;FFE1&quot; c=&quot;£&quot; rc=&quot;￡&quot; /&gt;
  &lt;fub u=&quot;00A5&quot; b=&quot;5C&quot; ru=&quot;005C&quot; c=&quot;¥&quot; rc=&quot;\&quot; /&gt;
  &lt;fub u=&quot;00A6&quot; b=&quot;7C&quot; ru=&quot;007C&quot; c=&quot;¦&quot; rc=&quot;|&quot; /&gt;
  &lt;fub u=&quot;00A9&quot; b=&quot;63&quot; ru=&quot;0063&quot; c=&quot;©&quot; rc=&quot;c&quot; /&gt;

  &lt;!--Reverse Fallbacks--&gt;
  &lt;fbu u=&quot;00A6&quot; b=&quot;EE FA&quot; /&gt;
  &lt;fbu u=&quot;2116&quot; b=&quot;87 82&quot; /&gt;

  &lt;!--Unassigned code points using the sub1 code for substitution--&gt;
  &lt;sub1 u=&quot;FFA0&quot; c=&quot;ﾠ&quot; /&gt;
  &lt;sub1 u=&quot;FFA1&quot; /&gt;

  &lt;!--Ranges--&gt;
  &lt;range bFirst=&quot;90 30 81 30&quot; bLast=&quot;E3 32 9A 35&quot;
    uFirst=&quot;10000&quot; uLast=&quot;10ffff&quot;
    bMin=&quot;90 30 81 30&quot; bMax=&quot;E3 39 FE 39&quot;/&gt;

 &lt;/assignments&gt;</pre>
  <p><b>assignments</b> contains a list of any number of <b>a</b>, <b>fub</b>, <b>fbu</b>, 
  <b>sub1</b>, or <b>range</b> elements. It has two optional attributes: <b>sub</b>, 
  which specifies the replacement character used in the legacy character 
  encoding (U+FFFD REPLACEMENT CHARACTER is used in Unicode.); and <b>sub1</b>, 
  which is IBM-specific and specifies a single-byte replacement character (only 
  for MBCS encodings with a multi-byte <b>sub</b> value).</p>
  <p>The <b>sub</b> value is a sequence of bytes, as described under <b>b</b> 
  below. The default is the ASCII control value SUB = <b>&quot;1A&quot;</b>.</p>
  <p>The <b>sub1</b> value is one byte; if it is missing, then the encoding uses 
  only one replacement character (the character specified with <b>sub</b>) for 
  all code points. In addition, if <b>sub1</b> is specified, then in conversions 
  <i>to </i>Unicode the &quot;narrow&quot; replacement character U+001A is to be 
  used for single-byte encoding codes (when a substitution is necessary) instead 
  of U+FFFD.</p>
  <b>a</b> specifies a mapping from byte sequences to Unicode and back. It has 
  the following attributes:<b></b>
  <ul>
    <li><b>b</b> (required) is a sequence of bytes. Always 2 hex digits, 
      unsigned. Multiple values are separated by spaces.</li>
    <li><b>u</b> (required) is a sequence of Unicode code points. One or more 
      hex digits, unsigned. Multiple values must be separated by spaces. Where 
      possible, this should be in Normalization Form C.</li>
    <li><b>v</b> (optional) is the version. This is a year, followed optionally 
      by a letter. The default value is <b>zero</b>. This allows the same 
      mapping file to be used over time when assignments are added. See <a href="tr22-3.html#Header">2.1 
      Header</a>.
      <ul>
        <li>If someone requests a mapping table of a certain version, such as 
          &quot;source-myname-1999b&quot;, then any table with a later version 
          can be used, such as &quot;source-myname-2000&quot;. All the 
          assignment elements in the later file that have a version that is 
          lexically less than or equal to the requested version are used.</li>
        <li>If there are any such assignment elements that would conflict except 
          for version, then the lexically larger version is chosen.</li>
      </ul>
    </li>
    <li><b>c</b> (optional) provides the actual character expressed in <b>u</b>. 
      This information is redundant, but provides readability.</li>
  </ul>
  <p>The element <b>fub</b> specifies a fallback mapping from Unicode to bytes, 
  to be used if an API requests a &quot;best effort&quot;. It has the same 
  attributes as <b>a</b>, plus two additional optional attributes. These are 
  provided for readability, and are not required.</p>
  <ul>
    <li><b>ru </b>(optional) indicates the roundtrip mapping: if you were to map 
      from Unicode to bytes and back.</li>
    <li><b>rc </b>(optional) indicates the actual character value of the 
      roundtrip mapping.</li>
  </ul>
  <blockquote>
    <p><b>Note: c</b>, <b>ru</b>, and <b>rc</b> could have been XML comments. 
    They are formatted better for display by typical browsers if they are 
    elements. Their contents is not checked for validity, and they are <b>not</b> 
    to be used in generating internal mapping tables.</p>
  </blockquote>
  <p>The element <b>fbu</b> specifies a fallback mapping from bytes to Unicode, 
  to be used if an API requests a &quot;best effort&quot;. Normally this element 
  is not required (or desired): byte sequences with no Unicode equivalent should 
  be assigned to private use characters (E000..F8FF, E0000..EFFFD, 
  100000..10FFFD). See <a href="tr22-3.html#Completeness">Completeness</a>. This element 
  has the same attributes as <b>a</b>, except that it excludes the attribute <b>c.</b></p>
  <p>The element <b>sub1</b> specifies a Unicode code point that is unassigned (unmappable 
  to the encoding) and maps to the &quot;narrow&quot; <b>sub1</b> replacement 
  character instead of the (default) &quot;wide&quot; <b>sub</b> replacement 
  character. This element has only the two attributes <b>u</b> (required) and <b>c</b> 
  (optional).</p>
  <p>The element <b>range</b> specifies that a range of byte sequences and 
  unicode values map together. It is simply a way to abbreviate a list of <b>a</b> 
  elements. The attributes are <b>bFirst</b>, <b>bLast</b>, <b>uFirst</b>, <b>uLast</b>, 
  <b>bMin</b>, <b>bMax</b> and <b>v</b>. The range of Unicode code points varies 
  continuously from <b>uFirst </b>to <b>uLast</b>. For enumerating the byte 
  sequences, the values are incremented from <b>bFirst</b> to <b>bLast</b> in 
  lexical order. That is: the last byte is incremented. If the byte value 
  exceeds the corresponding byte in <b>bMax</b>, it is reset to the 
  corresponding byte in <b>bMin</b>, and the previous byte in the sequence is 
  incremented. This process is repeated for each of the bytes from <b>bFirst</b> 
  to <b>bLast</b>. The <b>v</b> attribute is interpreted the same as in <b>a</b>.</p>
  <h4>Error Conditions</h4>
  <ul>
    <li>All byte sequences must be valid according to the validity 
      specification. <i>Otherwise the file is invalid.</i>
      <ul>
        <li>If the byte sequence is <b>UNASSIGNED</b> in the validity 
          specification, it is invalid.</li>
      </ul>
    </li>
    <li>All Unicode sequences must be valid Unicode code points between U+0000 
      and U+10FFFF. <i>Otherwise the file is invalid.</i>
      <ul>
        <li>If a code point exceeds the <b>max</b> value in the validity 
          specification associated with the byte sequence in that assignment 
          statement, it is invalid.</li>
        <li>If <b>normalization</b> is specified in the header to be &quot;<b>NFC</b>&quot;, 
          &quot;<b>NFD</b>&quot;, or &quot;<b>NFC_NFD</b>&quot;, then the code 
          point must be valid in the respective normalization form.</li>
        <li>Sequences cannot map to code points that are unassigned in the 
          latest version of the Unicode Standard.
          <ul>
            <li>If there are valid characters in the legacy encoding that are 
              not in Unicode yet, they must be mapped to private use characters 
              if they are mapped: (E000..F8FF, E0000..EFFFD, 100000..10FFFD).</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A <b>range</b> is treated as if it were expanded to a list of <b>a</b> 
      elements in terms of assessing the validity of the mapping table. In 
      addition, the element is invalid if:
      <ul>
        <li><b>bFirst</b>, <b>bLast</b>, <b>bMin</b>, <b>bMax </b>do not all 
          have the same number of bytes.</li>
        <li>Each byte in <b>bFirst</b>, <b>bLast</b> is not between the 
          corresponding bytes in <b>bMin</b>, <b>bMax.</b></li>
        <li><b>bLast</b> does not match the final byte sequence reached in the 
          process of generating the <b>a</b> elements.</li>
      </ul>
    </li>
    <li>The sub1 attribute of assignments must be exactly one byte if specified. 
      <i>Otherwise the file is invalid.</i></li>
    <li>A <b>sub1</b> element must not be used without specifying the <b>sub1</b> 
      attribute of <b>assignments</b>. <i>Otherwise the file is invalid.</i></li>
    <li>For the purpose of validity (and selecting versions) an <b>a</b> element 
      is treated as if it expanded into an <b>fub</b> element and an <b>fbu</b> 
      element.</li>
    <li>An <b>fub</b> or <b>sub1</b> element conflicts with any other <b>fub</b> 
      or <b>sub1</b> element that has the same Unicode sequence and the same 
      version.</li>
    <li>An <b>fbu</b> element conflicts with any other <b>fbu</b> element that 
      has the same byte sequence and the same version.</li>
    <li><i>In the case of conflicts, the file is invalid.</i></li>
  </ul>
  <h3>2.5 <a name="ISO_2022">ISO 2022</a></h3>
  <p>Country- or vendor-specific ISO 2022 encodings are used frequently on the 
  Internet. They each use a subset of the ISO 2022 framework and allow only few 
  embedded encodings. The &quot;very stateful&quot; nature of an ISO 2022 
  encoding makes it infeasible to describe it fully with one single XML file.</p>
  <p>Instead, the XML character mapping table format provides for a kind of 
  table of contents for an ISO 2022 encoding as an alternative to the usual 
  validity specification(s) and assignments. It allows the identification of the 
  invocation sequences and state shifts that are associated with each particular 
  mapping table (identified by its canonical names). It does not fully specify 
  all of the elements and semantics of the particular ISO 2022 subset.</p>
  <p><i>Terminology:</i></p>
  <blockquote>
    <p>An <i>escape sequence</i> announces an embedded encoding and cause an 
    immediate change to that encoding.</p>
    <p>A <i>designator sequence</i> announces an embedded encoding but does not 
    cause and immediate change to that encoding. Instead, such a change is later 
    invoked with a permanent Shift-In or Shift-Out (SI/SO) control code, or with 
    a one-time Single-Shift 2 or 3 (SS2/SS3).</p>
  </blockquote>
  <p>In the XML format, designator sequences are listed under the codes that 
  shift to them. The details of how designator sequences interact with shift 
  codes are not specified in the XML format. The initial state is generally 
  US-ASCII. Otherwise, it must be specified with a <code>default2022</code> 
  element.</p>
  <p><i>Example:</i></p>
  <p>This example shows all the features of ISO-2022 specifications; it is not a 
  real-world encoding.</p>
  <pre>  &lt;!--
    ISO 2022 encoding:
    Specifying names of mapping tables of embedded encodings,
    and escape and designator sequences
  --&gt;
  &lt;iso2022&gt;
    &lt;!-- Default single-byte encoding (US-ASCII is implied) --&gt;
    &lt;default2022 name=&quot;jis-x_201&quot;/&gt;

    &lt;!-- Escape sequences switch directly to the specified encoding --&gt;
    &lt;escape sequence=&quot;1B 28 4A&quot; name=&quot;jis-roman&quot;/&gt;

    &lt;!-- Designator sequences specify which encoding to switch to when the shift code occurs --&gt;
    &lt;so&gt;
      &lt;designator sequence=&quot;1B 24 29 41&quot; name=&quot;gb-2312_80-1980&quot;/&gt;
      &lt;designator sequence=&quot;1B 24 29 47&quot; name=&quot;cns-11643_2-1992&quot;/&gt;
      &lt;designator sequence=&quot;1B 24 29 45&quot; name=&quot;iso-ir_165-1992&quot;/&gt;
    &lt;/so&gt;

    &lt;ss2&gt;
      &lt;designator sequence=&quot;1B 24 2A 48&quot; name=&quot;cns-11643_2-1992&quot;/&gt;
    &lt;/ss2&gt;

    &lt;ss3&gt;
      &lt;designator sequence=&quot;1B 24 2B 49&quot; name=&quot;cns-11643_3-1992&quot;/&gt;
      &lt;designator sequence=&quot;1B 24 2B 4a&quot; name=&quot;cns-11643_4-1992&quot;/&gt;
    &lt;/ss3&gt;
  &lt;/iso2022&gt;
</pre>
  <h2>3 <a name="Names">Alias Table Format</a></h2>
  <p>A mapping alias table is a separate XML file that provides information 
  associated with multiple character mapping tables. For each character mapping 
  table, it provides display names (suitable to display to end-users), aliases, 
  and best-fit mappings.</p>
  <p><b>characterMappingAliases</b> (required) is the root. It contains any 
  number of <b>mapping</b> elements.</p>
  <p><b>mapping</b> (optional) marks an element that contains any number of <b>display</b>, 
  <b>alias</b>, and <b>bestFit</b> elements. It has one required attribute, <b>id</b>. 
  This provides the mapping table id in the canonical format, e.g. 
  &quot;us-ascii-1968&quot;.<br>
  <br>
  <b>display</b> (optional) provides names in different languages, suitable for 
  user menus. It has two required attributes, the <b>language</b> (xml:lang) and 
  the <b>name</b> in that language.</p>
  <pre>&lt;display name=&quot;Western Europe (Latin-1, 8859-1)&quot; xml:lang=&quot;en&quot;/&gt;</pre>
  <p><b>alias </b>(optional) provides common aliases for the canonical names. It 
  has one required attribute, which is <b>name</b>. This provides the alias 
  name, which should be spelled as specified by a standard or publication, if 
  applicable. Charset names and aliases should be matched according to <a href="tr22-3.html#Charset_Alias_Matching">Section 
  1.4</a>. The <b>preferredBy</b> attribute is optional. It is a space-delimited 
  list of environments where that particular alias is used: e.g. preferredBy=&quot;IANA 
  IBM&quot;. If two different aliases for the same mapping both have the same 
  environment in their preferredBy attributes, then the first listed one is the 
  preferred output alias for that environment. If an alias would have two 
  conflicting preferredBy attributes (in order to get the preferred output 
  aliases correct), it is expressed as two different alias elements.</p>
  <pre>&lt;alias name=&quot;iso-8859-1&quot; preferredBy=&quot;MIME&quot;/&gt;</pre>
  <p>Note that because aliases reflect current practice, the same alias may be 
  applied to different mappings.<br>
  <br>
  <b>bestFit</b> (optional) indicate an best-fit mapping <b>(B)</b> to use if 
  the specified <b>mapping</b> (<b>A)</b> is not installed. It has three 
  required attributes:</p>
  <ul>
    <li><b>id</b> is the canonical id of the bestFit mapping <b>(B)</b></li>
    <li><b>matchingA</b> is the percentage of identical round-trip mappings out 
      of A [i.e. count(A∩B)/count(A)]</li>
    <li><b>matchingB</b> is the percentage of identical round-trip mappings out 
      of B [i.e. count(A∩B)/count(B)].</li>
  </ul>
  <p align="center"><img alt="?" border="0" src="charsetOverlap.gif" width="454" height="269"></p>
  <p>For example, suppose we have the above situation. Mapping A has 876 
  roundtrip mappings. Mapping B has 5,432 roundtrip mappings. Of these, 765 are 
  identical. Then the resulting values would be:</p>
  <pre>&lt;bestFit id=&quot;...&quot; matchingA=&quot;87.3%&quot; matchingB=&quot;14.08%&quot;/&gt;</pre>
  <p>Each percentage must be specified to sufficient accuracy such that when 
  multiplied and rounded, the result precisely represents the number of common 
  elements count(A∩B). Thus &quot;14%&quot; and &quot;14.1%&quot; are both 
  insufficiently accurate (e.g. 5432 x 0.141 = 765.912, which rounds to the 
  incorrect value 766), while &quot;14.08%&quot; is sufficiently accurate (5432 
  x 0.1408 = 764.8256, which rounds to the correct value 765).</p>
  <h4>Example</h4>
  <p>Here is a example of a mapping element.</p>
  <pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE characterMappingAliases
  SYSTEM &quot;http://www.unicode.org/unicode/reports/tr22/CharacterMappingAliases.dtd&quot;&gt;

&lt;characterMappingAliases&gt;
 &lt;mapping id=&quot;us-ascii-1968&quot;&gt;
  &lt;display xml:lang=&quot;en&quot; name=&quot;US (ASCII)&quot;/&gt;
  &lt;alias name=&quot;us-ascii&quot; preferred=&quot;MIME&quot;/&gt;
  &lt;alias name=&quot;ansi_x3.4-1968&quot;/&gt;
  &lt;alias name=&quot;iso-ir-6&quot;/&gt;
  &lt;alias name=&quot;ansi_x3.4-1&quot;/&gt;
  &lt;alias name=&quot;iso_646.irv:1991&quot;/&gt;
  &lt;alias name=&quot;ascii&quot;/&gt;
  &lt;alias name=&quot;iso646-us&quot;/&gt;
  &lt;alias name=&quot;us&quot;/&gt;
  &lt;alias name=&quot;ibm367&quot;/&gt;
  &lt;alias name=&quot;cp367&quot;/&gt;
  &lt;alias name=&quot;csASCII&quot;/&gt;
  &lt;bestFit id=&quot;...&quot; matchingA=&quot;87.3%&quot; matchingB=&quot;14.08%&quot;/&gt;
 &lt;/mapping&gt;

&lt;/characterMappingAliases&gt;</pre>
  <h2>4 <a name="Samples">Samples</a></h2>
  <p>The following provide samples that illustrate features of the format.</p>
  <h3>4.1 <a name="Full_Sample">Full Sample</a></h3>
  <p>The samples used above, plus DTDs are found in <a href="tr22-3.html#Data_Files">Data 
  Files</a>. A sample of mapping tables constructed programmatically is provided 
  in the <a href="http://oss.software.ibm.com/icu/charset">ICU Conversion Table 
  Repository</a> [<a href="tr22-3.html#ConvRef">Conv</a>] You can view it directly with 
  Internet Explorer, which will interpret the XML.</p>
  <h3>4.2 <a name="UTF8_Sample">UTF-8 Sample</a></h3>
  <p>Here is a simple version of the UTF-8 validity specification, with the 
  shortest-form bounds checking and exact limit bounds checking omitted. While 
  in practice a mapping file is never required for UTF-8 since it is 
  algorithmically derived, it is instructive to see the use of the validity 
  element as a complicated example. As a reminder, the valid UTF-8 sequences are 
  listed in <a href="http://www.unicode.org/unicode/reports/tr28/#3_1_conformance">UAX 
  #28: Unicode 3.2</a>, <i>Table 3.1B. Legal UTF-8 Byte Sequences</i>.</p>
  <h4>4.2.1 <a name="Partial_Validity_Checks">Partial Validity Checks</a></h4>
  <p>Here is a simple version of the UTF-8 validity specification, with the 
  shortest-form bounds checking, surrogates, and exact limit bounds checking 
  omitted. This specification only checks the bounds for the first byte, and 
  that there are the appropriate number (0, 1, 2, or 3) of following bytes in 
  the right ranges. The single byte form does not need to be explicitly set; it 
  is simply any single byte that neither is illegal nor requires additional 
  bytes.</p>
  <pre>&lt;validity&gt;
 &lt;!--Validity specification for UTF-8, partial boundary checks--&gt;
 &lt;state type=&quot;FIRST&quot; next=&quot;VALID&quot; s=&quot;00&quot; e = &quot;7F&quot;/&gt;

 &lt;!-- 2 byte form --&gt;
 &lt;legal type=&quot;FIRST&quot; s=&quot;C0&quot; e=&quot;DF&quot; next=&quot;final&quot; /&gt;
 &lt;legal type=&quot;final&quot; s=&quot;80&quot; e=&quot;BF&quot; /&gt;

 &lt;!-- 3 byte form --&gt;
 &lt;legal type=&quot;FIRST&quot; s=&quot;DF&quot; e=&quot;EF&quot; next=&quot;prefinal&quot; /&gt;
 &lt;legal type=&quot;prefinal&quot; s=&quot;80&quot; e=&quot;BF&quot; next=&quot;final&quot; /&gt; 

 &lt;!-- 4 byte form --&gt;
 &lt;legal type=&quot;FIRST&quot; s=&quot;F0&quot; e=&quot;F4&quot; next=&quot;preprefinal&quot; /&gt;
 &lt;legal type=&quot;preprefinal&quot; s=&quot;80&quot; e=&quot;BF&quot; next=&quot;prefinal&quot; /&gt;
&lt;/validity&gt; </pre>
  <h4>4.2.2 <a name="Full_Validity_Checks">Full Validity Checks</a></h4>
  <p>The following provides the full validity specification for UTF-8, as shown 
  in <a href="http://www.unicode.org/unicode/reports/tr28/#3_1_conformance">Table 
  3.1B. Legal UTF-8 Byte Sequences</a> in <a href="http://www.unicode.org/unicode/reports/tr28/">Unicode 
  Version 3.2</a> [<a href="tr22-3.html#U3.2">U3.2</a>].</p>
  <pre>&lt;validity&gt;
 &lt;!--Validity specification for UTF-8, full boundary checks--&gt;
 &lt;state type=&quot;FIRST&quot; next=&quot;VALID&quot; s=&quot;00&quot; e = &quot;7F&quot;/&gt;

 &lt;!-- Normal Final Bytes --&gt;
 &lt;state type=&quot;final&quot; s=&quot;80&quot; e=&quot;BF&quot; next=&quot;VALID&quot;/&gt;
 &lt;state type=&quot;prefinal&quot;  s=&quot;80&quot; e=&quot;BF&quot; next=&quot;final&quot; /&gt;
 &lt;state type=&quot;preprefinal&quot; s=&quot;80&quot; e=&quot;BF&quot; next=&quot;prefinal&quot; /&gt;

 &lt;!-- 2 byte form, Normal --&gt;
 &lt;state type=&quot;FIRST&quot; s=&quot;C2&quot; e=&quot;DF&quot; next=&quot;final&quot; /&gt;

 &lt;!-- 3 byte form; Low range is special--&gt;
 &lt;state type=&quot;FIRST&quot; s=&quot;E0&quot;        next=&quot;prefinalLow&quot; /&gt; 
 &lt;state type=&quot;prefinalLow&quot; s=&quot;A0&quot; e=&quot;BF&quot; next=&quot;final&quot; /&gt; 

 &lt;!-- 3 byte form, Normal --&gt;
 &lt;state type=&quot;FIRST&quot; s=&quot;E1&quot; e=&quot;EC&quot; next=&quot;prefinal&quot;  /&gt;
 &lt;state type=&quot;FIRST&quot; s=&quot;EE&quot; e=&quot;EF&quot; next=&quot;prefinal&quot;  /&gt;

 &lt;!-- 3 byte form, Omitting Surrogates --&gt;
 &lt;state type=&quot;FIRST&quot; s=&quot;ED&quot; next=&quot;prefinalBelowSurrogate&quot;  /&gt;
 &lt;state type=&quot;prefinalBelowSurrogate&quot;  s=&quot;80&quot; e=&quot;9F&quot; next=&quot;final&quot; /&gt; </pre>
  <pre> &lt;!-- 4 byte form, Low range is special --&gt;
 &lt;state type=&quot;FIRST&quot; s=&quot;F0&quot;        next=&quot;preprefinalLow&quot; /&gt; 
 &lt;state type=&quot;preprefinalLow&quot; s=&quot;90&quot; e=&quot;BF&quot; next=&quot;prefinal&quot;/&gt;

 &lt;!-- 4 byte form, Normal --&gt;
 &lt;state type=&quot;FIRST&quot; s=&quot;F1&quot; e=&quot;F3&quot; next=&quot;preprefinal&quot;   /&gt;

 &lt;!-- 4 byte form, High range is special--&gt;
 &lt;state type=&quot;FIRST&quot; s=&quot;F4&quot;        next=&quot;preprefinalHigh&quot; /&gt;
 &lt;state type=&quot;preprefinalHigh&quot; s=&quot;80&quot; e=&quot;8F&quot; next=&quot;prefinal&quot;/&gt; 
&lt;/validity&gt;</pre>
  <h2><a name="Data_Files">Data Files</a></h2>
<!-- Silent Update 2009-06-30 kenw, updated dtd file link version 3 instead of 2.2 for this version. 
 Also removed bad anchors on the references and width="1" in table. -->
  <table cellspacing="12" cellpadding="0" width="100%" border="0" class="noborder">
    <tbody>
      <tr>
        <td valign="top" class="noborder"><a href="CharacterMapping.dtd">CharacterMapping.dtd</a></td>
        <td valign="top" class="noborder" rowspan="2">
          <p align="left">DTD file for the Character Mapping Data format:<br>
          latest version, and the version associated with this document</td>
      </tr>
      <tr>
        <td valign="top" class="noborder"><a href="CharacterMapping-3.dtd">CharacterMapping-3.dtd</a></td>
      </tr>
      <tr>
        <td valign="top" class="noborder"><a href="CharacterMappingAliases.dtd">CharacterMappingAliases.dtd</a></td>
        <td valign="top" class="noborder" rowspan="2">
          <p align="left">DTD file for the Character Mapping Alias format:<br>
          latest version, and the version associated with this document</td>
      </tr>
      <tr>
        <td valign="top" class="noborder"><a href="CharacterMappingAliases-3.dtd">CharacterMappingAliases-3.dtd</a></td>
      </tr>
      <tr>
        <td valign="top" class="noborder"><a href="SampleMappings.xml">SampleMappings.xml</a></td>
        <td valign="top" class="noborder">
          <p align="left">Sample mapping file</td>
      </tr>
      <tr>
        <td valign="top" class="noborder"><a href="SampleAliases.xml">SampleAliases.xml</a></td>
        <td valign="top" class="noborder">Sample alias file</td>
      </tr>
      <tr>
        <td valign="top" class="noborder"><a href="SampleAliases2.xml">SampleAliases2.xml</a></td>
        <td valign="top" class="noborder">Sample alias file #2</td>
      </tr>
    </tbody>
  </table>
  <h2><a name="References"><br>
  References</a></h2>
  <table cellspacing="12" cellpadding="0" width="100%" border="0" class="noborder">
    <tbody>
      <tr>
        <td valign="top" width="1" class="noborder">[<a name="BIDI">BIDI</a>]</td>
        <td valign="top" class="noborder">
          <p align="left">Unicode Standard Annex #9: The Bidirectional Algorithm<br>
          <a href="../tr9/index.html">http://www.unicode.org/reports/tr9/</a></td>
      </tr>
      <tr>
        <td class="noborder" width="1">[<a name="FAQ">FAQ</a>]</td>
        <td class="noborder">Unicode Frequently Asked Questions<br>
          <a href="http://www.unicode.org/unicode/faq/">http://www.unicode.org/unicode/faq/<br>
          </a><i>For answers to common questions on technical issues.</i></td>
      </tr>
      <tr>
        <td class="noborder" width="1">[<a name="Glossary">Glossary</a>]</td>
        <td class="noborder">Unicode Glossary<a href="http://www.unicode.org/glossary/"><br>
          http://www.unicode.org/glossary/<br>
          </a><i>For explanations of terminology used in this and other 
          documents.</i></td>
      </tr>
      <tr>
        <td valign="top" width="1" class="noborder">[<a name="IANA">IANA</a>]</td>
        <td valign="top" class="noborder">
          <p align="left">IANA character set registry<br>
          <a href="http://www.isi.edu/in-notes/iana/assignments/character-sets">http://www.isi.edu/in-notes/iana/assignments/character-sets</a></td>
      </tr>
      <tr>
        <td valign="top" width="1" class="noborder">[<a name="Normal">Normal</a>]</td>
        <td valign="top" class="noborder">
          <p align="left">Unicode Standard Annex #15, Unicode Normalization 
          Forms<br>
          <a href="../tr15.1">http://www.unicode.org/reports/tr15/</a></td>
      </tr>
      <tr>
        <td valign="top" width="1" class="noborder">[<a name="NormCharts">NormCharts</a>]</td>
        <td valign="top" class="noborder">Normalization Charts<br>
          <a href="http://www.unicode.org/charts/normalization/">http://www.unicode.org/charts/normalization/</a></td>
      </tr>
      <tr>
        <td class="noborder" width="1">[<a name="Reports">Reports</a>]</td>
        <td class="noborder">Unicode Technical Reports<br>
          <a href="../index.html">http://www.unicode.org/reports/<br>
          </a><i>For information on the status and development process for 
          technical reports, and for a list of technical reports.</i></td>
      </tr>
      <tr>
        <td valign="top" width="1" class="noborder">[<a name="ConvRef">Conv</a>]</td>
        <td valign="top" class="noborder">ICU Conversion Table Repository<br>
          <a href="http://oss.software.ibm.com/icu/charset">http://oss.software.ibm.com/icu/charset</a></td>
      </tr>
      <tr>
        <td class="noborder" width="1">[<a name="Versions">Versions</a>]</td>
        <td class="noborder">Versions of the Unicode Standard<br>
          <a href="http://www.unicode.org/versions/">http://www.unicode.org/versions/<br>
          </a><i>For details on the precise contents of each version of the 
          Unicode Standard, and how to cite them.</i></td>
      </tr>
      <tr>
        <td class="noborder" width="1">[<a name="U3.2">U3.2</a>]</td>
        <td class="noborder">The Unicode Consortium. The Unicode Standard, 
          Version 3.2.0 is defined by <i>The Unicode Standard, Version 3.0</i> 
          (Reading, MA, Addison-Wesley, 2000. ISBN 0-201-61633-5), as amended by 
          the <i>Unicode Standard Annex #27: Unicode 3.1</i> (<a href="http://www.unicode.org/unicode/reports/tr27/">http://www.unicode.org/reports/tr27/</a>) 
          and by the Unicode Standard Annex #28: <i>Unicode 3.2</i> (<a href="../tr28/index.html">http://www.unicode.org/reports/tr28/</a>).</td>
      </tr>
    </tbody>
  </table>
  <h2><a name="Modifications"><br>
  Modification History</a></h2>
  <p>The following summarizes modifications from the previous versions of this 
  document.</p>
  <table cellspacing="4" cellpadding="0" width="100%" border="0" class="noborder">
    <tbody>
      <tr>
        <td valign="top" width="1" class="noborder"><a name="TrackingNumber3">3</a></td>
        <td valign="top" class="noborder">
          <ul>
            <li>Added new sections
              <ul>
                <li><a href="tr22-3.html#Dual_Substitution_Handling">1.1.2 Dual 
                  Substitution Handling</a></li>
                <li><a href="tr22-3.html#Charset_Alias_Matching">1.4 Charset Alias Matching</a></li>
                <li><a href="tr22-3.html#Simple_SI_SO-Stateful_Encodings">2.3.1 Simple 
                  SI/SO- Stateful Encodings</a></li>
                <li><a href="tr22-3.html#ISO_2022">2.5 ISO 2022</a></li>
              </ul>
            </li>
            <li>Added some references to the new section.</li>
            <li>Updated DTD with the new elements and attributes.
              <ul>
                <li>DTD files now versioned (although these and other changes 
                  will always be backwards-compatible.) The previous DTD files 
                  are on X-2.2.dtd.</li>
              </ul>
            </li>
            <li>Minor editing</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td valign="top" width="1" class="noborder"><a name="TrackingNumber2.2">2.2</a></td>
        <td valign="top" class="noborder">
          <ul>
            <li>Removed imports.</li>
            <li>Added discussion of bestFit mapping tables.</li>
            <li>Changed fallback aliases to bestFit. Changed ranks to 
              percentages.</li>
            <li>Added diagram and discussion of PU mappings.</li>
            <li>Added UNASSIGNED, max to the validity spec.</li>
            <li>Added range.</li>
            <li>Added more error conditions.</li>
            <li>Added note that we anticipate extending this for complex 
              mappings.</li>
            <li>Deleted combiningOrder, since it may not be necessary or 
              conflict with future mechanisms for complex mappings.</li>
            <li>Moved Alias table to separate section.</li>
            <li>Added DTDs and samples</li>
            <li>Minor editing.</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td valign="top" width="1" class="noborder"><a name="TrackingNumber2.1">2.1</a></td>
        <td valign="top" class="noborder">
          <ul>
            <li>The aliases and display names have been moved into a separate, 
              centralized table. A sample is also provided.</li>
            <li>The syntax of the fallback assignments and validity 
              specification have been simplified, and some of the identifiers 
              changed for clarity.</li>
            <li>Pointers are provided to sample tables.</li>
            <li>Minor editing</li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>
  <h2><a name="Acknowledgments">Acknowledgments</a></h2>
  <p>Thanks to Kent Karlsson, Ken Borgendale, Bertrand Damiba, Mark Leisher, 
  Tony Graham, Markus Scherer, Peter Constable, Martin Duerst, Martin Hoskin, 
  and Ken Whistler for their feedback on versions of this document. Thanks 
  especially to Markus Scherer for contributing most of the text for version 3.</p>
  <hr align="LEFT">
  <p><font size="2">Copyright © 1999-2002 Unicode, Inc. All Rights Reserved. 
  The Unicode Consortium makes no expressed or implied warranty of any kind, and 
  assumes no liability for errors or omissions. No liability is assumed for 
  incidental and consequential damages in connection with or arising out of the 
  use of the information or programs contained or accompanying this technical 
  report.</font></p>
  <p><font size="2">Unicode and the Unicode logo are trademarks of Unicode, 
  Inc., and are registered in some jurisdictions.</font></p>
</div>

</body>

</html>
