<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<title>UAX #9: The Bidirectional Algorithm</title>

<!-- WEB ONLY -->
<link rel="stylesheet" type="text/css" href="../reports-web.css">
<!-- BOOK ONLY 
<link rel="stylesheet" type="text/css" href="../reports-book.css"> -->

</head>
<body><div class="book"><!-- WEB ONLY--><div class="web-only">
<table class="header" cellspacing="0" cellpadding="0" width="100%">
  <tr>
    <td class="icon"><a href="http://www.unicode.org">
    <img align="middle" alt="[Unicode]" border="0" src="../logo60s2.gif" width="34" height="33"></a>&nbsp;&nbsp;<a class="bar" href="../index.html">Technical 
    Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>
</table>
</div>
<div class="body">
  <h2 class="uaxtitle">Unicode Standard Annex&nbsp;#9</h2>
  <h1>The Bidirectional Algorithm</h1>
  <div class="web-only">
  <table border="1" cellpadding="2" width="90%">
    <tr>
      <td valign="top" width="20%">Version</td>
      <td valign="top">Unicode 5.0.0</td>
    </tr>
    <tr>
      <td valign="top">Authors</td>
      <td valign="top">Mark Davis (<a href="mailto:mark.davis@google.com">mark.davis@google.com</a>)</td>
    </tr>
    <tr>
      <td valign="top">Date</td>
      <td valign="top">2006-09-15</td>
    </tr>
    <tr>
      <td valign="top">This Version</td>
      <td valign="top">
      <a href="tr9-17.html">
      http://www.unicode.org/reports/tr9/tr9-17.html</a></td>
    </tr>
    <tr>
      <td valign="top">Previous Version</td>
      <td valign="top">
      <a href="tr9-15.html">
		http://www.unicode.org/reports/tr9/tr9-15.html</a></td>
    </tr>
    <tr>
      <td valign="top">Latest Version</td>
      <td valign="top"><a href="index.html">
      http://www.unicode.org/reports/tr9/</a></td>
    </tr>
    <tr>
      <td valign="top">Revision</td>
      <td valign="top"><a href="tr9-17.html#Modifications">17</a></td>
    </tr>
  </table>
  </div>
  <h4 class="summary">Summary</h4>
  <p><i>This annex describes specifications for the positioning of characters flowing from right 
  to left, such as Arabic or Hebrew.</i></p>
  <div class="web-only">
  <h4 class="status">Status</h4>
  <p><i>This document has been reviewed by Unicode members and other interested 
	parties, and has been approved for publication by the Unicode Consortium. 
	This is a stable document and may be used as reference material or cited as 
	a normative reference by other specifications.</i></p>
  <blockquote>
    <p><i><b>A Unicode Standard Annex (UAX)</b> forms an integral part of the 
	Unicode Standard, but is published online as a separate document. The 
	Unicode Standard may require conformance to normative content in a Unicode 
	Standard Annex, if so specified in the Conformance chapter of that version 
	of the Unicode Standard. The version number of a UAX document corresponds to 
	the version of the Unicode Standard of which it forms a part.</i></p>
  </blockquote>
  <p><i>Please submit corrigenda and other comments with the online reporting form [<a href="../tr41/tr41-1.html#Feedback">Feedback</a>]. 
  Related information that is useful in understanding this annex is found in
  Unicode Standard Annex #41, “<a href="../tr41/tr41-1.html">Common References for Unicode Standard Annexes</a>.” For the latest version of the Unicode Standard see [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]. 
  For a list of current Unicode Technical Reports see [<a href="../tr41/tr41-1.html#Reports">Reports</a>]. For more 
  information about versions of the Unicode Standard, see [<a href="../tr41/tr41-1.html#Versions">Versions</a>].</i></p>
  </div>
  <h4 class="contents"><i>Contents</i></h4>
  <ul class="toc">
    <li>1&nbsp; <a href="tr9-17.html#3.1_Bidirectional_Behavior">Introduction</a></li>
    <li>2&nbsp; <a href="tr9-17.html#Directional_Formatting_Codes">Directional Formatting Codes</a>
    <ul class="toc">
      <li>2.1&nbsp; <a href="tr9-17.html#Explicit_Directional_Embedding">Explicit Directional Embedding</a>
      </li>
      <li>2.2&nbsp; <a href="tr9-17.html#Explicit_Directional_Overrides">Explicit Directional Overrides</a>
      </li>
      <li>2.3&nbsp; <a href="tr9-17.html#Terminating_Explicit_Directional_Code">Terminating Explicit 
      Directional Code</a> </li>
      <li>2.4&nbsp; <a href="tr9-17.html#Implicit_Directional_Marks">Implicit Directional Marks</a> </li>
    </ul>
    </li>
    <li>3&nbsp; <a href="tr9-17.html#Basic_Display_Algorithm">Basic Display Algorithm</a>
    <ul class="toc">
      <li>3.1&nbsp; <a href="tr9-17.html#Definitions">Definitions</a>: <a href="tr9-17.html#BD1">BD1</a>, <a href="tr9-17.html#BD2">
      BD2</a>, <a href="tr9-17.html#BD3">BD3</a>, <a href="tr9-17.html#BD4">BD4</a> <a href="tr9-17.html#BD5">BD5</a>, <a href="tr9-17.html#BD6">
      BD6</a>, <a href="tr9-17.html#BD7">BD7</a> </li>
      <li>3.2&nbsp; <a href="tr9-17.html#Bidirectional_Character_Types">Bidirectional Character Types</a> </li>
      <li>3.3&nbsp; <a href="tr9-17.html#Resolving_Embedding_Levels">Resolving Embedding Levels</a>
      <ul class="toc">
        <li>3.3.1&nbsp; <a href="tr9-17.html#The_Paragraph_Level">The Paragraph Level</a>: <a href="tr9-17.html#P1">P1</a>,
        <a href="tr9-17.html#P2">P2</a>, <a href="tr9-17.html#P3">P3</a> </li>
        <li>3.3.2&nbsp; <a href="tr9-17.html#Explicit_Levels_and_Directions">Explicit Levels and Directions</a>:
        <a href="tr9-17.html#X1">X1</a>, <a href="tr9-17.html#X2">X2</a>, <a href="tr9-17.html#X3">X3</a>, <a href="tr9-17.html#X4">X4</a>,
        <a href="tr9-17.html#X5">X5</a>, <a href="tr9-17.html#X6">X6</a>, <a href="tr9-17.html#X7">X7</a>, <a href="tr9-17.html#X8">X8</a>,
        <a href="tr9-17.html#X9">X9</a>, <a href="tr9-17.html#X10">X10</a> </li>
        <li>3.3.3&nbsp; <a href="tr9-17.html#Resolving_Weak_Types">Resolving Weak Types</a>: <a href="tr9-17.html#W1">W1</a>,
        <a href="tr9-17.html#W2">W2</a>, <a href="tr9-17.html#W3">W3</a>, <a href="tr9-17.html#W4">W4</a>, <a href="tr9-17.html#W5">W5</a>,
        <a href="tr9-17.html#W6">W6</a>, <a href="tr9-17.html#W7">W7</a> </li>
        <li>3.3.4&nbsp; <a href="tr9-17.html#Resolving_Neutral_Types">Resolving Neutral Types</a>:
        <a href="tr9-17.html#N1">N1</a>, <a href="tr9-17.html#N2">N2</a> </li>
        <li>3.3.5&nbsp; <a href="tr9-17.html#Resolving_Implicit_Levels">Resolving Implicit Levels</a>:
        <a href="tr9-17.html#I1">I1</a>, <a href="tr9-17.html#I2">I2</a> </li>
      </ul>
      </li>
      <li>3.4&nbsp; <a href="tr9-17.html#Reordering_Resolved_Levels">Reordering Resolved Levels</a>:
      <a href="tr9-17.html#L1">L1</a>, <a href="tr9-17.html#L2">L2</a>, <a href="tr9-17.html#L3">L3</a>, <a href="tr9-17.html#L4">L4</a> </li>
      <li>3.5&nbsp; <a href="tr9-17.html#Shaping">Shaping</a> </li>
    </ul>
    </li>
    <li>4&nbsp; <a href="tr9-17.html#Bidirectional_Conformance">Bidirectional Conformance</a>
    <ul class="toc">
      <li>4.1&nbsp; <a href="tr9-17.html#Boundary_Neutrals">Boundary Neutrals</a> </li>
      <li>4.2&nbsp; <a href="tr9-17.html#Explicit_Formatting_Codes">Explicit Formatting Codes</a> </li>
      <li>4.3&nbsp; <a href="tr9-17.html#Higher-Level_Protocols">Higher-Level Protocols</a>: <a href="tr9-17.html#HL1">HL1</a>,
      <a href="tr9-17.html#HL1">HL2</a>, <a href="tr9-17.html#HL3">HL3</a>, <a href="tr9-17.html#HL4">HL4</a>, <a href="tr9-17.html#HL5">HL5</a>,
      <a href="tr9-17.html#HL6">HL6</a> </li>
    </ul>
    </li>
    <li>5&nbsp; <a href="tr9-17.html#Implementation_Notes">Implementation Notes</a>
    <ul class="toc">
      <li>5.1&nbsp; <a href="tr9-17.html#Reference_Code">Reference Code</a> </li>
      <li>5.2&nbsp; <a href="tr9-17.html#Retaining_Format_Codes">Retaining Format Codes</a> </li>
      <li>5.3&nbsp; <a href="tr9-17.html#Joiners">Joiners</a> </li>
      <li>5.4&nbsp; <a href="tr9-17.html#Vertical_Text">Vertical Text</a> </li>
      <li>5.5&nbsp; <a href="tr9-17.html#Usage">Usage</a> </li>
    </ul>
    </li>
    <li>6&nbsp; <a href="tr9-17.html#Mirroring">Mirroring</a></li>
    <li><a href="tr9-17.html#Acknowledgements">Acknowledgments</a></li>
    <li><a href="tr9-17.html#References">References</a></li>
    <li><a href="tr9-17.html#Modifications">Modifications</a></li>
  </ul>
  <hr>
  <h2 class="section"><a name="3.1_Bidirectional_Behavior"></a>1 Introduction</h2>
  <p>The Unicode Standard prescribes a <em>memory</em> representation order known as logical order. 
  When text is presented in horizontal lines, most scripts display characters from left to right. 
  However, there are several scripts (such as Arabic or Hebrew) where the natural ordering of 
  horizontal text in display is from right to left. If all of the text has the same horizontal 
  direction, then the ordering of the display text is unambiguous. However, when bidirectional text 
  (a mixture of left-to-right and right-to-left horizontal text) is present, some ambiguities can 
  arise in determining the ordering of the displayed characters.</p>
  <p>This annex describes the algorithm used to determine the directionality for bidirectional 
  Unicode text. The algorithm extends the implicit model currently employed by a number of existing 
  implementations and adds explicit format codes for special circumstances. In most cases, there is 
  no need to include additional information with the text to obtain correct display ordering.</p>
  <p>However, in the case of bidirectional text, there are circumstances where 
	an implicit bidirectional ordering is not sufficient to produce 
	comprehensible text. To deal with these cases, a minimal set of directional 
	formatting codes is defined to control the ordering of characters when 
	rendered. This allows exact control of the display ordering for legible 
	interchange and 
  ensures that plain text used for simple items like filenames or labels can always be correctly 
  ordered for display.</p>
  <p>The directional formatting codes are used <i>only</i> to influence the display ordering of 
  text. In all other respects they should be ignored—they have no effect on the comparison of text or on word breaks, parsing, or numeric analysis.</p>
  <p>When working with bidirectional text, the characters are still interpreted in logical 
  order—only the display is affected. The display ordering of bidirectional text depends on the 
  directional properties of the characters in the text.</p>
  <h2 class="section"><a name="Directional_Formatting_Codes"></a>2 Directional Formatting Codes</h2>
  <p>Two types of explicit codes are used to modify the standard implicit Unicode 
	Bidirectional Algorithm. In addition, there are implicit ordering codes, the <i>right-to-left</i> and <i>
  left-to-right</i> marks. All of these codes are limited to the current paragraph; thus their 
  effects are terminated by a <i>paragraph separator</i>. The directional types left-to-right and 
  right-to-left are called <i>strong types</i>, and characters of those types are called strong 
  directional characters. The directional types associated with numbers are called <i>weak types</i>, 
  and characters of those types are called weak directional characters.</p>
  <p>Although the term <em>embedding</em> is used for some explicit codes, the text within the scope 
  of the codes is not independent of the surrounding text. Characters within an embedding can affect 
  the ordering of characters outside, and vice versa. The algorithm is designed so that the use of 
  explicit codes can be equivalently represented by out-of-line information, such as stylesheet 
  information. However, any alternative representation will be defined by reference to the behavior 
  of the explicit codes in this algorithm.</p>
  <h3 class="section">2.1 <a name="Explicit_Directional_Embedding">Explicit Directional Embedding</a></h3>
  <p>The following codes signal that a piece of text is to be treated as embedded. For example, an 
  English quotation in the middle of an Arabic sentence could be marked as being embedded 
  left-to-right text. If there were a Hebrew phrase in the middle of the English quotation, 
	the that phrase could be marked as being embedded right-to-left. These codes allow for nested 
  embeddings.</p>
  <table border="0" cellspacing="2" cellpadding="2">
    <tr>
      <th valign="TOP">RLE</th>
      <td valign="TOP">Right-to-Left Embedding&nbsp;&nbsp;</td>
      <td valign="TOP">Treat the following text as embedded right-to-left.</td>
    </tr>
    <tr>
      <th valign="TOP">LRE</th>
      <td valign="TOP">Left-to-Right Embedding&nbsp;&nbsp;</td>
      <td valign="TOP">Treat the following text as embedded left-to-right.</td>
    </tr>
  </table>
  <p>The precise meaning of these codes will be made clear in the discussion of the algorithm. The 
  effect of right-left line direction, for example, can be accomplished by simply embedding the text 
  with RLE...PDF.</p>
  <h3 class="section">2.2 <a name="Explicit_Directional_Overrides">Explicit Directional Overrides</a></h3>
  <p>The following codes allow the bidirectional character types to be overridden when required for 
  special cases, such as for part numbers. These codes allow for nested directional overrides.</p>
  <table border="0" cellspacing="2" cellpadding="2">
    <tr>
      <th valign="TOP">RLO</th>
      <td valign="TOP">Right-to-Left Override&nbsp;&nbsp;</td>
      <td valign="TOP" width="277">Force following characters to be treated as 
		strong right-to-left characters.</td>
    </tr>
    <tr>
      <th valign="TOP">LRO</th>
      <td valign="TOP">Left-to-Right Override&nbsp;&nbsp;</td>
      <td valign="TOP" width="277">Force following characters to be treated as strong left-to-right characters.</td>
    </tr>
  </table>
  <p>The precise meaning of these codes will be made clear in the discussion of the algorithm. The 
  right-to-left override, for example, can be used to force a part number made of mixed English, 
  digits and Hebrew letters to be written from right to left.</p>
  <h3 class="section">2.3 <a name="Terminating_Explicit_Directional_Code">Terminating Explicit Directional Code</a></h3>
  <p>The following code terminates the effects of the last explicit code (either embedding or 
  override) and restores the bidirectional state to what it was before that code was encountered.</p>
  <table border="0" cellspacing="2" cellpadding="2">
    <tr>
      <th valign="TOP" align="LEFT">PDF</th>
      <td valign="TOP">Pop Directional Format&nbsp;&nbsp;</td>
      <td valign="TOP">Restore the bidirectional state to what it was before the last LRE, RLE, RLO, 
      or LRO.</td>
    </tr>
  </table>
  <h3 class="section">2.4 <a name="Implicit_Directional_Marks">Implicit Directional Marks</a></h3>
  <p>These characters are very light-weight codes. They act exactly like right-to-left or 
  left-to-right characters, except that they do not display or have any other semantic effect. Their 
  use is more convenient than using explicit embeddings or overrides because their scope is 
  much more local.</p>
  <table border="0" cellspacing="2" cellpadding="2">
    <tr>
      <th align="LEFT">RLM</th>
      <td >Right-to-Left Mark&nbsp;&nbsp;</td>
      <td >Right-to-left zero-width character</td>
    </tr>
    <tr>
      <th align="LEFT">LRM</th>
      <td >Left-to-Right Mark&nbsp;&nbsp;</td>
      <td >Left-to-right zero-width character</td>
    </tr>
  </table>
  <p>There is no special mention of the implicit directional marks in the following algorithm. That 
  is because their effect on bidirectional ordering is exactly the same as a corresponding strong 
  directional character; the only difference is that they do not appear in the display.</p>
  <h2 class="section">3 <a name="Basic_Display_Algorithm">Basic Display Algorithm</a></h2>
  <p>The Bidirectional Algorithm takes a stream of text as input and proceeds in three main phases:
  </p>
  <ul>
    <li>Separation of the input text into paragraphs. The rest of the algorithm affects only the 
    text between paragraph separators.</li>
    <li>Resolution of the embedding levels of the text. In this phase, the directional character 
    types, plus the explicit format codes, are used to produce resolved embedding levels.</li>
    <li>Reordering the text for display on a line-by-line basis using the resolved embedding levels, 
    once the text has been broken into lines.</li>
  </ul>
  <p>The algorithm reorders text only within a paragraph; characters in one paragraph have no effect 
  on characters in a different paragraph. Paragraphs are divided by the Paragraph Separator or 
  appropriate Newline Function (for guidelines on the handling of CR, LF, and CRLF, see <i>
  <span class="section">Section </span><span class="secno">4.4,</span> Directionality</i>, and <i>Section 5.8, Newline Guidelines</i> of [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]). 
  Paragraphs may also be determined by higher-level protocols: for example, the text in two 
  different cells of a table will be in different paragraphs.</p>
  <p>Combining characters always attach to the preceding base character in the memory 
  representation. Even after reordering for display and performing character shaping, the glyph 
  representing a combining character will attach to the glyph representing its base character in 
  memory. Depending on the line orientation and the placement direction of base letterform glyphs, 
  it may, for example, attach to the glyph on the left, or on the right, or above.</p>
  <div align="center">
  <p>This annex uses the numbering conventions for normative 
	definitions and rules in <i>Table 1</i>.</p>
       <p class="caption">Table 1. <span style="font-weight: 400">Normative Definitions and Rules</span></p>
   <table border="1" cellspacing="2" cellpadding="2">
      <tr>
        <th align="LEFT">Numbering</th>
        <th align="LEFT">Section</th>
      </tr>
      <tr>
        <td>BDn</td>
        <td>Definitions</td>
      </tr>
      <tr>
        <td>Pn</td>
        <td>Paragraph levels</td>
      </tr>
      <tr>
        <td>Xn</td>
        <td>Explicit levels and directions</td>
      </tr>
      <tr>
        <td>Wn</td>
        <td>Weak types</td>
      </tr>
      <tr>
        <td>Nn</td>
        <td>Neutral types</td>
      </tr>
      <tr>
        <td>In</td>
        <td>Implicit levels</td>
      </tr>
      <tr>
        <td>Ln</td>
        <td>Resolved levels</td>
      </tr>
    </table>
  </div>
  <h3 class="section">3.1 <a name="Definitions">Definitions</a></h3>
  <p><a name="BD1">BD1</a>. The <i>bidirectional characters types</i> are values assigned to each 
  Unicode character, including unassigned characters.</p>
  <p><a name="BD2">BD2</a>. <i>Embedding levels</i> are numbers that indicate how deeply the text is 
  nested, and the default direction of text on that level. The minimum embedding level of text is 
  zero, and the maximum explicit depth is level 61.</p>
  <blockquote>
    <p>Embedding levels are explicitly set by both override format codes and by embedding format 
    codes; higher numbers mean the text is more deeply nested. The reason for having a limitation is 
    to provide a precise stack limit for implementations to guarantee the same results. Sixty-one 
    levels is far more than sufficient for ordering, even with mechanically generated formatting; 
    the display becomes rather muddied with more than a small number of embeddings.</p>
  </blockquote>
  <p><a name="BD3">BD3</a>. The default direction of the current embedding level 
	(for the character in question) is called the <i>embedding direction</i>. It is <b>L</b> if the embedding level is even, 
  and <b>R</b> if the embedding level is odd.</p>
  <blockquote>
    <p>For example, in a particular piece of text, Level 0 is plain English text. Level 1 is plain 
    Arabic text, possibly embedded within English level 0 text. Level 2 is English text, possibly 
    embedded within Arabic level 1 text, and so on. Unless their direction is overridden, English 
    text and numbers will always be an even level; Arabic text (excluding numbers) will always be an 
    odd level. The exact meaning of the embedding level will become clear when the reordering 
    algorithm is discussed, but the following provides an example of how the algorithm works.</p>
  </blockquote>
  <p><a name="BD4">BD4</a>. The <i>paragraph embedding level</i> is the embedding level that 
  determines the default bidirectional orientation of the text in that paragraph.</p>
  <p><a name="BD5">BD5</a>. The direction of the paragraph embedding level is called the <i>
  paragraph direction</i>.</p>
  <ul>
    <li>In some contexts the paragraph direction is also known as the <i>base direction</i>.</li>
  </ul>
  <p><a name="BD6">BD6</a>. The <i>directional override status</i> determines whether the 
  bidirectional type of characters is to be reset with explicit directional controls. This status 
  has three states, as shown in <i>Table 2</i>.</p>
  <div align="center">
    <center>
      <p class="caption">Table 2. <span style="font-weight: 400">Directional Override Status</span></p>
    <table border="1" cellspacing="2" cellpadding="2">
      <tr>
        <th align="LEFT">Status</th>
        <th align="LEFT">Interpretation</th>
      </tr>
      <tr>
        <th align="LEFT">Neutral</th>
        <td>No override is currently active</td>
      </tr>
      <tr>
        <th align="LEFT">Right-to-left</th>
        <td>Characters are to be reset to <b>R</b></td>
      </tr>
      <tr>
        <th align="LEFT">Left-to-right</th>
        <td>Characters are to be reset to <b>L</b></td>
      </tr>
    </table>
    </center>
  </div>
  <p><a name="BD7">BD7</a>. A <i>level run</i> is a maximal substring of characters that have the 
  same embedding level. It is maximal in that no character immediately before or after the substring 
  has the same level (a level run is also known as a <i>directional run)</i>.</p>
  <h4>Example</h4>
	<p>In this and the following examples, case is used to indicate different 
	implicit character types for those unfamiliar with right-to-left letters. 
	Uppercase letters stand for right-to-left characters (such as Arabic or 
	Hebrew), and lowercase letters stand for left-to-right characters (such as 
	English or Russian).</p>
  <pre><b>Memory:        </b>    car is THE CAR in arabic

<b>Character types:</b>   LLL-LL-RRR-RRR-LL-LLLLLL

<b>Resolved levels:</b>   000000011111110000000000</pre>
  <p>Notice that the neutral character (space) between THE and CAR gets the level of the surrounding 
  characters. The level of the neutral characters can also be changed by 
	inserting appropriate directional marks around neutral characters. These 
	marks have no other effects.</p>
	 <p><i>Table&nbsp;3</i> lists additional abbreviations used in the examples and internal character types used 
  in the algorithm.</p>
  <div align="center">
    <center>
      <p class="caption">Table 3. <span style="font-weight: 400">Abbreviations for Examples and Internal Types</span></p>
    <table border="1" cellspacing="1" cellpadding="2" id="table13">
      <tr>
        <th valign="TOP"><b>Symbol</b></th>
        <th valign="TOP"><b>Description</b></th>
      </tr>
      <tr>
        <td valign="TOP">N</td>
        <td valign="TOP">Neutral or Separator (B, S, WS, ON)</td>
      </tr>
      <tr>
        <td valign="TOP">e</td>
        <td valign="TOP">The text ordering type (L or R) that matches the embedding level direction 
        (even or odd)</td>
      </tr>
      <tr>
        <td valign="TOP">sor</td>
        <td valign="TOP">The text ordering type (L or R) assigned to the 
		position before a level run.</td>
      </tr>
      <tr>
        <td valign="TOP">eor</td>
        <td valign="TOP">The text ordering type (L or R) assigned to the 
		position after a level run.</td>
      </tr>
    </table>
    </center>
  </div>
  <h3 class="section">3.2 <a name="Bidirectional_Character_Types">Bidirectional Character Types</a></h3>
  <p>The normative bidirectional character types for each character are specified in the
  <a href="http://www.unicode.org/Public/UNIDATA/">Unicode Character Database</a> [<a href="../tr41/tr41-1.html#UCD">UCD</a>] 
  and are summarized in <i>Table&nbsp;4</i>. This is a summary only: there are exceptions to the general 
  scope. For example, certain characters such as U+0CBF <span class="name">KANNADA VOWEL SIGN</span> I are given Type L 
  (instead of NSM) to preserve canonical equivalence.</p>
  <ul>
    <li>The term European digits is used to refer to decimal forms common in Europe and elsewhere, 
    and Arabic-Indic digits to refer to the native Arabic forms. (See <i>Section&nbsp;8.2, Arabic</i> of 
    [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>], for more details on naming digits.)</li>
    <li>Unassigned characters are given strong types in the algorithm. This is an explicit exception 
    to the general Unicode conformance requirements with respect to unassigned characters. As 
    characters become assigned in the future, these bidirectional types may change. For 
    assignments to character types, see DerivedBidiClass.txt [<a href="../tr41/tr41-1.html#Props">DerivedBIDI</a>] 
    in the [<a href="../tr41/tr41-1.html#UCD">UCD</a>].</li>
    <li>Private-use characters can be assigned different values by a conformant implementation.</li>
    <li>For the purpose of the Bidirectional Algorithm, inline objects (such as graphics) are 
    treated as if they are an U+FFFC<span class="name"> OBJECT REPLACEMENT CHARACTER</span>.</li>
    <li>As of Unicode 4.0, the Bidirectional Character Types of a few Indic characters were altered 
    so that the Bidirectional Algorithm preserves <a name="canonical_equivalence">canonical 
    equivalence</a>. That is, two canonically equivalent strings will result in equivalent ordering 
    after applying the algorithm. This invariant will be maintained in the future.<p>
	<b>Note:</b>
	The Bidirectional Algorithm does <i>not</i> preserve compatibility equivalence.</li>
  </ul>
	 <center>
         <p class="caption">Table 4. <span style="font-weight: 400">Bidirectional Character Types</span></p>
   <table border="0" cellspacing="0" cellpadding="2" class="noBorder" id="table11">
      <tr>
        <td align="CENTER" class="noborder">
        <table border="1" cellspacing="1" cellpadding="2" id="table12">
          <tr>
            <th valign="TOP" align="LEFT">
            Category</th>
            <th valign="TOP" align="LEFT">
            Type</th>
            <th valign="TOP" align="LEFT">
            Description</th>
            <th valign="TOP" align="LEFT">
            General Scope</th>
          </tr>
          <tr>
            <th rowspan="7" align="LEFT">
            Strong</th>
            <td valign="TOP"><b>L</b></td>
            <td valign="TOP">Left-to-Right</td>
            <td valign="TOP">LRM, most alphabetic, syllabic, Han ideographs, 
			non-European or non-Arabic digits, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>LRE</b></td>
            <td valign="TOP">Left-to-Right Embedding</td>
            <td valign="TOP">LRE</td>
          </tr>
          <tr>
            <td valign="TOP"><b>LRO</b></td>
            <td valign="TOP">Left-to-Right Override</td>
            <td valign="TOP">LRO</td>
          </tr>
          <tr>
            <td valign="TOP"><b>R</b></td>
            <td valign="TOP">Right-to-Left</td>
            <td valign="TOP">RLM, Hebrew alphabet, and related punctuation</td>
          </tr>
          <tr>
            <td valign="TOP"><b>AL</b></td>
            <td valign="TOP">Right-to-Left Arabic</td>
            <td valign="TOP">Arabic, Thaana, and Syriac alphabets, most punctuation specific to 
            those scripts, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>RLE</b></td>
            <td valign="TOP">Right-to-Left Embedding</td>
            <td valign="TOP">RLE</td>
          </tr>
          <tr>
            <td valign="TOP"><b>RLO</b></td>
            <td valign="TOP">Right-to-Left Override</td>
            <td valign="TOP">RLO</td>
          </tr>
          <tr>
            <th rowspan="8" align="LEFT">
            Weak</th>
            <td valign="TOP"><b>PDF</b></td>
            <td valign="TOP">Pop Directional Format</td>
            <td valign="TOP">PDF</td>
          </tr>
          <tr>
            <td valign="TOP"><b>EN</b></td>
            <td valign="TOP">European Number</td>
            <td valign="TOP">European digits, Eastern Arabic-Indic digits, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>ES</b></td>
            <td valign="TOP">European Number Separator</td>
            <td valign="TOP"><span class="name">Plus sign</span>, 
			<span class="name">minus sign</span></td>
          </tr>
          <tr>
            <td valign="TOP"><b>ET</b></td>
            <td valign="TOP">European Number Terminator</td>
            <td valign="TOP"><span class="name">Degree sign</span>, currency symbols, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>AN</b></td>
            <td valign="TOP">Arabic Number</td>
            <td valign="TOP">Arabic-Indic digits, Arabic decimal and thousands separators, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>CS</b></td>
            <td valign="TOP">Common Number Separator</td>
            <td valign="TOP"><span class="name">Colon</span>, <span class="name">
			comma</span>, <span class="name">full stop</span> (<i>period</i>),
			<span class="name">No-break space</span>, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>NSM</b></td>
            <td valign="TOP">Nonspacing Mark</td>
            <td valign="TOP">Characters marked Mn (Nonspacing_Mark) and Me (Enclosing_Mark) 
			in the Unicode Character Database</td>
          </tr>
          <tr>
            <td valign="TOP"><b>BN</b></td>
            <td valign="TOP">Boundary Neutral</td>
            <td valign="TOP">Most formatting and control characters, other than 
			those explicitly given types above</td>
          </tr>
          <tr>
            <th rowspan="4" align="LEFT">
            Neutral</th>
            <td valign="TOP"><b>B</b></td>
            <td valign="TOP">Paragraph Separator</td>
            <td valign="TOP"><span class="name">Paragraph separator</span>, 
			appropriate Newline Functions, higher-level protocol paragraph 
			determination</td>
          </tr>
          <tr>
            <td valign="TOP"><b>S</b></td>
            <td valign="TOP">Segment Separator</td>
            <td valign="TOP"><i>Tab</i></td>
          </tr>
          <tr>
            <td valign="TOP"><b>WS</b></td>
            <td valign="TOP">Whitespace</td>
            <td valign="TOP"><span class="name">Space</span>, <span class="name">
			figure space</span>, <span class="name">line separator</span>, 
			<span class="name">form feed</span>, General Punctuation 
            spaces, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>ON</b></td>
            <td valign="TOP">Other Neutrals</td>
            <td valign="TOP">All other characters, including <span class="name">OBJECT REPLACEMENT CHARACTER</span></td>
          </tr>
        </table>
        </td>
      </tr>
    </table>
    </center>
   <div>  <p>&nbsp;</p>
</div>
	<h3 class="section">3.3 <a name="Resolving_Embedding_Levels">Resolving Embedding Levels</a></h3>
  <p>The body of the Bidirectional Algorithm uses character types and explicit codes to produce a 
  list of resolved levels. This resolution process consists of five steps: (1) determining the 
  paragraph level; (2) determining explicit embedding levels and directions; (3) resolving weak 
  types; (4) resolving neutral types; and (5) resolving implicit embedding levels.</p>
  <h3 class="section">3.3.1 <a name="The_Paragraph_Level">The Paragraph Level</a></h3>
  <p><i><a name="P1">P1</a>. Split the text into separate paragraphs. A paragraph separator is kept 
  with the previous paragraph. Within each paragraph, apply all the other rules of this algorithm.</i></p>
  <p><i><a name="P2">P2</a>. In each paragraph, find the first character of type L, AL, or R.</i></p>
  <p>Because paragraph separators delimit text in this algorithm, this will generally be the first 
  strong character after a paragraph separator or at the very beginning of the text. Note that the 
  characters of type LRE, LRO, RLE, or RLO are ignored in this rule. This is because typically they are 
  used to indicate that the embedded text is the <i>opposite</i> direction than the paragraph level.</p>
  <p><i><a name="P3">P3</a>. If a character is found in P2 and it is of type AL or R, then set the 
  paragraph embedding level to one; otherwise, set it to zero.</i></p>
  <p>Whenever a higher-level protocol specifies the paragraph level, rules P2 and P3 
	do not apply.</p>
  <h3 class="section">3.3.2 <a name="Explicit_Levels_and_Directions">Explicit Levels and Directions</a></h3>
  <p>All explicit embedding levels are determined from the embedding and override codes, by applying 
  the explicit level rules X1 through X9. These rules are applied as part of the same logical pass 
  over the input.</p>
  <h4>Explicit Embeddings</h4>
  <p><i><a name="X1">X1</a>. Begin by setting the current embedding level to the paragraph embedding 
  level. Set the directional override status to neutral. Process each character iteratively, 
  applying rules X2 through X9. Only embedding levels from 0 to 61 are valid in this phase.</i></p>
  <p>In the resolution of levels in rules I1 and I2, the maximum embedding level of 62 can be 
  reached.</p>
  <p><i><a name="X2">X2</a>. With each RLE, compute the least greater <b>odd</b> embedding level.</i></p>
  <blockquote>
    <p><i>a. If this new level would be valid, then this embedding code is valid. Remember (push) 
    the current embedding level and override status. Reset the current level to this new level, and 
    reset the override status to <b>neutral</b>.</i></p>
    <p><i>b. If the new level would not be valid, then this code is invalid. Do 
	not
 change the 
    current level or override status.</i></p>
  </blockquote>
  <p>For example, level 0 → 1; levels 1, 2 → 3; levels 3, 4 → 5; ...59, 60 → 61; above 60, no 
  change (do not change levels with RLE if the new level would be invalid).</p>
  <p><i><a name="X3">X3</a>. With each LRE, compute the least greater <b>even</b> embedding level.</i></p>
  <blockquote>
    <p><i>a. If this new level would be valid, then this embedding code is valid. Remember (push) 
    the current embedding level and override status. Reset the current level to this new level, and 
    reset the override status to <b>neutral</b>.</i></p>
    <p><i>b. If the new level would not be valid, then this code is invalid. Do 
	not
 change the 
    current level or override status.</i></p>
  </blockquote>
  <p>For example, levels 0, 1 → 2; levels 2, 3 → 4; levels 4, 5 → 6; ...58, 59 → 60; above 59, 
  no change (do not change levels with LRE if the new level would be invalid).</p>
  <h4>Explicit Overrides</h4>
  <p>An explicit directional override sets the embedding level in the same way the explicit 
  embedding codes do, but also changes the directional character type of affected characters to the 
  override direction.</p>
  <p><i><a name="X4">X4</a>. With each RLO, compute the least greater <b>odd</b> embedding level.</i></p>
  <blockquote>
    <p><i>a. If this new level would be valid, then this embedding code is valid. Remember (push) 
    the current embedding level and override status. Reset the current level to this new level, and 
    reset the override status to <b>right-to-left</b>.</i></p>
    <p><i>b. If the new level would not be valid, then this code is invalid. Do 
	not
 change the 
    current level or override status.</i></p>
  </blockquote>
  <p><i><a name="X5">X5</a>. With each LRO, compute the least greater <b>even</b> embedding level.</i></p>
  <blockquote>
    <p><i>a. If this new level would be valid, then this embedding code is valid. Remember (push) 
    the current embedding level and override status. Reset the current level to this new level, and 
    reset the override status to <b>left-to-right</b>.</i></p>
    <p><i>b. If the new level would not be valid, then this code is invalid. Do 
	not
 change the 
    current level or override status.</i></p>
  </blockquote>
  <p><i><a name="X6">X6</a>. For all types besides RLE, LRE, RLO, LRO, and PDF:</i></p>
  <blockquote>
    <p><i>a. Set the level of the current character to the current embedding level.</i></p>
    <p><i>b. Whenever the directional override status is not neutral, reset the current 
    character type to the directional override status.</i></p>
  </blockquote>
  <p>If the directional override status is neutral, then characters retain their normal types: 
  Arabic characters stay AL, Latin characters stay L, neutrals stay N, and so on. If the directional 
  override status is R, then characters become R. If the directional override status is L, then 
  characters become L.</p>
  <h4>Terminating Embeddings and Overrides</h4>
  <p>There is a single code to terminate the scope of the current explicit code, whether an 
  embedding or a directional override. All codes and pushed states are completely popped at the end 
  of paragraphs.</p>
  <p><i><a name="X7">X7</a>. With each PDF, determine the matching embedding or override code. If 
  there was a valid matching code, restore (pop) the last remembered (pushed) embedding level and 
  directional override.</i></p>
  <p><i><a name="X8">X8</a>. All explicit directional embeddings and overrides are completely 
  terminated at the end of each paragraph. Paragraph separators are <b>not</b> included in the 
  embedding.</i></p>
  <p><i><a name="X9">X9</a>. Remove all RLE, LRE, RLO, LRO, PDF, and BN codes.</i></p>
  <ul>
    <li>Note that an implementation does not have to actually remove the codes; it just has to 
    behave as though the codes were not present for the remainder of the algorithm. Conformance does 
    not require any particular placement of these codes as long as all other characters are ordered 
    correctly.
    <p>See <span class="section">Section </span><span class="secno">5,</span> <i><a href="tr9-17.html#Implementation_Notes">Implementation Notes</a></i>, for information on 
    implementing the algorithm without removing the formatting codes.</li>
    <li>The <i>zero width joiner</i> and <i>non-joiner</i> affect the shaping of the adjacent characters—those 
    that are adjacent in the original backing-store order, even though those characters may end up 
    being rearranged to be non-adjacent by the Bidirectional Algorithm. For more information, see 
	<span class="section">Section </span><span class="secno">5.3,</span> <i>
    <a href="tr9-17.html#Joiners">Joiners</a></i>.</li>
  </ul>
  <p><i><a name="X10">X10</a>. The remaining rules are applied to each run of characters at the same 
  level. For each run, determine the <i>start-of-level-run</i> (<b>sor</b>) and <i>end-of-level-run</i> 
  (<b>eor</b>) type, either L or R. This depends on the higher of the two levels on either side of 
  the boundary (at the start or end of the paragraph, the level of the &#x201C;other&#x201D; run is the base 
  embedding level). If the higher level is odd, the type is R; otherwise, it is L.</i></p>
  <p>For example:</p>
  <pre><b>Levels:</b>  0   0   0   1   1   1   2
<b>
Runs:</b>   &lt;--- 1 ---&gt; &lt;--- 2 ---&gt; &lt;3&gt;</pre>
  <p>Run 1 is at level 0, <i>sor</i> is L, <i>eor</i> is R.<br>
  Run 2 is at level 1, <i>sor</i> is R, <i>eor</i> is L.<br>
  Run 3 is at level 2, <i>sor</i> is L, <i>eor</i> is L.<br>
  </p>
  <p>For two adjacent runs, the <i>eor</i> of the first run is the same as the <i>sor</i> of the 
  second.</p>
  <h3 class="section">3.3.3 <a name="Resolving_Weak_Types">Resolving Weak Types</a></h3>
  <p>Weak types are now resolved one level run at a time. At level run boundaries where the type of 
  the character on the other side of the boundary is required, the type assigned to <i>sor</i> or <i>
  eor</i> is used.</p>
  <p>Nonspacing marks are now resolved based on the previous characters.</p>
  <p><i><a name="W1">W1</a>. Examine each nonspacing mark (NSM) in the level run, and change the 
  type of the NSM to the type of the previous characte</i><em>r. If the NSM is at the start of the 
  level run, it will get the type of <strong>sor</strong>.</em></p>
  <div class="book-only"><p>&nbsp;</p></div>
	<p>Assume in this example that <i>sor</i> is R:</p>
  <blockquote>
    <pre>AL  NSM NSM → AL  AL  AL
    
<i>sor</i> NSM     → <i>sor</i> R</pre>
  </blockquote>
  <p>The text is next parsed for numbers. This pass will change the directional 
	types European Number Separator, European Number Terminator, and Common 
	Number Separator to be European Number text, Arabic Number text, or Other 
	Neutral text. The text to be scanned may have already had its type altered 
	by directional overrides. If so, then it will not parse as numeric.</p>
  <p><i><a name="W2">W2</a>. Search backward from each instance of a European number until the 
  first strong type (R, L, AL, or <b>sor</b>) is found. If an AL is found, change the type of 
  the European number to Arabic number.</i></p>
  <blockquote>
    <pre>AL EN    → AL AN

AL N EN  → AL N AN

<i>sor</i> N EN → <i>sor</i> N EN

L N EN   → L N EN

R N EN   → R N EN</pre>
  </blockquote>
  <p><i><a name="W3">W3</a>. Change all ALs to R.</i></p>
  <p><i><a name="W4">W4</a>. A single European separator between two European numbers changes to a 
  European number. A single common separator between two numbers of the same type changes to that 
  type.</i></p>
  <blockquote>
    <pre>EN ES EN → EN EN EN

EN CS EN → EN EN EN

AN CS AN → AN AN AN</pre>
  </blockquote>
  <p><i><a name="W5">W5</a>. A sequence of European terminators adjacent to European numbers changes 
  to all European numbers.</i></p>
  <blockquote>
    <pre>ET ET EN → EN EN EN

EN ET ET → EN EN EN

AN ET EN → AN EN EN</pre>
  </blockquote>
  <p><i><a name="W6">W6</a>. Otherwise, separators and terminators change to Other Neutral.</i></p>
  <blockquote>
    <pre>AN ET    → AN ON

L  ES EN → L  ON EN

EN CS AN → EN ON AN

ET AN    → ON AN</pre>
  </blockquote>
  <p><i><a name="W7">W7</a>. Search backward from each instance of a European number until the 
  first strong type (R, L, or <b>sor</b>) is found. If an L is found,&nbsp;then change the type of 
  the European number to L.</i></p>
  <blockquote>
    <pre><tt>L  N EN </tt>=<tt>&gt; L  N  L</tt>

<tt>R  N EN </tt>=<tt>&gt; R  N  EN</tt></pre>
  </blockquote>
  <div class="book-only"><p>&nbsp;</p></div>
 <h3 class="section">3.3.4 <a name="Resolving_Neutral_Types">Resolving Neutral Types</a></h3>
  <p>Neutral types are now resolved one level run at a time. At level run boundaries where the type 
  of the character on the other side of the boundary is required, the type assigned to <i>sor</i> or
  <i>eor</i> is used.</p>
  <p>The next phase resolves the direction of the neutrals. The results of this phase are that all 
  neutrals become either <b>R</b> or <b>L</b>. Generally, neutrals take on the direction of the 
  surrounding text. In case of a conflict, they take on the embedding direction.</p>
  <p><i><a name="N1">N1</a>. A sequence of neutrals takes the direction of the surrounding strong 
  text if the text on both sides has the same direction. European and Arabic numbers act as if 
  they</i> <em>were R in terms of their influence on neutrals. Start-of-level-run (<strong>sor</strong>) 
  and end-of-level-run (<strong>eor</strong>) are used at level run boundaries.</em></p>
  <blockquote>
    <pre>R  N  R  → R  R  R

L  N  L  → L  L  L

R  N  AN → R  R  AN

AN N  R  → AN R  R

R  N  EN → R  R  EN

EN N  R  → EN R  R</pre>
  </blockquote>
  <p>Note that any AN or EN remaining after W7 will be in an right-to-left context.</p>
  <p><i><a name="N2">N2</a>. Any remaining neutrals take the embedding direction.</i></p>
  <blockquote>
    <pre>N → e</pre>
  </blockquote>
  <p>Assume in this example that <i>eor</i> is L and <i>sor</i> is R. Then an application of 
  N1 and N2 yields the following:</p>
  <blockquote>
    <pre>L   N <i>eor</i> → L   L <i>eor</i>

R   N <i>eor</i> → R   e <i>eor</i>

<i>sor</i> N L   → <i>sor</i> e L

<i>sor</i> N R   → <i>sor</i> R R</pre>
  </blockquote>
  <p><i>Examples.</i> A list of numbers separated by neutrals and embedded in a directional run will 
  come out in the run’s order.</p>
  <pre><b>  Storage:</b>	he said &quot;THE VALUES ARE 123, 456, 789, OK&quot;.

<b>  Display:</b>	he said &quot;KO ,789 ,456 ,123 ERA SEULAV EHT&quot;.</pre>
  <p>In this case, both the comma and the space between the numbers take on the direction of the 
  surrounding text (uppercase = right-to-left), ignoring the numbers. The commas are not considered 
  part of the number because they are not surrounded on both sides (see
  <span class="section">Section </span><span class="secno">3.3.3,</span> <i>Resolving Weak Types</i>). However, if 
  there is an adjacent left-to-right sequence, then European numbers will adopt that direction:</p>
  <pre><b>Storage:</b>	he said &quot;IT IS A bmw 500, OK.&quot;

<b>Display:</b>	he said &quot;.KO ,bmw 500 A SI TI&quot;</pre>
  <h3 class="section">3.3.5 <a name="Resolving_Implicit_Levels">Resolving Implicit Levels</a></h3>
  <p>In the final phase, the embedding level of text may be increased, based on the resolved 
  character type. Right-to-left text will always end up with an odd level, and left-to-right and 
  numeric text will always end up with an even level. In addition, numeric text will always end up 
  with a higher level than the paragraph level. (Note that it is possible for text to end up at 
  levels higher than 61 as a result of this process.) This results in the following rules:</p>
  <p><i><a name="I1">I1</a>.</i> <em>For all characters with an even (left-to-right) embedding 
  direction, those of type R go up one level and those of type AN or EN go up two levels.</em></p>
  <p><i><a name="I2">I2</a>.</i> <em>For all characters with an</em><i> odd (right-to-left)</i><em> 
  embedding direction</em><i>, those</i><em> of type L, EN or AN</em><i> go up one level.</i></p>
  <p><i>Table&nbsp;5</i> summarizes the results of the implicit algorithm.</p>
  <div align="center">
    <center>
      <p class="caption">Table 5. <span style="font-weight: 400">Resolving Implicit Levels</span></p>
    <table border="1" cellspacing="1" cellpadding="2">
      <tr>
        <th rowspan="2">Type</th>
        <th colspan="2">Embedding Level</th>
      </tr>
      <tr>
        <th>Even</th>
        <th>Odd</th>
      </tr>
      <tr>
        <td valign="TOP"><b>L</b></td>
        <td valign="TOP">EL</td>
        <td valign="TOP">EL+1</td>
      </tr>
      <tr>
        <td valign="TOP"><b>R</b></td>
        <td valign="TOP">EL+1</td>
        <td valign="TOP">EL</td>
      </tr>
      <tr>
        <td valign="TOP"><b>AN</b></td>
        <td valign="TOP">EL+2</td>
        <td valign="TOP">EL+1</td>
      </tr>
      <tr>
        <td valign="TOP"><b>EN</b></td>
        <td valign="TOP">EL+2</td>
        <td valign="TOP">EL+1</td>
      </tr>
    </table>
    </center>
  </div>
  <h3 class="section">3.4 <a name="Reordering_Resolved_Levels">Reordering Resolved Levels</a></h3>
  <p>The following rules describe the logical process of finding the correct display order.

	As opposed to resolution phases, 
  these rules act on a per-line basis<i> and are applied <b>after</b> any line wrapping is 
  applied to the paragraph.</i></p>
  <p>Logically there are the following steps: </p>
  <ul>
    <li>The levels of the text are determined according to the previous rules.</li>
    <li>The characters are shaped into glyphs according to their context <i>(taking the embedding 
    levels into account for mirroring).</i></li>
    <li>The accumulated widths of those glyphs <i>(in logical order)</i> are used to determine line 
    breaks.</li>
    <li>For each line, rules L1–L4 are used to reorder the characters on that line.</li>
    <li>The glyphs corresponding to the characters on the line are displayed in that order.</li>
  </ul>
  <p><i><a name="L1">L1</a>. On each line, reset the embedding level of the following characters to 
  the paragraph embedding level:</i> </p>
  <ol>
    <li><i>Segment separators,</i></li>
    <li><i>Paragraph separators,</i></li>
    <li><i>Any sequence of whitespace characters preceding a segment separator or paragraph 
    separator, and</i></li>
    <li><i>Any sequence of white space characters at the end of the line.</i></li>
  </ol>
  <ul>
    <li>The types of characters used here are the <i>original</i> types, not those modified by the 
    previous phase.</li>
    <li>Because a <span class="name">Paragraph Separator </span>breaks lines, there will be at most one per line, at the end of 
    that line.</li>
  </ul>
  <p>In combination with the following rule, this means that trailing whitespace will appear at the 
  visual end of the line (in the paragraph direction). Tabulation will always have a consistent 
  direction within a paragraph.</p>
  <p><i><a name="L2">L2</a>. From the highest level found in the text to the lowest odd level on 
  each line, including intermediate levels not actually present in the text, reverse 
  any contiguous sequence of characters that are at that level or higher.</i></p>
  <p>This reverses a progressively larger series of substrings. The following four examples 
  illustrate this. In these examples, the paragraph embedding level for the first and third 
  examples is assumed to be 0 (left-to-right direction), and for the second and fourth 
	examples is assumed to 
  be 1 (right-to-left direction).</p>
  <h5>Example 1 (embedding level = 0)</h5>
  <pre><b>Memory:</b>                car means CAR.

<b>Resolved levels:</b>     00000000001110

<b>Reverse level 1:</b>     car means RAC.</pre>
  <h5>Example 2 (embedding level = 1)</h5>
  <pre><b>Memory:</b>                car MEANS CAR.

<b>Resolved levels:</b>     22211111111111

<b>Reverse level 2:</b>     rac MEANS CAR.

<b>Reverse levels 1-2:</b>  .RAC SNAEM car</pre>
  <h5>Example 3 (embedding level = 0)</h5>
  <pre><b>Memory:</b>                he said &quot;car MEANS CAR.&quot;

<b>Resolved levels:</b>     000000000222111111111100

<b>Reverse level 2:</b>     he said &quot;rac MEANS CAR.&quot;

<b>Reverse levels 1-2:</b>  he said &quot;RAC SNAEM car.&quot;</pre>
  <h5>Example 4 (embedding level = 1)</h5>
  <pre><b>Memory:</b>                DID YOU SAY ‘he said &quot;car MEANS CAR&quot;’?

<b>Resolved levels:</b>     11111111111112222222224443333333333211

<b>Reverse level 4:</b>     DID YOU SAY ‘he said &quot;rac MEANS CAR&quot;’?

<b>Reverse levels 3-4:</b>  DID YOU SAY ‘he said &quot;RAC SNAEM car&quot;’?

<b>Reverse levels 2-4:</b>  DID YOU SAY ‘&quot;rac MEANS CAR&quot; dias eh’?

<b>Reverse levels 1-4:</b>  ?‘he said &quot;RAC SNAEM car&quot;’ YAS UOY DID</pre>
  <p><i><a name="L3">L3</a>. Combining marks applied to a right-to-left base character will at this 
  point precede their base character. If the rendering engine expects them to follow the base 
  characters in the final display process, then the ordering of the marks and the base character 
  must be reversed.</i></p>
  <p>Many font designers provide default metrics for combining marks that support rendering by 
  simple overhang. Because of the reordering for right-to-left characters, it is common practice to 
  make the glyphs for most combining characters overhang to the left (thus assuming the characters 
  will be applied to left-to-right base characters) and make the glyphs for combining characters in 
  right-to-left scripts overhang to the right (thus assuming that the characters will be applied to 
  right-to-left base characters). With such fonts, the display ordering of the marks and base glyphs 
  may need to be adjusted when combining marks are applied to &#x201C;unmatching&#x201D; base characters. See <i>
  Section 5.13, Rendering Nonspacing Marks</i> of [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>], for more 
  information.</p>
  <p><i><a name="L4">L4</a>. A character is 
  depicted by a mirrored glyph if and only if (a)
	the resolved directionality of that character is R,
	and (b) the Bidi_Mirrored 
  property value of that character is true.</i></p>
	<ul>
		<li><i>The Bidi_Mirrored property 
  		is defined by Section&nbsp;4.7, Bidi Mirrored—Normative of [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]; 
		the property values are specified in [<a href="../tr41/tr41-1.html#UCD">UCD</a>].</i></li>
		<li><i>This rule can be overridden in certain 
		cases; see
      <a href="tr9-17.html#HL6">HL6</a>.</i></li>
	</ul>
  <p>For example, U+0028<span class="name"> left parenthesis</span>—which is interpreted in the Unicode 
	Standard as an opening parenthesis—appears as “<b>(</b>” when its resolved 
	level is even, and as the mirrored glyph “<b>)</b>” 
  when its resolved level is odd. Note that for 
	backward compatibility the characters U+FD3E (﴾) <span class="name">ORNATE LEFT PARENTHESIS</span> 
	and U+FD3F (﴿) <span class="name">ORNATE RIGHT PARENTHESIS</span> are not mirrored.</p>
  <h3 class="section">3.5 <a name="Shaping">Shaping</a></h3>
  <p>Cursively connected scripts, such as Arabic or 
	Syriac, require the selection of positional character shapes that depend on 
	adjacent characters (see <i>Section 8.2, Arabic</i> of [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>]).
	Shaping is logically applied <i>after</i> the Bidirectional Algorithm is 
	used and is limited to characters within the same directional run. Consider the following 
	example string 
  of Arabic characters, which is represented in memory as characters 1, 2, 3, and 4, and where the first two characters 
  are overridden to be LTR. To show both paragraph directions, the next two are embedded, but with 
  the normal RTL direction.</p>
  <blockquote>
    <div align="center">
      <center>
      <table cellspacing="0" cellpadding="4" border="1">
        <tr>
          <td>
          <p align="center"><b>1</b></td>
          <td>
          <p align="center"><b>2</b></td>
          <td>
          <p align="center"><b><i>3</i></b></td>
          <td>
          <p align="center"><b><i>4</i></b></td>
        </tr>
        <tr>
          <td>
          <p align="center"><font size="6">ج</font><br>
          <tt>062C<br>
          JEEM</tt></td>
          <td>
          <p align="center"><font size="6">ع</font><br>
          <tt>0639<br>
          AIN</tt></td>
          <td>
          <p align="center"><font size="6">ل</font><br>
          <tt>0644<br>
          LAM</tt></td>
          <td>
          <p align="center"><font size="6">م</font><br>
          <tt>0645<br>
          MEEM</tt></td>
        </tr>
        <tr>
          <td>
          <p align="center"><b>L</b></td>
          <td>
          <p align="center"><b>L</b></td>
          <td>
          <p align="center"><b>R</b></td>
          <td>
          <p align="center"><b>R</b></td>
        </tr>
      </table>
      </center>
    </div>
  </blockquote>
  <p>One can use embedding codes to achieve this effect in plain text or use markup in HTML, as in the 
  examples below. (The <b>bold</b> text would be for the right-to-left paragraph direction.)</p>
  <ul>
    <li>LRM/<b>RLM</b> LRO&nbsp;<i>JEEM&nbsp;AIN</i>&nbsp;PDF RLO&nbsp;<i>LAM&nbsp;MEEM</i>&nbsp;PDF</li>
    <li>&lt;p dir=&quot;ltr&quot;/&quot;<b>rtl</b>&quot;&gt;LRO&nbsp;<i>JEEM&nbsp;AIN</i>&nbsp;PDF RLO&nbsp;<i>LAM&nbsp;MEEM</i>&nbsp;PDF&lt;/p&gt;</li>
    <li>&lt;p dir=&quot;ltr&quot;/&quot;<b>rtl</b>&quot;&gt;&lt;bdo&nbsp;dir=&quot;ltr&quot;&gt;<i>JEEM&nbsp;AIN</i>&lt;/bdo&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;bdo&nbsp;dir=&quot;rtl&quot;&gt;<i>LAM&nbsp;MEEM</i>&lt;/bdo&gt;&lt;/p&gt;</li>
  </ul>
  <p>The resulting shapes will be the following, according to the paragraph direction:</p>
  <div align="center">
    <center>
    <table cellspacing="0" cellpadding="8" border="1">
      <tr>
        <th width="50%">
        Left-Right Paragraph</th>
        <th width="50%">
        Right-Left Paragraph</th>
      </tr>
      <tr>
        <td width="50%">
        <table cellspacing="0" cellpadding="4" border="1">
          <tr>
            <td>
            <p align="center"><b>1</b></td>
            <td>
            <p align="center"><b>2</b></td>
            <td>
            <p align="center"><i><b>4</b></i></td>
            <td>
            <p align="center"><i><b>3</b></i></td>
          </tr>
          <tr>
            <td>
            <p align="center"><font size="6">ﺞ</font><tt><br>
            JEEM-F</tt></td>
            <td>
            <p align="center"><font size="6">ﻋ</font><tt><br>
            AIN-I</tt></td>
            <td>
            <p align="center"><font size="6">ﻢ</font><tt><br>
            MEEM-F</tt></td>
            <td>
            <p align="center"><font size="6">ﻟ</font><tt><br>
            LAM-I</tt></td>
          </tr>
        </table>
        </td>
        <td width="50%">
        <table cellspacing="0" cellpadding="4" border="1">
          <tr>
            <td>
            <p align="center"><i><b>4</b></i></td>
            <td>
            <p align="center"><i><b>3</b></i></td>
            <td>
            <p align="center"><b>1</b></td>
            <td>
            <p align="center"><b>2</b></td>
          </tr>
          <tr>
            <td>
            <p align="center"><font size="6">ﻢ</font><tt><br>
            MEEM-F</tt></td>
            <td>
            <p align="center"><font size="6">ﻟ</font><tt><br>
            LAM-I</tt></td>
            <td>
            <p align="center"><font size="6">ﺞ</font><tt><br>
            JEEM-F</tt></td>
            <td>
            <p align="center"><font size="6">ﻋ</font><tt><br>
            AIN-I</tt></td>
          </tr>
        </table>
        </td>
      </tr>
    </table>
    </center>
  </div>
  <h3 class="section">3.5.1 <a name="Shaping_and_line_breaking">
	Shaping and Line Breaking</a></h3>
	<p>The process of breaking a paragraph into one or 
	more lines that fit within particular bounds is outside the scope of the 
	Bidirectional Algorithm. Where character shaping is involved, the width 
	calculations must be based on the shaped glyphs. </p>
	<p>Note that the <i>soft-hyphen</i> (SHY) works in 
	cursively connected scripts as it does in other scripts. That is, it 
	indicates a point where the line could be broken in the middle of a word. If 
	the rendering system breaks at that point, the display—including shaping—should be what is appropriate for the given language. For more information 
	on this and other line breaking issues, see Unicode Standard Annex #14, “Line Breaking Properties” [<a href="../tr41/tr41-1.html#UAX14">UAX14</a>].</p>
	<h2 class="section">4 <a name="Bidirectional_Conformance">Bidirectional Conformance</a><a name="Conformance"></a></h2>
  <p>A process that claims conformance to this specification shall satisfy the the following 
  clauses:</p>
  <table border="0" cellspacing="0" cellpadding="4" class="noborder">
    <tr>
      <td valign="top" class="noborder" nowrap><a name="C1"><b><i>
		UAX9-C</i></b></a><b><i><a name="C1">1</a>.</i></b></td>
      <td valign="top" class="noborder">
		<p style="text-align: justify"><i>In the absence of a permissible higher-level protocol, a 
      process that renders text shall display all visible representations of characters (excluding 
      format characters) in the order described by <span class="section">Section </span><span class="secno">3,</span>  
      <a href="tr9-17.html#Basic_Display_Algorithm">Basic Display Algorithm</a>, of this annex. In particular, this includes definitions
      <a href="tr9-17.html#BD1">BD1</a>–<a href="tr9-17.html#BD7">BD7</a> and steps</i> <i> <a href="tr9-17.html#P1">P1</a>–<a href="tr9-17.html#P3">P3</a>,
      <a href="tr9-17.html#X1">X1</a>–<a href="tr9-17.html#X10">X10</a>, <a href="tr9-17.html#W1">W1</a>–<a href="tr9-17.html#W7">W7</a>,
      <a href="tr9-17.html#N1">N1</a>–<a href="tr9-17.html#N2">N2</a>, <a href="tr9-17.html#I1">I1</a>–<a href="tr9-17.html#I2">I2</a>, and
      <a href="tr9-17.html#L1">L1</a>–<a href="tr9-17.html#L4">L4</a>.</i></td>
    </tr>
  </table>
  <ul>
    <li>As is the case for all other Unicode algorithms, this is a <i>logical</i> description—particular implementations can have more efficient mechanisms as long as they produce the same 
    results. See C18 in <i>Chapter 3, Conformance</i> of [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>], and the notes following.</li>
    <li>The Bidirectional Algorithm specifies part of the intrinsic semantics of right-to-left 
    characters and is thus required for conformance to the Unicode Standard where any such 
    characters are displayed.</li>
  </ul>
  <table border="0" cellspacing="0" cellpadding="4" class="noborder">
    <tr>
      <td valign="top" class="noborder" nowrap>

		<a name="C2"><b><i>UAX9-</i></b></a><b><i>C<a name="C2">2</a>.</i></b></td>
      <td valign="top" class="noborder">
		<p style="text-align: justify"><i>The only permissible higher-level protocols are those 
      listed in <span class="section">Section </span><span class="secno">4.3,</span>  
		<a href="tr9-17.html#Higher-Level_Protocols">Higher-Level Protocols</a>. They are <a href="tr9-17.html#HL1">HL1</a>, <a href="tr9-17.html#HL1">HL2</a>,
      <a href="tr9-17.html#HL3">HL3</a>, <a href="tr9-17.html#HL4">HL4</a>, <a href="tr9-17.html#HL5">HL5</a>, and <a href="tr9-17.html#HL6">HL6</a>.</i></td>
    </tr>
  </table>
  <blockquote>
	<p>Use of higher-level protocols is discouraged, 
	because it introduces interchange problems and can lead to security 
	problems. For more information, see Unicode Technical Report #36, “Unicode Security 
	Considerations” [<a href="../tr41/tr41-1.html#UTR36">UTR36</a>].</p>
  </blockquote>
  <h3 class="section">4.1 <a name="Boundary_Neutrals">Boundary Neutrals</a></h3>
  <p>The goal in marking a format or control character as BN is that it have no effect on the rest 
  of the algorithm. (ZWJ and ZWNJ are exceptions; see <a href="tr9-17.html#X9">X9</a>). Because 
	conformance does not require the 
  precise ordering of format characters with respect to others, 
  implementations can handle them in different ways as long as they preserve the ordering 
  of the other characters.</p>
  <h3 class="section">4.2 <a name="Explicit_Formatting_Codes">Explicit Formatting Codes</a></h3>
  <p>As with any Unicode characters, systems do not have to support any particular explicit 
  directional formatting code (although it is not generally useful to include a terminating code 
  without including the initiator). Generally, conforming systems will fall into three classes: </p>
  <ul>
    <li><i>No bidirectional formatting.</i> This implies that the system does not visually interpret 
    characters from right-to-left scripts. </li>
    <li><i>Implicit bidirectionality.</i> The implicit Bidirectional Algorithm and the directional 
    marks RLM and LRM are supported. </li>
    <li><i>Full bidirectionality.</i> The implicit Bidirectional Algorithm, the implicit directional 
    marks, and the explicit directional embedding codes are supported: RLM, LRM, LRE, RLE, LRO, RLO, 
    PDF.</li>
  </ul>
  <h3 class="section">4.3 <a name="Higher-Level_Protocols">Higher-Level Protocols</a></h3>
  <p>The following clauses are the only permissible ways for systems to apply higher-level protocols 
  to the ordering of bidirectional text. Some of the clauses apply to <i>segments</i> of structured 
  text. This refers to the situation where text is interpreted as being structured, whether with 
  explicit markup such as XML or HTML, or internally structured such as in a word processor or 
  spreadsheet. In such a case, a segment is span of text that is distinguished in some way by the 
  structure.&nbsp; </p>
  <table border="0" cellspacing="0" cellpadding="4" class="noborder">
    <tr>
      <td valign="top" class="noborder">
      <p class="noborder"><i><a name="HL1">HL1</a>.</i></td>
      <td valign="top" class="noborder">
      <p><i>Override P3, and set the paragraph embedding level explicitly.</i></p>
      <ul>
        <li>
        A higher-level protocol may set the paragraph level explicitly and 
        ignore P3. This can be done on the basis of the context, such as on a table cell, paragraph, 
        document, or system level.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td valign="top" class="noborder"><i><a name="HL2">HL2</a>.</i></td>
      <td valign="top" class="noborder"><i>Override W2, and set EN or AN explicitly.</i>
      <ul>
        <li>A higher-level process may reset characters of type EN to AN, or vice versa, and ignore 
        W2. For example, style sheet or markup information can be used within a span of text to 
        override the setting of EN text to be always be AN, or vice versa.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td valign="top" class="noborder"><i><a name="HL3">HL3</a>.</i></td>
      <td valign="top" class="noborder"><i>Emulate directional overrides or embedding codes.</i>
      <ul>
        <li>A higher-level protocol can impose a directional override or embedding on a segment of 
        structured text. The behavior must always be defined by reference to what would happen if 
        the equivalent explicit codes as defined in the algorithm were inserted into the text. For 
        example, a style sheet or markup can set the embedding level on a span of text.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td valign="top" class="noborder"><i><a name="HL4">HL4</a>.</i></td>
      <td valign="top" class="noborder"><i>Apply the Bidirectional Algorithm to segments</i>.<ul>
        <li>The Bidirectional Algorithm can be applied independently to one or more segments of structured 
        text. For example, when displaying a document consisting of textual data and visible markup 
        in an editor, a higher-level process can handle syntactic elements in the markup separately 
        from the textual data.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td valign="top" class="noborder"><i><a name="HL5">HL5</a>.</i></td>
      <td valign="top" class="noborder"><i>Provide artificial context.</i>
      <ul>
        <li>Text can be processed by the Bidirectional Algorithm as if it were preceded by a character of a 
        given type and/or followed by a character of a given type. This allows a piece of text that 
        is extracted from a longer sequence of text to behave as it did in the larger context.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td valign="top" class="noborder"><i><a name="HL6">HL6</a>.</i></td>
      <td valign="top" class="noborder"><i>Additional mirroring</i>.<ul>
        <li>Characters with a resolved directionality of R that do not
 have the Bidi_Mirrored property can also be depicted by 
		a mirrored glyph in specialized contexts. Such contexts include, but are 
		not limited to, historic scripts and associated punctuation, private-use 
		characters, and characters in mathematical expressions. (See <span class="section">Section </span><span class="secno">6,</span><i> <a href="tr9-17.html#Mirroring">Mirroring</a></i>.)</li>
      </ul>
      </td>
    </tr>
  </table>
  <p>Clauses HL1 and HL3 are not logically necessary; they are covered by applications of clauses HL4 
  and HL5. However, they are included for clarity because they are more common operations.</p>
  <p>As an example of the application of HL4, suppose an XML document contains the following 
  fragment. (Note: This is a simplified example for illustration: element names, attribute names, 
  and attribute values could all be involved.)</p>
  <blockquote>
	<p><code style="font-size:86%">ARABICenglishARABIC&lt;e1 type=&#39;ab&#39;&gt;ARABICenglish&lt;e2 type=&#39;cd&#39;&gt;english</code></p>
	</blockquote>
  <p>This can be analyzed as being five different segments:</p>
  <ol type="a">
    <li><code style="font-size:86%">ARABICenglishARABIC</code></li>
    <li><code style="font-size:86%">&lt;e1 type=&#39;ab&#39;&gt;</code></li>
    <li><code style="font-size:86%">ARABICenglish</code></li>
    <li><code style="font-size:86%">&lt;e2 type=&#39;cd&#39;&gt;</code></li>
    <li><code style="font-size:86%">english</code></li>
  </ol>
  <p>To make the XML file readable as source text, the display in an editor 
	could order these elements all in a uniform direction (for example, all left-to-right) and apply the 
	Bidirectional Algorithm to each 
  field separately. It could also choose to order the element names, attribute names, and attribute 
  values uniformly in the same direction (for example, all left-to-right). For final display, the markup 
  could be ignored, allowing all of the text (segments a, c, and e) to be reordered together.</p>
  <p>When text using a higher-level protocol is to be converted to Unicode plain text, for 
  consistent appearance formatting codes should be inserted to ensure that the order matches that of 
  the higher-level protocol.</p>
  <h2 class="section">5 <a name="Implementation_Notes">Implementation Notes</a></h2>
  <h3 class="section">5.1 <a name="Reference_Code">Reference Code</a></h3>
  <p>There are two versions of BIDI reference code available. Both have been tested to 
  produce identical results. One version is written in Java, and the other is written in C++. The 
  Java version is designed to closely follow the steps of the algorithm as described below. The C++ 
  code is designed to show one of the optimization methods that can be applied to the algorithm, 
  using a state table for one phase.</p>
  <p>One of the most effective optimizations is to first test for right-to-left 
    characters and not invoke the Bidirectional Algorithm unless they are present.</p>
  <p>There are two directories containing source code for reference 
	implementations: <a href="BidiReferenceJava.1">BidiReferenceJava</a> 
  and <a href="BidiReferenceCpp.1">BidiReferenceCpp</a> [<a href="../tr41/tr41-1.html#Code9">Code9</a>]. Implementers are encouraged to use this 
  resource to test their implementations.</p>
  <h3 class="section">5.2  <a name="Retaining_Format_Codes">Retaining Format Codes</a></h3>
  <p>Some implementations may wish to retain the format codes when running the algorithm. The 
  following provides a summary of how this may be done. Note that this summary is an informative 
  implementation guideline; it should provide the same results as the explicit algorithm above, but 
  in case of any deviation the explicit algorithm is the normative statement for conformance. </p>
  <ul>
    <li>In rule X9, instead of removing the format codes, assign the embedding level to each 
    embedding character, and turn it into BN.</li>
    <li>In rule X10, assign L or R to the last of a sequence of adjacent BNs according to the 
	<i>eor</i> / 
    <i>sor</i>, and set the level to the higher of the two levels.</li>
    <li>In rule W1, search backward from each NSM to the first character in the level run whose 
    type is not BN, and set the NSM to its type. If the NSM is the first non-BN character, it will 
    get the type of <i>sor</i>.</li>
    <li>In rule W4, scan past BN types that are adjacent to ES or CS.</li>
    <li>In rule W5, change all appropriate sequences of ET and BN, not just ET.</li>
    <li>In rule W6, change all BN types adjacent to ET, ES, or CS to ON as well.</li>
    <li>In rule W7, scan past BN.</li>
    <li>In rules N1 and N2, treat BNs adjoining neutrals same as those neutrals.</li>
    <li>In rules I1 and I2, ignore BN.</li>
    <li>In rule L1, include format codes and BN together with whitespace characters in the sequences 
    whose level gets reset before a separator or line break. Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one, 
	and otherwise to the base level.</li>
  </ul>
  <p>Implementations that display visible representations of format characters 
	will want to adjust this process to position the format characters 
	optimally for editing.</p>
  <h3 class="section">5.3 <a name="Joiners">Joiners</a></h3>
  <p>As described under <a href="tr9-17.html#X9">X9</a>, the <i>zero width joiner</i> and
	<i>non-joiner</i> affect the 
  shaping of the adjacent characters—those that are adjacent in the original backing-store 
  order—even though those characters may end up being rearranged to be non-adjacent by the 
	Bidirectional Algorithm. To determine the joining behavior of a particular 
	character after applying the Bidirectional Algorithm, there are two main 
	strategies:</p>
  <ul>
    <li>When shaping, an implementation can refer back to the original backing store to see if there 
    were adjacent ZWNJ or ZWJ characters.</li>
    <li>Alternatively, the implementation can replace ZWJ and ZWNJ by an out-of-band character 
    property associated with those adjacent characters, so that the information does not interfere 
    with the Bidirectional Algorithm and the information is preserved across rearrangement of those 
    characters. Once the Bidirectional Algorithm has been applied, that out-of-band information can then be 
    used for proper shaping.</li>
  </ul>
  <h3 class="section">5.4 <a name="Vertical_Text">Vertical Text</a><a name="bk3"></a></h3>
  <p>In the case of vertical line orientation, the Bidirectional Algorithm is still used to 
  determine the levels of the text. However, these levels are not used to reorder the text, because 
  the characters are usually ordered uniformly from top to bottom. Instead, the levels are used to 
  determine the rotation of the text. Sometimes vertical lines follow a vertical baseline in which 
  each character is oriented as normal (with no rotation), with characters ordered from top to 
  bottom whether they are Hebrew, numbers, or Latin. When setting text using the Arabic script in 
  vertical lines, it is more common to employ a horizontal baseline that is rotated by 90° 
  counterclockwise so that the characters are ordered from top to bottom. Latin text and numbers may 
  be rotated 90° clockwise so that the characters are also ordered from top to bottom.</p>
  <p>The Bidirectional Algorithm is used when some characters are ordered from bottom 
  to top. For example, this happens with a mixture of Arabic and Latin glyphs when all the glyphs 
  are rotated uniformly 90° clockwise. The Unicode Standard does not specify 
	whether text is presented horizontally or vertically, or whether text is 
	rotated. That is left up to higher-level protocols.</p>
  <h3 class="section">5.5 <a name="Usage">Usage</a></h3>
  <p>Because of the implicit character types and the heuristics for resolving neutral and numeric 
  directional behavior, the implicit bidirectional ordering will generally produce the correct 
  display without any further work. However, problematic cases may occur when a right-to-left 
  paragraph begins with left-to-right characters, or there are nested segments of 
  different-direction text, or there are weak characters on directional boundaries. In these cases, 
  embeddings or directional marks may be required to get the right display. Part numbers may also 
  require directional overrides.</p>
  <p>The most common problematic case is that of neutrals on the boundary of an embedded language. 
  This can be addressed by setting the level of the embedded text correctly. For example, with all 
  the text at level 0 the following occurs:</p>
  <pre><b>Memory: </b> he said &quot;I NEED WATER!&quot;, and expired.

<b>Display:</b> he said &quot;RETAW DEEN I!&quot;, and expired.</pre>
  <p>If the exclamation mark is to be part of the Arabic quotation, then the user can select the 
  text <i>I NEED WATER!</i> and explicitly mark it as embedded Arabic, which produces the following 
  result:</p>
  <pre><b>Memory:</b>  he said &quot;<b>&lt;RLE&gt;</b>I NEED WATER!<b>&lt;PDF&gt;</b>&quot;, and expired.

<b>Display:</b> he said &quot;!RETAW DEEN I&quot;, and expired.</pre>
  <p>A simpler method of doing this is to place a right directional mark (RLM) after the exclamation 
  mark. Because the exclamation mark is now not on a directional boundary, this produces the correct 
  result.</p>
  <pre><b>Memory:</b>  he said &quot;I NEED WATER!<b>&lt;RLM&gt;</b>&quot;, and expired.

<b>Display:</b> he said &quot;!RETAW DEEN I&quot;, and expired.</pre>
  <p>This latter approach is preferred because it does not make use of the stateful format codes, 
  which can easily get out of sync if not fully supported by editors and other string manipulation. 
  The stateful format codes are generally needed only for more complex (and rare) cases such as 
  double embeddings, as in the following:</p>
  <pre><b>Memory:</b>  DID YOU SAY ‘<b>&lt;LRE&gt;</b>he said &quot;I NEED WATER!<b>&lt;RLM&gt;</b>&quot;, and expired.<b>&lt;PDF&gt;</b>’?

<b>Display:</b> ?‘he said &quot;!RETAW DEEN I&quot;, and expired.’ YAS UOY DID</pre>
  <h4>Migrating from 2.0 to 3.0</h4>
  <p>In the Unicode Character Database for [<a href="../tr41/tr41-1.html#Unicode3.0">Unicode3.0</a>], new 
	bidirectional character types were 
  introduced to make the body of the Bidirectional Algorithm depend only on the types of characters, and not on 
  the character values. The changes from the 2.0 bidirectional types are listed in 
	<i>Table 
	6</i>.</p>
	  <div class="book-only"><p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p></div>
  <div align="center">
    <center>
      <p class="caption">Table 6. <span style="font-weight: 400">New Bidirectional Types in Unicode 3.0</span></p>
    <table border="1" cellspacing="2" cellpadding="2">
      <tr>
        <th valign="TOP">Characters</th>
        <th valign="TOP">New Bidirectional Type</th>
      </tr>
      <tr>
        <td valign="TOP">All characters with General_Category Me, Mn</td>
        <td valign="TOP">NSM</td>
      </tr>
      <tr>
        <td valign="TOP">All characters of type R in the Arabic ranges (0600..06FF, FB50..FDFF, 
        FE70..FEFE)<br>
        (Letters in the Thaana and Syriac ranges also have this value.)</td>
        <td valign="TOP">AL</td>
      </tr>
      <tr>
        <td valign="TOP">The explicit embedding characters: LRO, RLO, LRE, RLE, PDF</td>
        <td valign="TOP">LRO, RLO, LRE, RLE, PDF, respectively</td>
      </tr>
      <tr>
        <td valign="TOP">Formatting characters and controls (General_Category Cf and Cc) that 
        were of bidirectional type ON</td>
        <td valign="TOP">BN</td>
      </tr>
      <tr>
        <td valign="TOP">Zero Width Space</td>
        <td valign="TOP">BN</td>
      </tr>
    </table>
    </center>
  </div>
  <p>Implementations that use older property tables can adjust to the modifications in the 
  Bidirectional Algorithm by algorithmically remapping the characters in <i>Table 6</i> to the new types.</p>
  <h2 class="section">6 <a name="Mirroring">Mirroring</a></h2>
  <p>The mirrored property is important to ensure that the correct character codes are used for the 
  desired semantic. This is of particular importance where the name of a character does not indicate 
  the intended semantic, such as with U+0028 “(” <span class="name">LEFT PARENTHESIS</span>. While the name 
  indicates that it is a left parenthesis, the character really expresses an <i>open parenthesis</i>—the <i>leading</i> character in a parenthetical phrase, not the trailing one.</p>
  <p>Some of the characters that do not have the Bidi_Mirrored property 
	may be rendered with mirrored glyphs, according to a higher level 
	protocol that adds 
  mirroring: see <span class="section">Section </span><span class="secno">4.3,</span>
  <i><a href="tr9-17.html#Higher-Level_Protocols">Higher-Level Protocols</a></i>, especially
	<a href="tr9-17.html#HL6">HL6</a>. Except in such cases, mirroring must be done 
	according to rule <a href="tr9-17.html#L4">L4</a>, to ensure that the correct character 
	code is used to express the intended semantic of the character, 
	and to avoid interoperability and security problems.</p>
  <p>Implementing rule <a href="tr9-17.html#L4">L4</a> calls for mirrored glyphs. These glyphs may not be exact
  <i>graphical</i> mirror images. For example, clearly an italic parenthesis is not 
  an exact mirror image of another— “<i>(</i>” is not the mirror image of “<i>)</i>”. 
  Instead, mirror glyphs are those acceptable as mirrors within the normal parameters of the font in 
  which they are represented.</p>
  <p>In implementation, sometimes pairs of characters are acceptable mirrors for one 
  another—for example, U+0028 “(” <span class="name">LEFT PARENTHESIS</span> and U+0029 
	“)” 
  <span class="name">RIGHT PARENTHESIS</span> or U+22E0 “⋠” <span class="name">DOES NOT PRECEDE OR EQUAL</span> and
  U+22E1 “⋡” <span class="name">DOES NOT SUCCEED OR EQUAL</span>. Other characters such as 
  U+2231 “∱” <span class="name">CLOCKWISE INTEGRAL</span> do not have corresponding characters that can be 
  used for acceptable mirrors. The informative Bidi Mirroring data file <a href="../tr41/tr41-1.html#Data9">[Data9]</a>, 
  lists the paired characters with acceptable mirror glyphs. A comment in the file indicates where 
  the pairs are “best fit”: they should be acceptable in rendering, although ideally the mirrored 
  glyphs may have somewhat different shapes.</p>
    <div class="book-only"><p>&nbsp;</p></div>
  <h2 class="nonumber"><a name="Acknowledgements">Acknowledgments</a></h2>
  <div class="book-only">
  <p>Mark Davis is the author of the initial version and has added to and 
	maintained the text of this annex.</p></div>
	<p>Thanks to the following people for their contributions to the Bidirectional 
	Algorithm or for 
  their feedback on earlier versions of this annex: Alaa Ghoneim (علاء غنيم), Ahmed Talaat (أحمد 
  طلعت), Asmus Freytag, Avery Bishop, Behdad Esfahbod (بهداد اسفهبد), Doug Felt, Eric Mader,
  Ernest Cline, Gidi Shalom-Bendor (גידי שלום-בן דור), Isai Scheinberg, Israel Gidali (ישראל 
  גידלי), Joe Becker, John McConnell, Jonathan Kew, Jonathan Rosenne (יונתן רוזן), Khaled Sherif (خالد 
  شريف), Kamal Mansour (كمال منصور), Kenneth Whistler, Maha Hassan (مها حسن), Markus Scherer, Martin 
  Dürst, Mati Allouche (מתתיהו &nbsp;אלוש), Michel Suignard, Mike Ksar (<span lang="AR-JO">ميشيل 
  قصار</span>), Murray Sargent, Paul Nelson, Rick McGowan, Roozbeh Pournader (روزبه پورنادر), 
  Steve Atkin, and Thomas Milo (تُومَاسْ مِيلُو).</p>
  <h2 class="nonumber"><a name="References">References</a></h2>
	<p>For references for this annex, see Unicode Standard Annex #41, “<a href="../tr41/tr41-1.html">Common 
	References for Unicode Standard Annexes</a>.”</p>
<h2 class="nonumber"><a name="Modifications">Modifications</a></h2>
		<!-- BOOK ONLY -->
	<div class="book-only">
	<p>For details of the change history, see the online copy of this annex at http://www.unicode.org/reports/tr9/.</p>
	</div>
	<!-- START WEB ONLY -->
	<div class="web-only">
  <p>The following summarizes modifications from previous revisions of this 
	annex.</p>

	<h3>Revision 17</h3>
	<ul>
    <li>This revision incorporates successive changes. 
	The latest changes were on 2006-02-24.</li>
	<li>Modified <a href="tr9-17.html#L4">L4</a> and <a href="tr9-17.html#HL6">HL6</a>, in conjunction with proposed 
    property change to Bidi_Mirrored (<a href="http://www.unicode.org/review/resolved-pri.html#pri80">PRI #80</a>)
    </li>
	<li>Added note on U+ FD3E (﴾) ORNATE LEFT 
	PARENTHESIS and U+ FD3F (﴿) ORNATE RIGHT PARENTHESIS.</li>
	<li>Used new format for conformance clause 
	numbering.</li>
	<li>Added caution on use of higher-level 
	protocols, after <a href="tr9-17.html#C2">UAX9-C2</a>.</li>
	<li>Some wording changes in 6&nbsp; <a href="tr9-17.html#Mirroring">Mirroring</a>, 
	for consistency with new L4 and HL6.</li>
	<li>Moved text to
	<a href="tr9-17.html#Shaping_and_line_breaking">Shaping_and_line_breaking</a>, and 
	added note on SHY in 3.4 there</li>
	<li>Removed two notes indicating that the conformance clauses override clause 
	C13 of Unicode 4.0. </li>
	<li>Changed some references to Unicode4.0</li>
  </ul>
  <p>Revision 16 being a proposed update, only changes between versions 17 and 
	15 are noted here.</p>
  <h3><b>Revision <a name="TrackingNumber15">15</a></b>:</h3>
  <ul>
    <li>Minor editing</li>
    <li>Fixed section Number for Mirroring</li>
    <li>Changed “Tracking Number” to Revision</li>
    <li>Added note on U+0CBF KANNADA VOWEL SIGN I</li>
    <li>Added note after N1, and clarified example after N2.</li>
    <li>Fixed references to sections of the Unicode Standard</li>
  </ul>
  <h3><b>Revision</b> <a name="TrackingNumber14">14</a>:</h3>
  <ul>
    <li>Aliased directional run and level run</li>
    <li>Pointed to DerivedBidiClass.txt for unassigned character assignments.</li>
  </ul>
  <h3><b>Revision</b> <a name="TrackingNumber13">13</a>:</h3>
  <ul>
    <li><a href="tr9-17.html#Bidirectional_Conformance">4. Bidirectional Conformance</a>: added explicit 
    clauses.</li>
    <li><a href="tr9-17.html#Higher-Level_Protocols">4.3. Higher-Level Protocols</a>:
    <ul>
      <li>Added clarifying text, and renumbered options.</li>
      <li>Removed option regarding number shaping (because it was irrelevant to bidirectional 
      ordering).</li>
      <li>Broadened the ability to override on the basis of context, and clarified number handling.</li>
      <li>Made clear that bidi could be applied to segments</li>
    </ul>
    </li>
    <li><a href="tr9-17.html#3.1_Bidirectional_Behavior">1. Introduction</a>: added note that the changes in
    <a href="tr9-17.html#Bidirectional_Conformance">4. Bidirectional Conformance</a> override clause C13 of 
    Unicode 4.0 [<a href="../tr41/tr41-1.html#Unicode">Unicode</a>], and tighten the conformance requirements from what 
    they had been previously.</li>
    <li>Minor editing for clarification.</li>
  </ul>
  <h3><b>Revision</b> <a name="TrackingNumber11">11</a>:</h3>
  <ul>
    <li>Updated for Unicode 4.0.</li>
    <li>Added note on <a href="tr9-17.html#canonical_equivalence">canonical equivalence</a></li>
    <li>Added <a href="tr9-17.html#Joiners">Joiners</a> section on ZWJ and ZWNJ</li>
    <li>Clarified <a href="tr9-17.html#L2">L2</a> and examples following.</li>
    <li>Added a section on the interaction of <a href="tr9-17.html#Shaping">shaping</a> and bidirectional 
    reordering.</li>
    <li>Moved lists for unassigned characters into UCD.html (also now explicit in 
    DerivedBidiClass.txt)</li>
    <li>Updated references for Newline Guidelines (because the UAX is incorporated into the 4.0 book)</li>
    <li>The first two sections were rearranged, with <a href="tr9-17.html#Reference_Code">Reference Code</a> 
    going into <a href="tr9-17.html#Implementation_Notes">Implementation Notes</a>, and <a href="tr9-17.html#Mirroring">
    Mirroring</a> in its own section at the end.
    <ul>
      <li>This is <i>not</i> highlighted in the proposed text.</li>
    </ul>
    </li>
    <li>Sections were renumbered and the table of contents is more detailed.
    <ul>
      <li>This is <i>not</i> highlighted in the proposed text.</li>
    </ul>
    </li>
    <li>Misc editing.</li>
  </ul>
  <h3><b>Revision</b> <a name="TrackingNumber10">10</a>:</h3>
  <ul>
    <li>Updated for Unicode 3.2.</li>
    <li>Updated UAX boilerplate in the status section.</li>
  </ul>
  <h3><b>Revision</b> <a name="TrackingNumber9">9</a>:</h3>
  <ul>
    <li>Clarified the language of <a href="tr9-17.html#P2">P2</a></li>
    <li>Corrected the implementation note on “Retaining Format Codes” in
    <a href="tr9-17.html#Implementation_Notes">Implementation Notes</a></li>
    <li>Minor editing</li>
  </ul>
  <hr>
  <p class="copyright">Copyright © 2000-2006 Unicode, Inc. All Rights Reserved. The 
  Unicode Consortium makes no expressed or implied warranty of any kind, and assumes no liability 
  for errors or omissions. No liability is assumed for incidental and consequential damages in 
  connection with or arising out of the use of the information or programs contained or accompanying 
  this technical report. The Unicode <a href="http://www.unicode.org/copyright.html">Terms of Use</a> 
  apply.</p>
  <p class="copyright">Unicode and the Unicode logo are trademarks of Unicode, Inc., and are 
  registered in some jurisdictions.</div> <!-- WEB ONLY -->
  </div> <!-- BODY -->
  </div> <!-- BOOK -->
</body>
</html>
