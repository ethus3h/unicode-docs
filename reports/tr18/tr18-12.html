<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<link rel="stylesheet" href="../../unicode/reports/reports.css" type="text/css">
<title>UTS #18: Unicode Regular Expressions</title>
<style type="text/css">
<!--
.rule_head, .rule_body { font-style: italic; border-width: 0 }
span.regex   { font-family: monospace; font-weight:bold }
.rule_head   { font-weight: bold }
-->
</style>
</head>

<body bgcolor="#ffffff">

<table class="header" width="100%">
  <tr>
    <td class="icon"><a href="http://www.unicode.org"><img align="middle" alt="[Unicode]" border="0" src="../../webscripts/logo60s2.gif" width="34" height="33"></a>&nbsp; <a class="bar" href="../index.html">Technical Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>
</table>
<div class="body">
  <h2 align="center"><span class="changedspan">Proposed Update </span>Unicode Technical <span>Standard </span>#18</h2>
  <h1 align="right">Unicode Regular Expressions</h1>
  <table class="wide" border="1" width="95%">
    <tr>
      <td width="20%">Version</td>
      <td><span class="changedspan"><span>1</span>2<font color="#FF0000"> (draft 3)</font></span></td>
    </tr>
    <tr>
      <td>Authors</td>
      <td>Mark Davis<span class="changedspan">, Andy Heninger</span></td>
    </tr>
    <tr>
      <td>Date</td>
      <td><span>200<span class="changedspan">8-05-01</span></span></td>
    </tr>
    <tr>
      <td>This Version</td>
      <td><span><a href="tr18-12.html">http://www.unicode.org/reports/tr18/tr18-12.html</a></span></td>
    </tr>
    <tr>
      <td>Previous Version</td>
      <td><span><a href="tr18-11.html">http://www.unicode.org/reports/tr18/tr18-11.html</a></span></td>
    </tr>
    <tr>
      <td>Latest Version</td>
      <td><a href="../tr18.1">http://www.unicode.org/reports/tr18/</a></td>
    </tr>
    <tr>
      <td>Revision</td>
      <td><span class="changedspan"><a href="tr18-12.html#Modifications">12</a></span></td>
    </tr>
  </table>
  <p><br>
  </p>
  <h3><i>Summary</i></h3>
  <p><i><em>This document describes guidelines for how to adapt regular expression engines to use Unicode.</em></i></p>
  <h3><i>Status</i></h3>
  <p><span class="removedspan"><i>This document has been reviewed by Unicode members and other interested parties, and has been approved by the Unicode Technical Committee as a <b>Unicode Technical Standard</b>. This is a stable document and may be used as reference material or cited as a normative 
  reference by other specifications.</i></span><span class="changedspan"><i><br>
  This is a<b><font color="#ff3333"> draft </font></b>document which may be updated, replaced, or superseded by other documents at any time. Publication does not imply endorsement by the Unicode Consortium.&nbsp; This is not a stable document; it is inappropriate to cite this document as other than 
  a work in progress.</i> </span></p>
  <blockquote>
    <p><i>A <b>Unicode Technical Standard (UTS)</b> is an independent specification. Conformance to the Unicode Standard does not imply conformance to any UTS.</i></p>
  </blockquote>
  <p><i>Please submit corrigenda and other comments with the online reporting form [<a href="tr18-12.html#Feedback">Feedback</a>]. Related information that is useful in understanding this document is found in [<a href="tr18-12.html#References">References</a>]. For the latest version of the Unicode Standard see [<a 
  href="tr18-12.html#Unicode">Unicode</a>]. For a list of current Unicode Technical Reports see [<a href="tr18-12.html#Reports">Reports</a>]. For more information about versions of the Unicode Standard, see [<a href="tr18-12.html#Versions">Versions</a>].</i></p>
  <h3><i>Contents</i></h3>
  <ul class="toc">
    <li>0 <a href="tr18-12.html#Introduction">Introduction</a>
    <ul class="toc">
      <li>0.1 <a href="tr18-12.html#Notation">Notation</a></li>
      <li>0.2 <a href="tr18-12.html#Conformance">Conformance</a></li>
    </ul>
    </li>
    <li>1 <a href="tr18-12.html#Basic_Unicode_Support">Basic Unicode Support: Level 1</a>
    <ul class="toc">
      <li>1.1 <a href="tr18-12.html#Hex_notation">Hex notation</a></li>
      <li>1.2 <a href="tr18-12.html#Categories">Properties</a></li>
      <li>1.3 <a href="tr18-12.html#Subtraction_and_Intersection">Subtraction and Intersection</a></li>
      <li>1.4 <a href="tr18-12.html#Simple_Word_Boundaries">Simple Word Boundaries</a></li>
      <li>1.5 <a href="tr18-12.html#Simple_Loose_Matches">Simple Loose Matches</a></li>
      <li>1.6 <a href="tr18-12.html#Line_Boundaries">Line Boundaries</a></li>
      <li>1.7 <a href="tr18-12.html#Supplementary_Characters">Code Points</a></li>
    </ul>
    </li>
    <li>2 <a href="tr18-12.html#Extended_Unicode_Support">Extended Unicode Support: Level 2</a>
    <ul class="toc">
      <li>2.1 <a href="tr18-12.html#Canonical_Equivalents">Canonical Equivalents</a></li>
      <li>2.2 <a href="tr18-12.html#Default_Grapheme_Clusters">Extended Grapheme Clusters</a></li>
      <li>2.3 <a href="tr18-12.html#Default_Word_Boundaries">Default Word Boundaries</a></li>
      <li>2.4 <a href="tr18-12.html#Default_Loose_Matches">Default Loose Matches</a></li>
      <li>2.5 <a href="tr18-12.html#Name_Properties">Name Properties</a></li>
      <li>2.6 <a href="tr18-12.html#Wildcard_Properties">Wildcards in Property Values</a></li>
    </ul>
    </li>
    <li>3 <a href="tr18-12.html#Tailored_Support">Tailored Support: Level 3</a>
    <ul class="toc">
      <li>3.1 <a href="tr18-12.html#Tailored_Properties">Tailored Punctuation</a></li>
      <li>3.2 <a href="tr18-12.html#Tailored_Graphemes_Clusters">Tailored Grapheme Clusters</a></li>
      <li>3.3 <a href="tr18-12.html#Tailored_Word_Boundaries">Tailored Word Boundaries</a></li>
      <li>3.4 <a href="tr18-12.html#Tailored_Loose_Matches">Tailored Loose Matches</a></li>
      <li>3.5 <a href="tr18-12.html#Tailored_Ranges">Tailored Ranges</a></li>
      <li>3.6 <a href="tr18-12.html#Context_Matching">Context Matching</a></li>
      <li>3.7 <a href="tr18-12.html#Partial_Matches">Incremental Matches</a></li>
      <li>3.8 <a href="tr18-12.html#Unicode_Set_Sharing">Unicode Set Sharing</a></li>
      <li>3.9 <a href="tr18-12.html#Possible_Match_Sets">Possible Match Sets</a></li>
      <li>3.10 <a href="tr18-12.html#Folded_Matching">Folded Matching</a></li>
      <li>3.11 <a href="tr18-12.html#Submatchers">Submatchers</a></li>
    </ul>
    </li>
    <li>Annex A <a href="tr18-12.html#Character_Blocks">Character Blocks</a></li>
    <li>Annex B <a href="tr18-12.html#Sample_Collation_Character_Code">Sample Collation Character Code</a></li>
    <li>Annex C <a href="tr18-12.html#Compatibility_Properties">Compatibility Properties</a></li>
    <li><a href="tr18-12.html#References">References</a></li>
    <li><a href="tr18-12.html#Acknowledgments">Acknowledgments</a></li>
    <li><a href="tr18-12.html#Modifications">Modifications</a></li>
  </ul>
  <hr>
  <h2>0 <a name="Introduction">Introduction</a></h2>
  <p>The following describes general guidelines for extending regular expression engines (Regex) to handle Unicode. The following issues are involved in such extensions.</p>
  <ul>
    <li>Unicode is a large character set—regular expression engines that are only adapted to handle small character sets will not scale well. </li>
    <li>Unicode encompasses a wide variety of languages which can have very different characteristics than English or other western European text. </li>
  </ul>
  <p>There are three fundamental levels of Unicode support that can be offered by regular expression engines:</p>
  <ul>
    <li><b><a href="tr18-12.html#Basic_Unicode_Support">Level 1</a>: Basic Unicode Support. </b>At this level, the regular expression engine provides support for Unicode characters as basic logical units. (This is independent of the actual serialization of Unicode as UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, or 
    UTF-32LE.) This is a minimal level for useful Unicode support. It does not account for end-user expectations for character support, but does satisfy most low-level programmer requirements. The results of regular expression matching at this level are independent of country or language. At this 
    level, the user of the regular expression engine would need to write more complicated regular expressions to do full Unicode processing.</li>
    <li><b><a href="tr18-12.html#Extended_Unicode_Support">Level 2</a>: Extended Unicode Support. </b>At this level, the regular expression engine also accounts for extended grapheme clusters (what the end-user generally thinks of as a character), better detection of word boundaries, and canonical equivalence. 
    This is still a default level—independent of country or language—but provides much better support for end-user expectations than the raw level 1, without the regular-expression writer needing to know about some of the complications of Unicode encoding structure.</li>
    <li><b><a href="tr18-12.html#Tailored_Support">Level 3</a>: Tailored Support. </b>At this level, the regular expression engine also provides for tailored treatment of characters, including country- or language-specific behavior. For example, the characters <i>ch</i> can behave as a single character in 
    Slovak or traditional Spanish. The results of a particular regular expression reflect the end-users&#39; expectations of what constitutes a character in their language, and the order of the characters. However, there is a performance impact to support at this level.</li>
  </ul>
  <p><span class="changedspan">In particular:</span></p>
  <ol>
    <li><span class="changedspan">Level 1 is the minimally useful level of support for Unicode. All regex implementations dealing with Unicode should be at least at Level 1.</span></li>
    <li><span class="changedspan">Level 2 is recommended for implementations that need to handle additional Unicode features. This level is achievable without too much effort. However, some of the subitems in Level 2 are more important than others: see <a href="tr18-12.html#Extended_Unicode_Support">Level 2</a>.</span></li>
    <li><span class="changedspan">Level 3 contains information about extensions only useful for specific applications. Features at this level may require further investigation for effective implementation. </span></li>
  </ol>
  <p>One of the most important requirements for a regular expression engine is to document clearly what Unicode features are and are not supported. Even if higher-level support is not currently offered, provision should be made for the syntax to be extended in the future to encompass those features.</p>
  <blockquote>
    <p><b><i>Note: </i></b><i>Unicode is a constantly evolving standard: new characters will be added in the future. This means that a regular expression that tests for currency symbols, for example, has different results in Unicode 2.0 than in Unicode 2.1, where the Euro currency symbol was added.</i></p>
  </blockquote>
  <p>At any level, efficiently handling properties or conditions based on a large character set can take a lot of memory. A common mechanism for reducing the memory requirements — while still maintaining performance — is the two-stage table, discussed in Chapter 5 of <i>The Unicode Standard </i>[<a 
  href="tr18-12.html#Unicode">Unicode</a>]. For example, the Unicode character properties required in <a href="tr18-12.html#Categories">RL1.2 Properties</a> can be stored in memory in a two-stage table with only 7 or 8 Kbytes. Accessing those properties only takes a small amount of bit-twiddling and two array accesses.</p>
  <blockquote>
    <p><i><b>Note: </b>For ease of reference, the section ordering for this document is intended to be as stable as possible over successive versions. That may lead, in some cases, to the ordering of the sections being less than optimal.</i></p>
  </blockquote>
  <h3>0.1 <a name="Notation">Notation</a></h3>
  <p>In order to describe regular expression syntax, an extended BNF form is used:</p>
  <table class="syntax">
    <tr>
      <td style="text-align: center"><code>x y</code></td>
      <td>the sequence consisting of x then y</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>x*</code></td>
      <td>zero or more occurrences of x</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>x?</code></td>
      <td>zero or one occurrence of x</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>x | y</code></td>
      <td>either x or y</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>( x )</code></td>
      <td>for grouping</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>&quot;XYZ&quot;</code></td>
      <td>terminal character(s)</td>
    </tr>
  </table>
  <p>The following syntax for character ranges will be used in successive examples.</p>
  <blockquote>
    <p>Note: <i>This is only a <b>sample</b> syntax for the purposes of examples in this document.</i> Regular expression syntax varies widely: the issues discussed here would need to be adapted to the syntax of the particular implementation. However, it is important to have a concrete syntax to 
    correctly illustrate the different issues. In general, the syntax here is similar to that of <a href="http://www.perl.com/pub/q/documentation">Perl Regular Expressions</a> [<a href="tr18-12.html#Perl">Perl</a>].) In some cases, this gives multiple syntactic constructs that provide for the same 
    functionality.</p>
  </blockquote>
  <table class="syntax">
    <tr>
      <td width="100%">
      <pre>LIST := &quot;[&quot; NEGATION? ITEM (SEP? ITEM)* &quot;]&quot;
ITEM := CODE_POINT2
     := CODE_POINT2 &quot;-&quot; CODE_POINT2 // range

CODE_POINT2 := ESCAPE CODE_POINT
            := CODE_POINT

NEGATION := &quot;^&quot;
SEP := &quot;&quot;   // no separator = union 
    := &quot;|<span class="changedspan">|</span>&quot; // union
ESCAPE := &quot;\&quot;</pre>
      </td>
    </tr>
  </table>
  <p>CODE_POINT refers to any Unicode code point from U+0000 to U+10FFFF, although typically the only ones of interest will be those representing characters. Whitespace is allowed between any elements, but to simplify the presentation the many occurrences of &quot; &quot;* are omitted.</p>
  <p>Code points that are syntax characters or whitespace are typically escaped. For more information see [<a href="tr18-12.html#Syntax">Syntax</a>]. In examples, the syntax \s to mean white space is sometimes used. See also <a href="tr18-12.html#Compatibility_Properties">Annex C. Compatibility Properties</a>.</p>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><span class="regex">[a-z |</span><span class="changedspan"><span class="regex">|</span></span><span class="regex"> A-Z |</span><span class="changedspan"><span class="regex">|</span></span><span class="regex"> 0-9]</span></td>
      <td rowspan="3">Match ASCII alphanumerics</td>
    </tr>
    <tr>
      <td><span class="regex">[a-z A-Z 0-9]</span></td>
    </tr>
    <tr>
      <td><span class="regex">[a-zA-Z0-9]</span></td>
    </tr>
    <tr>
      <td><span class="regex">[^a-z A-Z 0-9]</span></td>
      <td>Match anything but ASCII alphanumerics</td>
    </tr>
    <tr>
      <td><span class="regex">[\] \- \ ]</span></td>
      <td>Match the literal characters ], -, &lt;space&gt;</td>
    </tr>
  </table>
  <p>Where string offsets are used in examples, they are from zero to n (the length of the string), and indicate positions <i>between</i> characters. Thus in &quot;abcde&quot;, the substring from 2 to 4 includes the two characters &quot;cd&quot;.</p>
  <p>T<span>he following notation is defined for use here and in other Unicode documents:</span></p>
  <table class="syntax">
    <tr>
      <td><span><span class="regex">\n</span></span></td>
      <td><span>As used within regular expressions, expands to the text matching the <b>n</b>th parenthesized group in regular expression. (<font size="3">à</font> la Perl). Note that most</span> engines limit n to be [1-9]; thus \456 would be the reference to the 4th group followed by the literal 
      &#39;56&#39;.</td>
    </tr>
    <tr>
      <td><span><span class="regex">$n</span></span></td>
      <td><span>As used within replacement strings for regular expressions, expands to the text matching the <b>n</b>th parenthesized group in a corresponding regular expression. The value of $0 is the entire expression.(<font size="3"> à</font> la Perl)</span></td>
    </tr>
    <tr>
      <td><span><span class="regex">$xyz</span></span></td>
      <td><span>As used within regular expressions or replacement strings, expands to an assigned variable value. The &#39;xyz&#39; is of the form of an identifier. For example, given <span class="regex">$greek_lower = [[:greek:]</span></span><span class="regex">&amp;<span class="changedspan">&amp;</span></span><span><span 
      class="regex">[:lowercase:]]</span>, the regular expression pattern &quot;<span class="regex">ab$greek_lower</span>&quot; is equivalent to &quot;<span class="regex">ab[[:greek:]</span></span><span class="regex">&amp;<span class="changedspan">&amp;</span></span><span><span class="regex">[:lowercase:]]</span>&quot;.</span></td>
    </tr>
  </table>
  <blockquote>
    <p><span><b>Note: </b>Because any character could occur as a literal in a regular expression, when regular expression syntax is embedded within other syntax it can be difficult to determine where the end of the regex expression is. Common practice is to allow the user to choose a delimiter like 
    &#39;/&#39; in /ab(c)*/. The user can then simply choose a delimiter that is not in the particular regular expression.</span></p>
  </blockquote>
  <h3>0.2 <a name="Conformance">Conformance</a></h3>
  <p>The following describes the possible ways that an implementation can claim conformance to this technical standard.</p>
  <p>All syntax and API presented in this document is <i>only</i> for the purpose of illustration; there is absolutely no requirement to follow such syntax or API. Regular expression syntax varies widely: the features discussed here would need to be adapted to the syntax of the particular 
  implementation. In general, the syntax in examples is similar to that of <a href="http://www.perl.com/pub/q/documentation">Perl Regular Expressions</a> [<a href="tr18-12.html#Perl">Perl</a>], but it may not be exactly the same. While the API examples generally follow
  <a href="http://java.sun.com/j2se/1.4.1/docs/api/java/util/regex/package-summary.html">Java style</a>, it is again <i>only</i> for illustration.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head"><a name="C0">C0</a>.</td>
      <td class="rule_body">An implementation claiming conformance to this specification at any Level shall identify the version of this specification and the version of the Unicode Standard.<br>
&nbsp;</td>
    </tr>
  </table>
  <table class="noborder">
    <tr>
      <td class="rule_head"><a name="C1">C1</a>.</td>
      <td class="rule_body">An implementation claiming conformance to Level 1 of this specification shall meet the requirements described in the following sections:</td>
    </tr>
  </table>
  <blockquote>
    <dl>
      <dd><a href="tr18-12.html#Hex_notation">RL1.1 Hex Notation</a></dd>
      <dd><a href="tr18-12.html#Categories">RL1.2 Properties</a><br>
      <span><a href="tr18-12.html#Categories">RL1.2a Compatibility Properties</a></span></dd>
      <dd><a href="tr18-12.html#Subtraction_and_Intersection">RL1.3 Subtraction and Intersection</a></dd>
      <dd><a href="tr18-12.html#Simple_Word_Boundaries">RL1.4 Simple Word Boundaries</a></dd>
      <dd><a href="tr18-12.html#Simple_Loose_Matches">RL1.5 Simple Loose Matches</a></dd>
      <dd><a href="tr18-12.html#Line_Boundaries">RL1.6 Line Boundaries</a></dd>
      <dd><a href="tr18-12.html#Supplementary_Characters">RL1.7 Supplementary Code Points</a></dd>
    </dl>
  </blockquote>
  <table class="noborder">
    <tr>
      <td class="rule_head"><a name="C2">C2</a>.</td>
      <td class="rule_body">An implementation claiming conformance to Level 2 of this specification shall satisfy C1, and meet the requirements described in the following sections:</td>
    </tr>
  </table>
  <blockquote>
    <dl>
      <dd><a href="tr18-12.html#Canonical_Equivalents">RL2.1 Canonical Equivalents</a></dd>
      <dd><a href="tr18-12.html#Default_Grapheme_Clusters">RL2.2 Extended Grapheme Clusters</a></dd>
      <dd><a href="tr18-12.html#Default_Word_Boundaries">RL2.3 Default Word Boundaries</a></dd>
      <dd><a href="tr18-12.html#Default_Loose_Matches">RL2.4 Default Loose Matches</a></dd>
      <dd><a href="tr18-12.html#Name_Properties">RL2.5 Name Properties</a></dd>
      <dd><a href="tr18-12.html#Wildcard_Properties">RL2.6 Wildcards in Property Values</a></dd>
    </dl>
  </blockquote>
  <table class="noborder">
    <tr>
      <td class="rule_head"><a name="C3">C3</a>.</td>
      <td class="rule_body">An implementation claiming conformance to Level 3 of this specification shall satisfy C1 and C2, and meet the requirements described in the following sections:</td>
    </tr>
  </table>
  <blockquote>
    <dl>
      <dd><a href="tr18-12.html#Tailored_Properties">RL3.1 Tailored Punctuation</a></dd>
      <dd><a href="tr18-12.html#Tailored_Graphemes_Clusters">RL3.2 Tailored Grapheme Clusters</a></dd>
      <dd><a href="tr18-12.html#Tailored_Word_Boundaries">RL3.3 Tailored Word Boundaries</a></dd>
      <dd><a href="tr18-12.html#Tailored_Loose_Matches">RL3.4 Tailored Loose Matches</a></dd>
      <dd><a href="tr18-12.html#Tailored_Ranges">RL3.5 Tailored Ranges</a></dd>
      <dd><a href="tr18-12.html#Context_Matching">RL3.6 Context Matching</a></dd>
      <dd><a href="tr18-12.html#Partial_Matches">RL3.7 Incremental Matches</a></dd>
      <dd><a href="tr18-12.html#Possible_Match_Sets">RL3.9 Possible Match Sets</a></dd>
      <dd><a href="tr18-12.html#Folded_Matching">RL3.10 Folded Matching</a></dd>
      <dd><a href="tr18-12.html#Submatchers">RL3.11 Submatchers</a></dd>
      <dt>&nbsp;</dt>
    </dl>
  </blockquote>
  <table class="noborder">
    <tr>
      <td class="rule_head"><a name="C4">C4</a>.</td>
      <td class="rule_body">An implementation claiming <i>partial</i> conformance to this specification shall clearly indicate which levels are completely supported (C1-C3), plus any additional supported features from higher levels.</td>
    </tr>
  </table>
  <blockquote>
    <p>For example, an implementation may claim conformance to Level 1, plus <a href="tr18-12.html#Context_Matching">Context Matching</a>, and <a href="tr18-12.html#Partial_Matches">Incremental Matches</a>. Another implementation may claim conformance to Level 1, except for <a href="tr18-12.html#Subtraction_and_Intersection">
    Subtraction and Intersection</a>.</p>
  </blockquote>
  <p><b>Notes:</b></p>
  <ul>
    <li>A regular expression engine may be operating in the context of a larger system. In that case some of the requirements may be met by the overall system. For example, the requirements of Section <a href="tr18-12.html#Canonical_Equivalents">2.1 Canonical Equivalents</a> might be best met by making 
    normalization available as a part of the larger system, and requiring users of the system to normalize strings where desired before supplying them to the regular-expression engine. Such usage is conformant, as long as the situation is clearly documented.</li>
    <li>A conformance claim may also include capabilities added by an optional add-on, such as an optional library module, as long as this is clearly documented.</li>
    <li>For backwards compatibility, some of the functionality may only be available if some special setting is turned on. None of the conformance requirements require the functionality to be available by default.</li>
  </ul>
  <h2><a name="Basic_Unicode_Support">1 Basic Unicode Support</a>: <a name="Level_1">Level 1</a></h2>
  <p>Regular expression syntax usually allows for an expression to denote a set of single characters, such as <span class="regex">[a-z A-Z 0-9]</span>. Because there are a very large number of characters in the Unicode standard, simple list expressions do not suffice.</p>
  <h3><a name="Hex_notation">1.1 Hex notation</a></h3>
  <p>The character set used by the regular expression writer may not be Unicode, or may not have the ability to input all Unicode code points from a keyboard.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.1</td>
      <td class="rule_head">Hex Notation</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall supply a mechanism for specifying any Unicode code point (from U+0000 to U+10FFFF).</td>
    </tr>
  </table>
  <p>A sample notation for listing hex Unicode characters within strings is by prefixing four hex digits with &quot;\u&quot; and prefixing eight hex digits with &quot;\U&quot;. This would provide for the following addition:</p>
  <table class="syntax">
    <tr>
      <td width="100%">
      <pre>&lt;codepoint&gt; := &lt;character&gt;
&lt;codepoint&gt; := ESCAPE U_SHORT_MARK
               HEX_CHAR HEX_CHAR HEX_CHAR HEX_CHAR

&lt;codepoint&gt; := ESCAPE U_LONG_MARK
               HEX_CHAR HEX_CHAR HEX_CHAR HEX_CHAR
               HEX_CHAR HEX_CHAR HEX_CHAR HEX_CHAR

U_SHORT_MARK := &quot;u&quot;
U_LONG_MARK := &quot;U&quot;</pre>
      </td>
    </tr>
  </table>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><span class="regex">[\u3040-\u309F \u30FC]</span></td>
      <td>Match Hiragana characters, plus prolonged sound sign</td>
    </tr>
    <tr>
      <td><span class="regex">[\u00B2 \u2082]</span></td>
      <td>Match superscript and subscript 2</td>
    </tr>
    <tr>
      <td><span class="regex">[a \U00010450]</span></td>
      <td>Match &quot;a&quot; or U+10450 SHAVIAN LETTER PEEP</td>
    </tr>
  </table>
  <ul>
    <li><b>Note:</b> instead of <span class="regex">[...\u3040...]</span>, an alternate syntax is <span class="regex">[...\x{3040}...]</span>, as in Perl 5.6 and later.</li>
    <li><b>Note: </b>more advanced regular expression engines can also offer the ability to use the Unicode character name for readability. See <a href="tr18-12.html#Name_Properties">2.5 Name Properties</a>.</li>
  </ul>
  <h4>1.1.1 Hex Notation and Normalization</h4>
  <p><span class="changedspan">The Unicode Standard treats certain sequences of characters as equivalent, such as the following:</span></p>
  <table class="example" id="table1">
    <tr>
      <td><span class="changedspan">1</span></td>
      <td><span class="changedspan">u + grave</span></td>
      <td><span class="changedspan"><code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=0075">U+0075</a></code> (&nbsp;u&nbsp;) LATIN SMALL LETTER U +<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=0300">U+0300</a></code> (&nbsp;̀&nbsp;) COMBINING GRAVE ACCENT</span></td>
    </tr>
    <tr>
      <td><span class="changedspan">2</span></td>
      <td><span class="changedspan">u-grave</span></td>
      <td><span class="changedspan"><code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=00F9">U+00F9</a></code> (&nbsp;ù&nbsp;) LATIN SMALL LETTER U WITH GRAVE</span></td>
    </tr>
  </table>
  <p><span class="changedspan">Literal text in regular expressions may be normalized (converted to equivalent characters) in transmission, out of the control of the authors of of that text. For example, a regular expression may contain a sequence of literal characters &#39;u&#39; and <i>grave</i>, such as 
  the expression [aeiou ̀ ́ ̈̈] (the last three character being <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=0300">U+0300</a></code> (&nbsp;̀&nbsp;) COMBINING GRAVE ACCENT, <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=0301">U+0301</a></code> (&nbsp;́&nbsp;) 
  COMBINING ACUTE ACCENT, and <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=0308">U+0308</a></code> (&nbsp;̈&nbsp;) COMBINING DIAERESIS. In transmission, the two adjacent characters in Row 1 might be changed to the different expression containing just one character in Row 2, thus 
  changing the meaning of the regular expression. Hex notation can be used to avoid this problem. In the above example, the regular expression should be written as <span class="regex">[aeiou\u0300\u0301\u0308]</span> for safety. </span></p>
  <p><span class="changedspan">A regular expression engine may also enforce a single, uniform interpretation of regular expressions by always normalizing input text to Normalization Form NFC before interpreting that text. For more information, see <i>UAX #15: Unicode Normalization Forms</i> [<a 
  href="tr18-12.html#Norm">Norm</a>].</span></p>
  <h3><a name="Categories">1.2 Properties</a></h3>
  <p>Because Unicode is a large character set, a regular expression engine needs to provide for the recognition of whole categories of characters as well as simply ranges of characters; otherwise the listing of characters becomes impractical and error-prone. This is done by providing syntax for sets 
  of characters based on the Unicode character properties, and allowing them to be mixed with lists and ranges of individual code points.</p>
  <p>There are a large number of Unicode Properties defined in <span class="changedspan">the Unicode Character Database (UCD): for the list, see <a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Properties">Unicode Character Database properties</a></span>.
  The official data mapping Unicode characters (and code points) to properties is the <a href="http://www.unicode.org/ucd/">Unicode Character Database</a> [<a 
  href="http://www.unicode.org/ucd/">UCD</a>]. See also Chapter 4 in <i>The Unicode Standard</i> [<a href="tr18-12.html#Unicode">Unicode</a>].
  <span class="changedspan">The defined Unicode string functions, such as isNFC() and isLowercase(), also apply to single code points and are useful to support in regular expressions.</span></p>
  <p align="left">The recommended names for UCD properties and property values are in <a href="http://www.unicode.org/Public/UNIDATA/PropertyAliases.txt">PropertyAliases.txt</a> [<a href="tr18-12.html#Prop">Prop</a>] and <a href="http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt">
  PropertyValueAliases.txt</a> [<a href="tr18-12.html#PropValue">PropValue</a>]. There are both abbreviated names and longer, more descriptive names. It is strongly recommended that both names be recognized, and that loose matching of property names be used, whereby the case distinctions, whitespace, hyphens, 
  and underbar are ignored.</p>
  <blockquote>
    <p><b>Note:</b> it may be a useful implementation technique to load the Unicode tables that support properties and other features on demand, to avoid unnecessary memory overhead for simple regular expressions that do not use those properties. </p>
  </blockquote>
  <p>Where a regular expression is expressed as much as possible in terms of higher-level semantic constructs such as <i>Letter</i>, it makes it practical to work with the different alphabets and languages in Unicode. Here is an example of a syntax addition that permits properties.</p>
  <blockquote>
    <p>Notice that following Perl Syntax, the <i>p</i> is lowercase to indicate a positive match, and uppercase to indicate a negative match.</p>
  </blockquote>
  <table class="syntax">
    <tr>
      <td width="100%"><span class="regex">ITEM := POSITIVE_SPEC | NEGATIVE_SPEC<br>
      POSITIVE_SPEC := (&quot;\p{&quot; PROP_SPEC &quot;}&quot;) | (&quot;[:&quot; PROP_SPEC &quot;:]&quot;)<br>
      NEGATIVE_SPEC := (&quot;\P{&quot; PROP_SPEC &quot;}&quot;) | (&quot;[:^&quot; PROP_SPEC &quot;:]&quot;)<br>
      PROP_SPEC&nbsp; := &lt;binary_unicode_property&gt;<br>
      PROP_SPEC&nbsp; := &lt;unicode_property&gt; (&quot;:&quot; | &quot;=&quot; <span class="changedspan">| &quot;≠&quot;</span> ) <span class="changedspan">VALUE</span><br>
      PROP_SPEC&nbsp; := &lt;script_or_category_property_value&gt; <span class="changedspan">&nbsp;(&quot;|&quot; &lt;script_or_category_property_value&gt;)*</span><br>
      <span class="changedspan">PROP_VALUE :=&nbsp;&nbsp;&nbsp;&nbsp; &lt;unicode_property_value&gt; (&quot;|&quot; &lt;unicode_property_value&gt;)*</span></span></td>
    </tr>
  </table>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><span class="regex">[\p{L} \p{Nd}]</span></td>
      <td rowspan="4">Match all letters and decimal digits</td>
    </tr>
    <tr>
      <td><span class="regex">[\p{letter} \p{decimal number}]</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><span class="regex">[\p{letter|decimal number}]</span></span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><span class="regex">[\p{L|Nd}]</span></span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><span class="regex">\P{script=greek}</span></span></td>
      <td rowspan="6">Match anything that does not have the Greek script</td>
    </tr>
    <tr>
      <td><span class="changedspan"><span class="regex">\P{script:greek}</span></span></td>
    </tr>
    <tr>
      <td><span class="regex"><span class="changedspan">\p{script≠greek}</span></span></td>
    </tr>
    <tr>
      <td><span class="regex"><span class="changedspan">[:^script=greek:]</span></span></td>
    </tr>
    <tr>
      <td><span class="regex"><span class="changedspan">[:^script:greek:]</span></span></td>
    </tr>
    <tr>
      <td><span class="regex"><span class="changedspan">[:script≠greek:]</span></span></td>
    </tr>
    <tr>
      <td><span class="regex">\p{East Asian Width:Narrow}</span></td>
      <td>Match anything that has the <span class="regex">East Asian Width</span> property value of Narrow</td>
    </tr>
    <tr>
      <td><span class="regex">\p{Whitespace}</span></td>
      <td>Match anything that has the binary property Whitespace</td>
    </tr>
  </table>
  <p>Some properties are binary: they are either true or false for a given code point. In that case, only the property name is required. Others have multiple values, so for uniqueness both the property name and the property value need to be included. For example, <i>Alphabetic</i> is both a binary 
  property and a value of the Line_Break enumeration, so \p{Alphabetic} would mean the binary property, and \p{Line Break:Alphabetic} or \p{Line_Break=Alphabetic} would mean the enumerated property. There are two exceptions to this: the properties <i>Script</i> and <i>General Category</i> commonly 
  have the property name omitted. Thus \p{Not_Assigned} is equivalent to \p{General_Category = Not_Assigned}, and \p{Greek} is equivalent to \p{Script:Greek}.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.2</td>
      <td class="rule_head">Properties</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall provide at least a minimal list of properties, consisting of the following:
      <ul>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#General_Category">General_Category</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Script">Script</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Alphabetic">Alphabetic</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Uppercase">Uppercase</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Lowercase">Lowercase</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#White_Space">White_Space</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Noncharacter_Code_Point">Noncharacter_Code_Point</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Default_Ignorable_Code_Point">Default_Ignorable_Code_Point</a></li>
        <li>ANY, ASCII, ASSIGNED</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td class="rule_body"><span><b>RL1.2a </b></span></td>
      <td class="rule_body"><span><b>Compatibility Properties</b></span></td>
    </tr>
    <tr>
      <td class="rule_body">&nbsp;</td>
      <td class="rule_body"><span>To meet this requirement, an implementation shall provide the properties listed in <a href="tr18-12.html#Compatibility_Properties">Annex C. Compatibility Properties</a>, with the property values as listed there. Such an implementation shall document whether it is using the 
      Standard Recommendation or POSIX-compatible properties.</span></td>
    </tr>
  </table>
  <p>Of <span>the properties in RL1.2</span>, only General Category and Script have multiple values; the rest are binary. An implementation that does not support non-binary enumerated properties can essentially &quot;flatten&quot; the enumerated type. Thus, for example, instead of <span class="regex">\p{script=latin}</span> 
  the syntax could be <span class="regex">\p{script_latin}</span>.</p>
  <h4>General Category Property</h4>
  <p>The most basic overall character property is the General Category, which is a basic categorization of Unicode characters into: <i>Letters, Punctuation, Symbols, Marks, Numbers, Separators, </i>and<i> Other</i>. These property values each have a single letter abbreviation, which is the uppercase 
  first character except for separators, which use Z. The official data mapping Unicode characters to the General Category value is in <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">UnicodeData.txt</a> [<a href="tr18-12.html#UData">UData</a>].</p>
  <p>Each of these categories has different subcategories. For example, the subcategories for <i>Letter</i> are <i>uppercase</i>, <i>lowercase</i>, <i>titlecase</i>, <i>modifier</i>, and <i>other</i> (in this case, <i>other</i> includes uncased letters such as Chinese). By convention, the 
  subcategory is abbreviated by the category letter (in uppercase), followed by the first character of the subcategory in lowercase. For example, <i>Lu</i> stands for <i>Uppercase Letter</i>.</p>
  <blockquote>
    <p><b>Note: </b>Because it is recommended that the property syntax be lenient as to spaces, casing, hyphens and underbars, any of the following should be equivalent: <span class="regex">\p{Lu}</span>, <span class="regex">\p{lu}</span>, <span class="regex">\p{uppercase letter}</span>,
    <span class="regex">\p{uppercase letter}</span>, <span class="regex">\p{Uppercase_Letter}</span>, and <span class="regex">\p{uppercaseletter}</span></p>
  </blockquote>
  <p>The General Category property values are listed below. For more information on the meaning of these values, see <a href="http://www.unicode.org/Public/UNIDATA/UCD.html">UCD.html</a> [<a href="tr18-12.html#UDataDoc">UDataDoc</a>].</p>
  <div align="center">
    <center>
    <table border="0" cellspacing="0" cellpadding="4" class="noborder">
      <tr>
        <td width="33%" class="noborder">
        <table class="values">
          <tr>
            <th>Abb.</th>
            <th align="left">Long form</th>
          </tr>
          <tr>
            <td>L</td>
            <td>Letter</td>
          </tr>
          <tr>
            <td>Lu</td>
            <td>Uppercase Letter</td>
          </tr>
          <tr>
            <td>Ll</td>
            <td>Lowercase Letter</td>
          </tr>
          <tr>
            <td>Lt</td>
            <td>Titlecase Letter</td>
          </tr>
          <tr>
            <td>Lm</td>
            <td>Modifier Letter</td>
          </tr>
          <tr>
            <td>Lo</td>
            <td>Other Letter</td>
          </tr>
          <tr>
            <td>M</td>
            <td>Mark</td>
          </tr>
          <tr>
            <td>Mn</td>
            <td>Non-Spacing Mark</td>
          </tr>
          <tr>
            <td>Mc</td>
            <td>Spacing Combining Mark</td>
          </tr>
          <tr>
            <td>Me</td>
            <td>Enclosing Mark</td>
          </tr>
          <tr>
            <td>N</td>
            <td>Number</td>
          </tr>
          <tr>
            <td>Nd</td>
            <td>Decimal Digit Number</td>
          </tr>
          <tr>
            <td>Nl</td>
            <td>Letter Number</td>
          </tr>
          <tr>
            <td>No</td>
            <td>Other Number</td>
          </tr>
        </table>
        </td>
        <td width="33%" class="noborder">
        <table class="values">
          <tr>
            <th>Abb.</th>
            <th align="left">Long form</th>
          </tr>
          <tr>
            <td>S</td>
            <td>Symbol</td>
          </tr>
          <tr>
            <td>Sm</td>
            <td>Math Symbol</td>
          </tr>
          <tr>
            <td>Sc</td>
            <td>Currency Symbol</td>
          </tr>
          <tr>
            <td>Sk</td>
            <td>Modifier Symbol</td>
          </tr>
          <tr>
            <td>So</td>
            <td>Other Symbol</td>
          </tr>
          <tr>
            <td>P</td>
            <td>Punctuation</td>
          </tr>
          <tr>
            <td>Pc</td>
            <td>Connector Punctuation</td>
          </tr>
          <tr>
            <td>Pd</td>
            <td>Dash Punctuation</td>
          </tr>
          <tr>
            <td>Ps</td>
            <td>Open Punctuation</td>
          </tr>
          <tr>
            <td>Pe</td>
            <td>Close Punctuation</td>
          </tr>
          <tr>
            <td>Pi</td>
            <td>Initial Punctuation</td>
          </tr>
          <tr>
            <td>Pf</td>
            <td>Final Punctuation</td>
          </tr>
          <tr>
            <td>Po</td>
            <td>Other Punctuation</td>
          </tr>
        </table>
        </td>
        <td width="33%" class="noborder">
        <table class="values">
          <tr>
            <th>Abb.</th>
            <th align="left">Long form</th>
          </tr>
          <tr>
            <td>Z</td>
            <td>Separator</td>
          </tr>
          <tr>
            <td>Zs</td>
            <td>Space Separator</td>
          </tr>
          <tr>
            <td>Zl</td>
            <td>Line Separator</td>
          </tr>
          <tr>
            <td>Zp</td>
            <td>Paragraph Separator</td>
          </tr>
          <tr>
            <td>C</td>
            <td>Other</td>
          </tr>
          <tr>
            <td>Cc</td>
            <td>Control</td>
          </tr>
          <tr>
            <td>Cf</td>
            <td>Format</td>
          </tr>
          <tr>
            <td>Cs</td>
            <td>Surrogate</td>
          </tr>
          <tr>
            <td>Co</td>
            <td>Private Use</td>
          </tr>
          <tr>
            <td>Cn</td>
            <td>Not Assigned</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Any*</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Assigned*</td>
          </tr>
          <tr>
            <td>-</td>
            <td>ASCII*</td>
          </tr>
        </table>
        </td>
      </tr>
    </table>
    </center>
  </div>
  <table border="0" width="100%" cellspacing="0" cellpadding="4" class="noborder">
    <tr>
      <td valign="top" class="noborder">*</td>
      <td valign="top" class="noborder">The last few properties are not part of the General Category.
      <ul>
        <li><i>Any</i> matches all code points. This could also be captured with <span class="regex">[\u0000-\u10FFFF]</span>, but with <a href="tr18-12.html#Tailored_Ranges">Tailored Ranges</a> off. In some regular expression languages, <span class="regex">\p{Any}</span> may be expressed by a period, but that 
        may exclude newline characters.</li>
        <li><i>Assigned</i> is equivalent to <span class="regex">\P{Cn}</span>, and matches all assigned characters (for the target version of Unicode). It also includes all private use characters. It is useful for avoiding confusing double negatives. Note that <i>Cn</i> includes noncharacters, so
        <i>Assigned</i> excludes them.</li>
        <li>ASCII is equivalent to <span class="regex">[\u0000-\u007F]</span>, but with <a href="tr18-12.html#Tailored_Ranges">Tailored Ranges</a> off.</li>
      </ul>
      </td>
    </tr>
  </table>
  <h4>Script Property</h4>
  <p>A regular-expression mechanism may choose to offer the ability to identify characters on the basis of other Unicode properties besides the General Category. In particular, Unicode characters are also divided into scripts as described in <a href="../tr24/index.html">UTR #24: 
  Script Names</a> [<a href="tr18-12.html#ScriptDoc">ScriptDoc</a>] (for the data file, see <a href="http://www.unicode.org/Public/UNIDATA/Scripts.txt">Scripts.txt</a> [<a href="tr18-12.html#ScriptData">ScriptData</a>]). Using a property such as <span class="regex">\p{Greek}</span> allows implementations to test whether 
  letters are Greek or not.</p>
  <p>Note, however, that the usage model for the script property normally requires that people construct somewhat more complex regular expressions, because a great many characters are shared between scripts. Documentation should point users to the description in UTR #24.</p>
  <h4 align="left">Other Properties</h4>
  <p align="left">Other <span class="changedspan">recommended</span> properties are described in <i>Section 2</i> of <i>UAX #15: Unicode Normalization Forms</i> [<a href="tr18-12.html#Norm">Norm</a>], in <i>Section 3.13</i> of <i>The Unicode Standard, Version 5.0</i> [<a href="tr18-12.html#Case">Case</a>], and in the 
  documentation for the Unicode Character Database [<a href="tr18-12.html#UCD">UCD</a>]. <span class="changedspan">See also &quot;Clarification of Lowercase and Uppercase&quot; in [<a href="../tr41.1#Unicode5.1">Unicode5.1</a>].</span></p>
  <p align="left">The binary properties include:</p>
  <ul>
    <li>
    <p align="left"><i>Bidi_Control, Join_Control</i></li>
    <li>
    <p align="left"><i>ASCII_Hex_Digit, Hex_Digit</i></li>
    <li>
    <p align="left"><i>ID_Start, ID_Continue, XID_Start, XID_Continue</i></li>
    <li>
    <p align="left"><i>isLowercase, isUppercase, isTitlecase, isCasefolded, isCased</i></li>
    <li>
    <p align="left"><i>isNFC, isNFD, isNFKC, isNFKD</i></li>
  </ul>
  <p align="left">The enumerated non-binary properties include:</p>
  <ul>
    <li>
    <p align="left"><i>Decomposition_Type</i></li>
    <li>
    <p align="left"><i>Numeric_Type</i></li>
    <li>
    <p align="left"><i>East_Asian_Width</i></li>
    <li>
    <p align="left"><i>Line_Break</i></li>
  </ul>
  <p align="left">The numeric properties include:</p>
  <ul>
    <li>
    <p align="left"><i>Numeric_Value</i></li>
  </ul>
  <p align="left">The string properties include:</p>
  <ul>
    <li>
    <p align="left"><i>Name<br>
    </i>See also <a href="tr18-12.html#Name_Properties">2.5 Name Properties</a> and <a href="tr18-12.html#Wildcard_Properties">2.6 Wildcards in Property Values</a>.</li>
    <li>
    <p align="left"><i>toLowercase, toUppercase, toTitlecase, toCasefolded</i></li>
    <li>
    <p align="left"><i>toNFC, toNFD, toNFKC, toNFKD</i></li>
    <li>
    <p align="left"><i>Age<br>
    </i><b>Caution:</b> The <a href="http://www.unicode.org/Public/UNIDATA/DerivedAge.txt">DerivedAge</a> data file in the UCD provides the deltas between versions, for compactness. However, when using the property all characters included in that version are included. Thus <span class="regex">\p{age=3.0}</span> 
    includes the letter <i>a</i>, which was included in Unicode 1.0. To get characters that are new in a particular version, subtract off the previous version as described in <a href="tr18-12.html#Subtraction_and_Intersection">1.3 Subtraction and Intersection</a>. For example: <span class="regex">[\p{age=3.1} -<span 
    class="changedspan">-</span> \p{age=3.0}]</span></li>
  </ul>
  <p align="left"><span class="changedspan">For example:</span></p>
  <table class="values">
    <tr>
      <th align="left"><span class="changedspan">String properties</span></th>
      <th align="left"><span class="changedspan">Description</span></th>
      <th>&nbsp;</th>
    </tr>
    <tr>
      <td><span class="changedspan"><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:toNFC=%C3%85:%5D" target="list">[:toNFC=Å:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toNFC(X) = &quot;a&quot;</span></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><span class="changedspan"><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:toNFD=A%5Cu0300:%5D" target="list">[:toNFD=A\u0300:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toNFD(X) = &quot;A\u0300&quot;</span></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><span class="changedspan"><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:toNFKC=A:%5D" target="list">[:toNFKC=A:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toNFKC(X) = &quot;A&quot;</span></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><span class="changedspan"><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:toNFKD=A%5Cu0300:%5D" target="list">[:toNFKD=A\u0300:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toNFKD(X) = &quot;a&quot;</span></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><span class="changedspan"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:toLowercase=a:%5D">[:toLowercase=a:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toLowercase(X) = &quot;a&quot;</span></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><span class="changedspan"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:toUppercase=A:%5D">[:toUppercase=A:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toUppercase(X) = &quot;A&quot;</span></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><span class="changedspan"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:toTitlecase=A:%5D">[:toTitlecase=A:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toTitlecase(X) = &quot;A&quot;</span></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><span class="changedspan"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:toCaseFold=a:%5D">[:toCaseFold=a:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toCasefold(X) = &quot;A&quot;</span></td>
      <td>&nbsp;</td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <table class="values">
    <tr>
      <th><span class="changedspan">Binary properties</span></th>
      <th><span class="changedspan">Description</span></th>
    </tr>
    <tr>
      <td><span class="changedspan"><code><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[:isNFC:]">[:isNFC:]</a></code></span></td>
      <td><span class="changedspan">The set of all characters X such that toNFC(X) = X</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><code><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[:isNFD:]">[:isNFD:]</a></code></span></td>
      <td><span class="changedspan">The set of all characters X such that toNFD(X) = X</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><code><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[:isNFKC:]">[:isNFKC:]</a></code></span></td>
      <td><span class="changedspan">The set of all characters X such that toNFKC(X) = X</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><code><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[:isNFKD:]">[:isNFKD:]</a></code></span></td>
      <td><span class="changedspan">The set of all characters X such that toNFKD(X) = X</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:isLowercase:%5D">[:isLowercase:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toLowercase(X) = X</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:isUppercase:%5D">[:isUppercase:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toUppercase(X) = X</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:isTitlecase:%5D">[:isTitlecase:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toTitlecase(X) = X</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:isCaseFolded:%5D">[:isCaseFolded:]</a></span></td>
      <td><span class="changedspan">The set of all characters X such that toCasefo(X) = X</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:isCased:%5D">[:isCased:]</a></span></td>
      <td><span class="changedspan">The set of all </span></td>
    </tr>
  </table>
  <p align="left">A full list of the available UCD properties is on <a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Properties">UCD Properties</a>. Of those, the following are only useful in very restricted cases, such as in the internal implementation of normalization or case conversions:</p>
  <table class="values">
    <tr>
      <th>Rarely Needed Properties</th>
    </tr>
    <tr>
      <td>Composition_Exclusion</td>
    </tr>
    <tr>
      <td>Decomposition_Mapping</td>
    </tr>
    <tr>
      <td>Special_Case_Condition</td>
    </tr>
    <tr>
      <td>FC_NFKC_Closure</td>
    </tr>
    <tr>
      <td>ISO_Comment</td>
    </tr>
    <tr>
      <td>NFC_Quick_Check<br>
      NFKC_Quick_Check<br>
      NFD_Quick_Check<br>
      NFKD_Quick_Check</td>
    </tr>
    <tr>
      <td>Expands_On_NFC<br>
      Expands_On_NFD<br>
      Expands_On_NFKC<br>
      Expands_On_NFKD</td>
    </tr>
    <tr>
      <td><span class="changedspan">all <i>Contributory Properties.</i></span></td>
    </tr>
  </table>
  <h4 align="left">&nbsp;</h4>
  <h4 align="left">Blocks</h4>
  <p align="left">Unicode blocks can sometimes also be a useful enumerated property. However, there are some <i>very</i> significant caveats to the use of Unicode blocks for the identification of characters: see <a href="tr18-12.html#Character_Blocks">Annex A. Character Blocks</a>. If blocks are used, some of 
  the names can collide with Script names, so they should be distinguished, with syntax such as <span class="regex">\p{Greek Block}</span> or <span class="regex">\p{Block=Greek}</span>.</p>
  <h3><a name="Subtraction_and_Intersection">1.3 Subtraction</a> and Intersection</h3>
  <p>As discussed earlier, character properties are essential with a large character set. In addition, there needs to be a way to &quot;subtract&quot; characters from what is already in the list. For example, one may want to include all non-ASCII letters without having to list every character in
  <span class="regex">\p{letter}</span> that is not one of those 52.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.3</td>
      <td class="rule_head">Subtraction and Intersection</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall supply mechanisms for <span class="changedspan">union, </span>intersection and set-difference of Unicode sets.</td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <table class="syntax">
    <tr>
      <td><code>ITEM&nbsp;&nbsp;&nbsp;&nbsp; := &quot;[&quot; ITEM &quot;]&quot;</code></td>
      <td>// for grouping</td>
    </tr>
    <tr>
      <td><span class="changedspan"><code>OPERATOR</code></span><code> := &quot;&quot;</code></td>
      <td>// no separator = union</td>
    </tr>
    <tr>
      <td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := &quot;|<span class="changedspan">|</span>&quot;</code></td>
      <td>// union: A∪B</td>
    </tr>
    <tr>
      <td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := &quot;&amp;<span class="changedspan">&amp;</span>&quot;</code></td>
      <td>// intersection: A∩B</td>
    </tr>
    <tr>
      <td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := &quot;-<span class="changedspan">-</span>&quot;</code></td>
      <td>// set difference: A-B</td>
    </tr>
    <tr>
      <td><span class="changedspan"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := &quot;~~&quot;</code></span></td>
      <td><span class="changedspan">// symmetric difference: A⊖B = (A∪B)-(A∩B)</span></td>
    </tr>
  </table>
  <p>Implementations may also choose to offer other set operations<span class="changedspan">. The </span><a href="http://mathworld.wolfram.com/SymmetricDifference.html">symmetric difference</a> of two sets<span class="changedspan"> is particularly useful. It is defined as being the union minus the 
  intersection intersection. Thus <span class="regex">[\p{letter}~~\p{ascii}]</span> is equivalent to <span class="regex">[[\p{letter}\p{ascii}]--[\p{letter}&amp;&amp;\p{ascii}]]</span>.</span></p>
  <p><span class="changedspan">For compatibility with industry practice, symbols are doubled in the above notation. This practice provides for better backwards compatibility with expressions using older syntax, because they are unlikely to contain doubled characters. It also allows the operators to 
  appear adjacent to ranges without ambiguity, such as <span class="regex">[\p{letter}--a-z]</span>.</span></p>
  <p><span class="changedspan">Binding or precedence may vary by regular expression engine, so it is safest to always disambiguate using brackets to be sure. In particular, precedence may put all operators on the same level, or may take union as binding more closely. </span>For example, where
  <span class="regex">A..E</span> stand for expressions, not characters:</p>
  <table class="values">
    <tr>
      <th>Expression</th>
      <th>Equals</th>
      <th>When</th>
    </tr>
    <tr>
      <td rowspan="2" nowrap><span class="changedspan">[ABC--DE]</span></td>
      <td nowrap><span class="changedspan">[[AB]C]--[DE]]</span></td>
      <td><span class="changedspan">Union binds more closely. That is, it means:</span><p><span class="changedspan">form the union of A, B, and C, and then subtract the union of D and E. </span></td>
    </tr>
    <tr>
      <td nowrap><span class="changedspan">[[[[[AB]C]--D]E]]</span></td>
      <td><span class="changedspan">Operators are on the same level. That is, it means:</span><p><span class="changedspan">form the union of A, B, and C, and then subtract D, and then add E.</span></td>
    </tr>
  </table>
  <p><span class="changedspan">Even where an expression is not ambiguous, extra grouping brackets may be useful for clarity.</span></p>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><span class="regex">[\p{L}-<span class="changedspan">-</span>QW]</span></td>
      <td>Match all letters but Q and W</td>
    </tr>
    <tr>
      <td><span class="regex">[\p{N}-<span class="changedspan">-</span>[\p{Nd}-<span class="changedspan">-</span>0-9]]</span></td>
      <td>Match all non-decimal numbers, plus 0-9.</td>
    </tr>
    <tr>
      <td><span class="regex">[\u0000-\u007F-<span class="changedspan">-</span>\P{letter}]</span></td>
      <td>Match all letters in the ASCII range, by subtracting non-letters.</td>
    </tr>
    <tr>
      <td><span class="regex">[\p{Greek}-<span class="changedspan">-</span>\N{GREEK SMALL LETTER ALPHA}]</span></td>
      <td>Match Greek letters except alpha</td>
    </tr>
    <tr>
      <td><span class="regex">[\p{Assigned}-<span class="changedspan">-</span>\p{Decimal Digit Number}-<span class="changedspan">-</span>a-fA-Fａ-ｆＡ-Ｆ]</span></td>
      <td>Match all assigned characters except for hex digits (using a broad definition).</td>
    </tr>
  </table>
  <h3><br>
  <a name="Simple_Word_Boundaries">1.4 Simple Word Boundaries</a></h3>
  <p>Most regular expression engines allow a test for word boundaries (such as by &quot;\b&quot; in Perl). They generally use a very simple mechanism for determining word boundaries: one example of that would be having word boundaries between any pair of characters where one is a <span class="regex">&lt;word_character&gt;</span> 
  and the other is not, or at the start and end of a string. This is not adequate for Unicode regular expressions.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.4</td>
      <td class="rule_head">Simple Word Boundaries</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall extend the word boundary mechanism so that:
      <ol>
        <li>The class of <span class="regex">&lt;word_character&gt;</span> includes all the Alphabetic values from the Unicode character database, from <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">UnicodeData.txt</a> [<a href="tr18-12.html#UData">UData</a>]<span>, plus the U+200C ZERO WIDTH 
        NON-JOINER and U+200D ZERO WIDTH JOINER</span>. See also <a href="tr18-12.html#Compatibility_Properties">Annex C: Compatibility Properties</a>.</li>
        <li>Nonspacing marks are never divided from their base characters, and otherwise ignored in locating boundaries.</li>
      </ol>
      </td>
    </tr>
  </table>
  <p>Level 2 provides more general support for word boundaries between arbitrary Unicode characters which may override this behavior.</p>
  <h3><a name="Simple_Loose_Matches">1.5 Simple Loose Matches</a></h3>
  <p>Most regular expression engines offer caseless matching as the only loose matching. If the engine does offers this, then it needs to account for the large range of cased Unicode characters outside of ASCII.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.5</td>
      <td class="rule_head">Simple Loose Matches</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, if an implementation provides for case-insensitive matching, then it shall provide at least the simple, default Unicode case-insensitive matching.
      <p>To meet this requirement, if an implementation provides for case conversions, then it shall provide at least the simple, default Unicode case conversion.</td>
    </tr>
  </table>
  <p>In addition, because of the vagaries of natural language, there are situations where two different Unicode characters have the same uppercase or lowercase. To meet this requirement, implementations must implement these in accordance with the Unicode Standard. For example, the Greek U+03C3 &quot;σ&quot;
  <i>small sigma,</i> U+03C2 &quot;ς&quot; <i>small final sigma,</i> and U+03A3 &quot;Σ&quot; <i>capital sigma</i> all match.</p>
  <p>Some caseless matches may match one character against two: for example, U+00DF &quot;ß&quot; matches the two characters &quot;SS&quot;. And case matching may vary by locale. However, because many implementations are not set up to handle this, at Level 1 only simple case matches are necessary. To correctly 
  implement a caseless match, <span>see Chapter 3 of the Unicode Standard [<a href="tr18-12.html#Unicode">Unicode</a>]</span>. The data file supporting caseless matching is <a href="http://www.unicode.org/Public/UNIDATA/CaseFolding.txt">CaseFolding.txt</a> [<a href="tr18-12.html#CaseData">CaseData</a>].</p>
  <p>To meet this requirement, where an implementation also offers case conversions, these must also <span>follow <i>Chapter 3 Conformance</i> of [<a href="tr18-12.html#Unicode">Unicode</a>]</span>. The relevant data files are <a href="http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt">SpecialCasing.txt</a> 
  [<a href="tr18-12.html#SpecialCasing">SpecialCasing</a>] and <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">UnicodeData.txt</a> [<a href="tr18-12.html#UData">UData</a>].</p>
  <h3><a name="Line_Boundaries">1.6 Line Boundaries</a></h3>
  <p>Most regular expression engines also allow a test for line boundaries: end-of-line or start-of-line. This presumes that lines of text are separated by line (or paragraph) separators.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.6</td>
      <td class="rule_head">Line Boundaries</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, if an implementation provides for line-boundary testing, it shall recognize not only CRLF, LF, CR, but also NEL (U+0085), PS (U+2029) and LS (U+2028).</td>
    </tr>
  </table>
  <p>Formfeed (U+000C) also normally indicates an end-of-line. For more information, see Chapter 3 of [<a href="tr18-12.html#Unicode">Unicode</a>].</p>
  <p>These characters should be uniformly handled in determining logical line numbers, start-of-line, end-of-line, and arbitrary-character implementations. Logical line number is useful for compiler error messages and the like. Regular expressions often allow for SOL and EOL patterns, which match 
  certain boundaries. Often there is also a &quot;non-line-separator&quot; arbitrary character pattern that excludes line separator characters.</p>
  <p>The behavior of these characters may also differ depending on whether one is in a &quot;multiline&quot; mode or not. For more information, see <i>Anchors and Other &quot;Zero-Width Assertions&quot;</i> in Chapter 3 of [<a href="tr18-12.html#Friedl">Friedl</a>].</p>
  <p>A newline sequence is defined to be any of the following:</p>
  <p align="center"><span class="regex">\u000A | <span>\u000B | </span>\u000C | \u000D | \u0085 | \u2028 | \u2029 | \u000D\u000A</span></p>
  <ol>
    <li><b>Logical line number</b>
    <ul>
      <li>The line number is increased by one for each occurrence of <span>a newline sequence</span>. </li>
      <li>Note that different implementations may call the first line either line zero or line one.</li>
    </ul>
    </li>
    <li><b>Logical beginning of line (often &quot;^&quot;)</b>
    <ul>
      <li>SOL is at the start of a file or string, and <span class="changedspan">depending on matching options, </span>also immediately following any occurrence of a newline sequence.</li>
    </ul>
    <ul>
      <li>There is no empty line within the sequence <span class="regex">\u000D\u000A</span><span class="changedspan">, that is, between the first and second character.</span></li>
      <li>Note that there may be a separate pattern for &quot;beginning of text&quot; for a multiline mode, one which matches only at the beginning of the first line, e.g., in Perl \A.</li>
    </ul>
    </li>
    <li><b>Logical end of line (often &quot;$&quot;)</b>
    <ul>
      <li>EOL at the end of a file or string, and <span class="changedspan">depending on matching options, </span>also immediately preceding a final occurrence of<span> a newline sequence.</span></li>
      <li>There is no empty line within the sequence <span class="regex">\u000D\u000A</span>,<span class="changedspan"> that is, between the first and second character.</span></li>
      <li>SOL and EOL are not symmetric because of multiline mode: EOL can be interpreted in at least three different ways:
      <ol type="a">
        <li>EOL matches at the end of the string</li>
        <li>EOL matches before final newline</li>
        <li>EOL matches before any newline</li>
      </ol>
      </li>
    </ul>
    </li>
    <li><b>Arbitrary character pattern (often &quot;.&quot;)</b><ul>
      <li><span class="changedspan">Where the &#39;arbitrary character pattern&#39; matches a newline sequence, it must match all of the newline sequences, and <span class="regex">\u000D\u000A</span> (CRLF)<i> should</i> match as if it were a single character. (The recommendation that CRLF match as a single 
      character is, however, not required for conformance to RL1.6.)</span></li>
      <li>Note that ^$ (an empty line pattern) should not match the empty string within the sequence <span class="regex">\u000D\u000A</span>, but should match the empty string within the reversed sequence <span class="regex">\u000A\u000D</span>.</li>
    </ul>
    </li>
  </ol>
  <p>It is strongly recommended that there be a regular expression meta-character, such as &quot;\R&quot;, for matching all line ending characters and sequences listed above (e.g. in #1). It would thus be shorthand for:</p>
  <p align="center"><span class="regex">( \u000D\u000A | [\u000A<span>\u000B</span>\u000C\u000D\u0085\u2028\u2029] )</span></p>
  <blockquote>
    <p><b>Note: </b>For some implementations, there may be a performance impact in recognizing CRLF as a single entity, such as with an arbitrary pattern character (&quot;.&quot;). To account for that, an implementation may <span class="changedspan">also</span> satisfy R1.6 if there is a mechanism available 
    for converting the sequence CRLF to a single line boundary character before regex processing.</p>
  </blockquote>
  <p>For more information on line breaking, see [<a href="tr18-12.html#LineBreak">LineBreak</a>].</p>
  <h3><a name="Supplementary_Characters">1.7 Code Points</a></h3>
  <p>A fundamental requirement is that Unicode text be interpreted semantically by code point, not code units.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.7</td>
      <td class="rule_head">Supplementary Code Points</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall handle the full range of Unicode code points, including values from U+FFFF to U+10FFFF. In particular, where UTF-16 is used, a sequence consisting of a leading surrogate followed by a trailing surrogate shall be handled as 
      a single code point in matching.</td>
    </tr>
  </table>
  <p>UTF-16 uses pairs of Unicode code units to express code points above FFFF<sub>16</sub>. Surrogate pairs (or their equivalents in other encoding forms) are be handled internally as single code point values. In particular, <span class="regex">[\u0000-\U0010000]</span> will match all the following 
  sequence of code units:</p>
  <table>
    <tr>
      <th width="198" align="left">Code Point</th>
      <th width="199" align="left">UTF-8 Code Units</th>
      <th width="199" align="left">UTF-16 Code Units</th>
      <th width="199" align="left">UTF-32 Code Units</th>
    </tr>
    <tr>
      <td><span class="regex">7F</span></td>
      <td><span class="regex">7F</span></td>
      <td><span class="regex">007F</span></td>
      <td><span class="regex">0000007F</span></td>
    </tr>
    <tr>
      <td><span class="regex">80</span></td>
      <td><span class="regex">C2 80</span></td>
      <td><span class="regex">0080</span></td>
      <td><span class="regex">00000080</span></td>
    </tr>
    <tr>
      <td><span class="regex">7FF</span></td>
      <td><span class="regex">DF BF</span></td>
      <td><span class="regex">07FF</span></td>
      <td><span class="regex">000007FF</span></td>
    </tr>
    <tr>
      <td><span class="regex">800</span></td>
      <td><span class="regex">E0 A0 80</span></td>
      <td><span class="regex">0800</span></td>
      <td><span class="regex">00000800</span></td>
    </tr>
    <tr>
      <td><span class="regex">FFFF</span></td>
      <td><span class="regex">EF BF BF</span></td>
      <td><span class="regex">FFFF</span></td>
      <td><span class="regex">0000FFFF</span></td>
    </tr>
    <tr>
      <td><span class="regex">10000</span></td>
      <td><span class="regex">F0 90 80 80</span></td>
      <td><span class="regex">D800 DC00</span></td>
      <td><span class="regex">00010000</span></td>
    </tr>
  </table>
  <p><br>
  </p>
  <hr align="LEFT">
  <h2><a name="Extended_Unicode_Support">2 Extended Unicode Support</a>: <a name="Level_2">Level 2</a></h2>
  <p>Level 1 support works well in many circumstances. However, it does not handle more complex languages or extensions to the Unicode Standard very well. Particularly important cases are canonical equivalence, word boundaries, extended grapheme cluster boundaries, and loose matches. (For more 
  information about boundary conditions, see<i> </i><a href="../tr29.1">UTR #29: Text Boundaries</a> [<a href="tr18-12.html#Boundaries">Boundaries</a>].)</p>
  <p>Level 2 support matches much more what user expectations are for sequences of Unicode characters. It is still locale-independent and easily implementable. However, <span class="removedspan">the implementation may be slower when supporting Level 2, and some expressions may require Level 1 
  matches. Thus it is often</span> <span class="changedspan">for compatibility with Level 1,</span> it is useful to have some sort of syntax that will turn Level 2 support on and off.</p>
  <p><span class="changedspan">The features comprising Level 2 are not in order of importance. In particular, the most useful and highest priority features in practice are:</span></p>
  <ul>
    <li><span class="changedspan"><a href="tr18-12.html#Default_Word_Boundaries">RL2.3 Default Word Boundaries</a></span></li>
    <li><span class="changedspan"><a href="tr18-12.html#Name_Properties">RL2.5 Name Properties</a></span></li>
    <li><span class="changedspan"><a href="tr18-12.html#Wildcard_Properties">RL2.6 Wildcards in Property Values</a></span></li>
  </ul>
  <h3><a name="Canonical_Equivalents">2.1 Canonical Equivalents</a></h3>
  <p>There are many instances where a character can be equivalently expressed by two different sequences of Unicode characters. For example, <span class="regex">[ä]</span> should match both &quot;ä&quot; and &quot;a\u0308&quot;. (See <a href="../tr15.1">UAX #15: Unicode Normalization</a> [<a 
  href="tr18-12.html#Norm">Norm</a>] and <i>Sections 2.5 and 3.9</i> of <i>The Unicode Standard</i> for more information.)</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.1</td>
      <td class="rule_head">Canonical Equivalents</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall provide a mechanism for ensuring that all canonically equivalent literal characters match.</td>
    </tr>
  </table>
  <p><span class="changedspan">One of the most effective ways to implement canonical equivalence is by having a special mode that only matches on extended grapheme cluster boundaries, since it avoids the reordering problems that can happen in normalization. See <a href="tr18-12.html#Default_Grapheme_Clusters">
  RL2.2 Extended Grapheme Clusters</a>.</span></p>
  <p>There are two <span class="changedspan">other</span> options for implementing this:</p>
  <ol>
    <li>Before (or during) processing, translate text (and pattern) into a normalized form. This is the simplest to implement, because there are available code libraries for doing normalization.</li>
  </ol>
  <ol>
    <li value="2">Expand the regular expression internally into a more generalized regular expression that takes canonical equivalence into account. For example, the expression <span class="regex">[a-z ä]</span> can be internally turned into <span class="regex">([a-z ä] | (a \u0308))</span>. While 
    this can be faster, it may also be substantially more difficult to generate expressions capturing all of the possible equivalent sequences. </li>
  </ol>
  <p>It may be useful to distinguish a regular-expression engine from the larger software package which uses it. For example, the requirements of this section can be met by requiring the package to normalize text before supplying it to the regular expression engine. However, where the regular 
  expression engine returns offsets into the text, the package may need to map those back to what the offsets would be in the original, unnormalized text.</p>
  <blockquote>
    <p><b>Note:</b> Combining characters are required for many languages. Even when text is in Normalization Form C, there may be combining characters in the text.</p>
  </blockquote>
  <h3><a name="Default_Grapheme_Clusters">2.2 Extended Grapheme Clusters</a></h3>
  <p>One or more Unicode characters may make up what the user thinks of as a character. To avoid ambiguity with the computer use of the term <i>character,</i> this is called a <i>grapheme cluster</i>. For example, &quot;G&quot; + <i>acute-accent</i> is a grapheme cluster: it is thought of as a single 
  character by users, yet is actually represented by two Unicode characters. <span class="changedspan">The Unicode Standard defines <i>extended grapheme clusters</i> that keep Hangul syllables together and do not break between base characters and combining marks.
   The precise definition is in <a href="../tr29.1">
  UTR #29: Text Boundaries</a> [<a href="tr18-12.html#Boundaries">Boundaries</a>].
    These <i>extended</i> grapheme clusters are not the same as <i>tailored</i> grapheme clusters, which are covered in Level 3,
   <a href="tr18-12.html#Boundaries">Tailored Grapheme Clusters</a>.</span>
  </p>
  <table class="noborder" id="table2">
    <tr>
      <td class="rule_head">RL3.12</td>
      <td class="rule_head">Extended Grapheme Clusters</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide a mechanism for matching against an arbitrary extended grapheme cluster, a literal cluster, and matching extended grapheme cluster boundaries.</i></td>
    </tr>
  </table>
  <p>For example, an implementation could interpret &quot;\X&quot; as matching any <span class="changedspan">extended</span> grapheme cluster, while interpreting &quot;.&quot; as matching any single code point. It could interpret &quot;\h&quot; as a zero-width match against any <span class="changedspan">extended</span> grapheme 
  cluster boundary, and &quot;\H&quot; as the negation of that.</p>
  <p>Regular expression engines should also provide some mechanism for easily matching against literal clusters, because they are more likely to match user expectations for many languages. One mechanism for doing that is to have explicit syntax for literal clusters, as in the following syntax:</p>
  <table class="syntax" id="table3">
    <tr>
      <td width="100%"><span class="regex">ITEM := &quot;\q{&quot; CODE_POINT + &quot;}&quot;</span></td>
    </tr>
  </table>
  <p>This syntax can also be used for tailored grapheme clusters (see <a href="tr18-12.html#Tailored_Graphemes_Clusters">Tailored Grapheme Clusters</a>).</p>
  <p><i>Examples:</i></p>
  <table class="example" id="table4">
    <tr>
      <td><span class="regex">[a-z\q{x\u0323}]</span></td>
      <td>Match a-z, and x with an under-dot (used in American Indian languages)</td>
    </tr>
    <tr>
      <td><span class="regex">[a-z\q{aa}]</span></td>
      <td>Match a-z, and aa (treated as a single character in Danish).</td>
    </tr>
    <tr>
      <td><span class="regex">[a-z ñ \q{ch} \q{ll} \q{rr}]</span></td>
      <td>Match some lowercase characters in traditional Spanish.</td>
    </tr>
  </table>
  <p><span class="changedspan">In implementing extended grapheme clusters, the expression <span class="regex">[a-m \q{ch} \q{rr}]</span> should behave like <span class="regex">(?&gt; ch | rr | [am]){1}+</span> as interpreted in Java-like regex engines (the {1}+ syntax is not in Perl). That is, the 
  expression would:</span></p>
  <ul>
    <li><span class="changedspan">match ch or rr and advance by two code points, or</span></li>
    <li><span class="changedspan">match a-m and advance one code point, or</span></li>
    <li><span class="changedspan">fail to match</span></li>
  </ul>
  <p><span class="changedspan">Note that <span class="regex">/(?&gt; ch | rr | [a-m])heese/</span> will match &quot;chheese&quot; but not &quot;cheese&quot;; that is, the <i>c</i> in <span class="regex">[a-m]</span> will not match if the &quot;ch&quot; has already been matched. </span></p>
  <p><span class="changedspan">Matching a <i>complemented</i> set containing strings like \q{ch} may behave differently in the two different modes: the normal mode where code points are the unit of matching, or the mode where extended grapheme clusters are the unit of matching. That is, the 
  expression <span class="regex">[^ a-z \q{ch} \q{rr}]</span> should behave in the following way:</span></p>
  <table class="values">
    <tr>
      <th><span class="changedspan">Mode</span></th>
      <th nowrap><span class="changedspan">Behavior</span></th>
      <th><span class="changedspan">Description</span></th>
    </tr>
    <tr>
      <td><span class="changedspan">normal</span></td>
      <td nowrap><span class="changedspan"><span class="regex">(?! ch | rr | [a-m] )<br>
      [\x{0}-\x{10FFFF}]</span></span></td>
      <td><span class="changedspan">failing with strings starting with a-z, ch, or rr, and<br>
      otherwise advancing by one code point</span></td>
    </tr>
    <tr>
      <td><span class="changedspan">grapheme cluster</span></td>
      <td nowrap><span class="changedspan"><span class="regex">(?! ch | rr | [a-m] )<br>
      \X</span></span></td>
      <td><span class="changedspan">failing with strings starting with a-z, ch, or rr, and<br>
      otherwise advancing by one extended grapheme cluster</span></td>
    </tr>
  </table>
  <p><span class="changedspan">A complex character set containing strings like <span class="regex">\q{ch}</span> plus embedded complement operations is interpreted as if the complement were pushed up to the top of the expression, using the following rewrites recursively:</span></p>
  <div>
    <table id="table6" style="border-collapse: collapse;" border="1" cellpadding="2" cellspacing="0">
      <tr>
        <th bgcolor="#c0c0c0" width="50%"><span class="changedspan">Original</span></th>
        <th bgcolor="#c0c0c0" width="50%"><span class="changedspan">Rewrite </span></th>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">^^x </span></td>
        <td align="center" style="text-align: center"><span class="changedspan">x </span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">^x || ^y </span></td>
        <td align="center" style="text-align: center"><span class="changedspan">^(x &amp;&amp; y) </span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">^x || y </span></td>
        <td align="center" style="text-align: center"><span class="changedspan">^(x -- y) </span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">x || ^y </span></td>
        <td align="center" style="text-align: center"><span class="changedspan">^(y -- x) </span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">^x &amp;&amp; ^y </span></td>
        <td align="center" rowspan="2" style="vertical-align: middle; text-align: center"><span class="changedspan">^(x || y) </span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">^x -- y </span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">^x &amp;&amp; y </span></td>
        <td align="center" rowspan="2" style="vertical-align: middle; text-align: center"><span class="changedspan">y -- x </span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">^x -- ^y </span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">x &amp;&amp; ^y </span></td>
        <td align="center" style="text-align: center"><span class="changedspan">x -- y </span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">x -- ^y </span></td>
        <td align="center" style="text-align: center"><span class="changedspan">x &amp;&amp; y</span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">^x ~~ ^y</span></td>
        <td align="center" style="text-align: center"><span class="changedspan">x ~~ y</span> </td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">^x ~~ y</span></td>
        <td align="center" rowspan="2" style="vertical-align: middle; text-align: center"><span class="changedspan">^(x ~~ y)</span></td>
      </tr>
      <tr>
        <td align="center" bgcolor="#eeeeee" style="text-align: center"><span class="changedspan">x ~~ ^y</span></td>
      </tr>
    </table>
  </div>
  <p><span class="changedspan">Applying these rewrites results in a simplification of the regex expression. Either the complement operations will be completely eliminated, or a single remaining complement operation will remain at the top level of the expression. Logically, then, the rest of the 
  expression consists of a flat list of characters and/or multi-character strings; matching strings can then can be handled as described above.</span></p>
  <h3><a name="Default_Word_Boundaries">2.3 Default Word Boundaries</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.3</td>
      <td class="rule_head">Default Word Boundaries</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide a mechanism for matching Unicode default word boundaries.</i></td>
    </tr>
  </table>
  <p>The simple Level 1 support using simple <span class="regex">&lt;word_character&gt;</span> classes is only a very rough approximation of user word boundaries. A much better method takes into account more context than just a single pair of letters. A general algorithm can take care of character and 
  word boundaries for most of the world&#39;s languages. For more information, see <a href="../tr29.1">UTR #29: Text Boundaries</a> [<a href="tr18-12.html#Boundaries">Boundaries</a>].</p>
  <blockquote>
    <p><b>Note: </b>Word boundaries and &quot;soft&quot; line-break boundaries (where one could break in line wrapping) are not generally the same; line breaking has a much more complex set of requirements to meet the typographic requirements of different languages. See
    <a href="../tr14/index.html">UAX #14: Line Breaking Properties</a> [<a href="tr18-12.html#LineBreak">LineBreak</a>] for more information. However, soft line breaks are not generally relevant to general regular expression engines.</p>
  </blockquote>
  <p>A fine-grained approach to languages such as Chinese or Thai <font face="Lucida Sans Unicode">—</font> languages that do not use spaces <font face="Lucida Sans Unicode">—</font> requires information that is beyond the bounds of what a Level 2 algorithm can provide.</p>
  <h3><a name="Default_Loose_Matches">2.4 Default Loose Matches</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.4</td>
      <td class="rule_head">Default Loose Matches</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement:
      <ul>
        <li>if an implementation provides for case-insensitive matching, then it shall provide at least the full, default Unicode case-insensitive matching.</li>
        <li>if an implementation provides for case conversions, then it shall provide at least the full, default Unicode case conversion.</li>
      </ul>
      </td>
    </tr>
  </table>
  <p>At Level 1, caseless matches do not need to handle cases where one character matches against two. Level 2 includes caseless matches where one character may match against two (or more) characters. For example, 00DF &quot;ß&quot; will match against the two characters &quot;SS&quot;.</p>
  <p>To correctly implement a caseless match and case conversions, see <a href="../tr21/index.html">UAX #21: Case Mappings</a> [<a href="tr18-12.html#Case">Case</a>]. For ease of implementation, a complete case folding file is supplied at
  <a href="http://www.unicode.org/Public/UNIDATA/CaseFolding.txt">CaseFolding.txt</a> [<a href="tr18-12.html#CaseData">CaseData</a>].</p>
  <p>If the implementation containing the regular expression engine also offers case conversions, then these should also be done in accordance with UAX #21, with the full mappings. The relevant data files are <a href="http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt">SpecialCasing.txt</a> [<a 
  href="tr18-12.html#SpecialCasing">SpecialCasing</a>] and <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">UnicodeData.txt</a> [<a href="tr18-12.html#UData">UData</a>].</p>
  <h3>2.5 <a name="Name_Properties">Name Properties</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.5</td>
      <td class="rule_head">Name Properties</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall support individually named characters.</i></td>
    </tr>
  </table>
  <p>When using names in regular expressions, the main data is supplied in the Name property in the UCD, as described in [<a href="tr18-12.html#UDataDoc">UDataDoc</a>], or computed as in the case of CJK Ideographs or Hangul Syllables. Certain code points are not assigned names in the standard. These should be 
  given names based on the General_Category:</p>
  <table class="example">
    <tr>
      <td><b>Control:</b></td>
      <td>The Unicode 1.0 name field (ISO control names).</td>
    </tr>
    <tr>
      <td><b>Private Use:</b></td>
      <td rowspan="2">&lt;no name&gt;</td>
    </tr>
    <tr>
      <td><b>Unassigned:</b></td>
    </tr>
  </table>
  <p>The ISO names for the control characters may be unfamiliar, especially because many people are not familiar with changes in the formal ISO names to make them more language neutral, so it is recommended that they be supplemented with other aliases. For example, for U+0009 the implementation 
  could accept the official name CHARACTER TABULATION, and also the aliases HORIZONTAL TABULATION, HT, and TAB.</p>
  <h4>Individually Named Characters</h4>
  <p>The following provides syntax for specifying a code point by supplying the precise name. This syntax specifies a single code point, which can thus be used in ranges.</p>
  <table class="syntax">
    <tr>
      <td width="100%"><span class="regex">&lt;codepoint&gt; := &quot;\N{&quot; &lt;character_name&gt; &quot;}&quot;</span></td>
    </tr>
  </table>
  <p>This is equivalent to using the property <i>name,</i> as in \<span class="regex">p{name=WHITE SMILING FACE}</span>. The only distinction between them is that \N should cause a syntax error if it fails to match a character. <span class="changedspan">This may be extended to match named character 
  sequences, such as \N{KHMER CONSONANT SIGN COENG KA}. Note that because this is a sequence it behaves as a single element, so \N{KHMER CONSONANT SIGN COENG KA}* should be treated as if it were the expression (\x{17D2|\x{1780})*.</span></p>
  <p>As with other property values, names should use a loose match, disregarding case, spaces and hyphen (the underbar character &quot;_&quot; cannot occur in Unicode character names). An implementation may also choose to allow namespaces, where some prefix like &quot;LATIN LETTER&quot; is set globally and used if 
  there is no match otherwise.</p>
  <p>There are, however, three instances that require special-casing with loose matching, where an extra test shall be made for the presence or absence of a hyphen.</p>
  <ul>
    <li>U+0F68 TIBETAN LETTER A and<br>
    <i>U+0F60 TIBETAN LETTER -A</i> </li>
    <li>U+0FB8 TIBETAN SUBJOINED LETTER A and<br>
    <i>U+0FB0 TIBETAN SUBJOINED LETTER -A</i> </li>
    <li>U+116C HANGUL JUNGSEONG OE and<br>
    <i>U+1180 HANGUL JUNGSEONG O-E</i></li>
  </ul>
  <p>&nbsp;Examples:</p>
  <ul>
    <li><span class="regex">\N{WHITE SMILING FACE}</span> or <span class="regex">\N{whitesmilingface}</span> is equivalent to <span class="regex">\u263A</span></li>
    <li><span class="regex">\N{GREEK SMALL LETTER ALPHA}</span> is equivalent to <span class="regex">\u03B1</span></li>
    <li><span class="regex">\N{FORM FEED}</span> is equivalent to <span class="regex">\u000C</span></li>
    <li><span class="regex">\N{SHAVIAN LETTER PEEP}</span> is equivalent to <span class="regex">\U00010450</span></li>
    <li><span class="regex">[\N{GREEK SMALL LETTER ALPHA}-\N{GREEK SMALL LETTER BETA}]</span> is equivalent to <span class="regex">[\u03B1-\u03B2]</span></li>
  </ul>
  <h3>2.6 <a name="Wildcard_Properties">Wildcards in Property Values</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.6</td>
      <td class="rule_head">Wildcards in Property Values</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall support wildcards in Unicode property values.</i></td>
    </tr>
  </table>
  <p>Instead of a single property value, this feature allows the use of a regular expression to pick out a set of characters based on whether the property values match the regular expression. The regular expression must support at least wildcards; other regular expressions features are recommended 
  but optional.</p>
  <table class="syntax" id="table7">
    <tr>
      <td width="100%">
      <pre><span class="changedspan">PROP_VALUE := &lt;value&gt;
            | &quot;/&quot; &lt;regex expression&gt; &quot;/&quot;</span></pre>
      </td>
    </tr>
  </table>
  <blockquote>
    <p><b>Note: </b>Where regular expressions are using in matching, case, spaces, hyphen, and underbar are significant; it is presumed that users will make use of regular-expression features to ignore these if desired.</p>
  </blockquote>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <th><span class="changedspan">Expression</span></th>
      <th><span class="changedspan"><span style="background-color: #FFFF00"><b>Description/Contents</b></span></span></th>
    </tr>
    <tr>
      <td nowrap><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=/p{toNfd=/b/}">\p{toNfd=/b/}</a></td>
      <td><span class="changedspan"><b>Characters whose NFD form contains a &quot;b&quot; (U+0062) in the value.</b></span></td>
    </tr>
    <tr>
      <td nowrap>&nbsp;</td>
      <td><code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=0062">U+0062</a></code> ( b ) LATIN SMALL LETTER B<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=1E03">U+1E03</a></code> ( ḃ ) LATIN SMALL LETTER B WITH DOT ABOVE<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=1E05">U+1E05</a></code> ( ḅ ) LATIN SMALL LETTER B WITH DOT BELOW<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=1E07">U+1E07</a></code> ( ḇ ) LATIN SMALL LETTER B WITH LINE BELOW</td>
    </tr>
    <tr>
      <td nowrap><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=/p{name=/^LATIN LETTER.*P$/}">\p{name=/^LATIN LETTER.*P$/}</a></td>
      <td><span class="changedspan"><b>Characters with names starting with &quot;LATIN LETTER&quot; and ending with &quot;P&quot;</b></span></td>
    </tr>
    <tr>
      <td nowrap>&nbsp;</td>
      <td><code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=01AA">U+01AA</a></code> ( ƪ ) LATIN LETTER REVERSED ESH LOOP<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=0294">U+0294</a></code> ( ʔ ) LATIN LETTER GLOTTAL STOP<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=0296">U+0296</a></code> ( ʖ ) LATIN LETTER INVERTED GLOTTAL STOP<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=1D18">U+1D18</a></code> ( ᴘ ) LATIN LETTER SMALL CAPITAL P</td>
    </tr>
    <tr>
      <td nowrap><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=/p{name=/VARIA(TION|NT)/}">\p{name=/VARIA(TION|NT)/}</a></td>
      <td><span class="changedspan"><b>Characters with names containing &quot;VARIATION&quot; or &quot;VARIANT&quot;</b></span></td>
    </tr>
    <tr>
      <td nowrap>&nbsp;</td>
      <td><code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=180B">U+180B</a></code> (&nbsp; ) MONGOLIAN FREE VARIATION SELECTOR ONE<br>
      …<code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=180D">U+180D</a></code> (&nbsp; ) MONGOLIAN FREE VARIATION SELECTOR THREE<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=299C">U+299C</a></code> ( ⦜ ) RIGHT ANGLE VARIANT WITH SQUARE<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=303E">U+303E</a></code> ( 〾 ) IDEOGRAPHIC VARIATION INDICATOR<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=FE00">U+FE00</a></code> (&nbsp; ) VARIATION SELECTOR-1<br>
      …<code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=FE0F">U+FE0F</a></code> (&nbsp; ) VARIATION SELECTOR-16<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=121AE">U+121AE</a></code> ( 𒆮 ) CUNEIFORM SIGN KU4 VARIANT FORM<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=12425">U+12425</a></code> ( 𒐥 ) CUNEIFORM NUMERIC SIGN THREE SHAR2 VARIANT FORM<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=1242F">U+1242F</a></code> ( 𒐯 ) CUNEIFORM NUMERIC SIGN THREE SHARU VARIANT FORM<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=12437">U+12437</a></code> ( 𒐷 ) CUNEIFORM NUMERIC SIGN THREE BURU VARIANT FORM<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=1243A">U+1243A</a></code> ( 𒐺 ) CUNEIFORM NUMERIC SIGN THREE VARIANT FORM ESH16<br>
      …<code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=12449">U+12449</a></code> ( 𒑉 ) CUNEIFORM NUMERIC SIGN NINE VARIANT FORM ILIMMU A<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=12453">U+12453</a></code> ( 𒑓 ) CUNEIFORM NUMERIC SIGN FOUR BAN2 VARIANT FORM<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=12455">U+12455</a></code> ( 𒑕 ) CUNEIFORM NUMERIC SIGN FIVE BAN2 VARIANT FORM<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=1245D">U+1245D</a></code> ( 𒑝 ) CUNEIFORM NUMERIC SIGN ONE THIRD VARIANT FORM A<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=1245E">U+1245E</a></code> ( 𒑞 ) CUNEIFORM NUMERIC SIGN TWO THIRDS VARIANT FORM A<br>
      <code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=E0100">U+E0100</a></code> (&nbsp; ) VARIATION SELECTOR-17<br>
      …<code><a target="c" href="http://unicode.org/cldr/utility/character.jsp?a=E01EF">U+E01EF</a></code> (&nbsp; ) VARIATION SELECTOR-256</td>
    </tr>
  </table>
  <p>The above are all on the basis of Unicode 5.0; different versions of Unicode may produce different results.</p>
  <p><span class="changedspan">Here are some additional samples, illustrating various sets. If you click on them, they will use the online Unicode utilities on the Unicode website to show the contents of the sets. Note that these online utilities curently use single-letter operations:</span></p>
  <table class="example">
    <tr>
      <th>Expression</th>
      <th><span class="changedspan"><span style="background-color: #FFFF00"><b>Description</b></span></span></th>
    </tr>
    <tr>
      <td nowrap><span class="changedspan"><span class="regex"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B:name=/CJK/:%5D-%5B:ideographic:%5D%5D">[[:name=/CJK/:]-[:ideographic:]]</a></span></span></td>
      <td><span class="changedspan">The set of all characters with names that contain CJK that are not Ideographic</span></td>
    </tr>
    <tr>
      <td nowrap><span class="changedspan"><span class="regex"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:name=/%5CbDOT$/:%5D">[:name=/\bDOT$/:]</a></span></span></td>
      <td><span class="changedspan">The set of all characters with names that end with the word DOT</span></td>
    </tr>
    <tr>
      <td nowrap><span class="changedspan"><span class="regex"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:block=/%28?i%29arab/:%5D">[:block=/(?i)arab/:]</a></span></span></td>
      <td><span class="changedspan">The set of all characters in blocks that contain the sequence of letters &quot;arab&quot; (case-insensitive)</span></td>
    </tr>
    <tr>
      <td nowrap><span class="changedspan"><span class="regex"><a target="list" href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:toNFKC=/%5C./:%5D">[:toNFKC=/\./:]</a></span></span></td>
      <td><span class="changedspan">the set of all characters with toNFKC values that contain a literal period</span></td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <hr align="LEFT">
  <h2><a name="Tailored_Support">3 Tailored Support</a>: <a name="Level_3">Level 3</a></h2>
  <p>All of the above deals with a default specification for a regular expression. However, a regular expression engine also may want to support tailored specifications, typically tailored for a particular language or locale. This may be important when the regular expression engine is being used by 
  end-users instead of programmers, such as in a word-processor allowing some level of regular expressions in searching.</p>
  <p>For example, the order of Unicode characters may differ substantially from the order expected by users of a particular language. The regular expression engine has to decide, for example, whether the list <span class="regex">[a-ä]</span> means:</p>
  <ul>
    <li>the Unicode characters in binary order between <span class="regex">0061<sub>16</sub></span> and <span class="regex">00E5<sub>16</sub></span> (including &#39;<span class="regex">z</span>&#39;, &#39;<span class="regex">Z</span>&#39;, &#39;[&#39;, and &#39;<span class="regex">¼</span>&#39;), <i>or</i> </li>
    <li>the letters in that order in the users&#39; locale (which <i>does not</i> include &#39;<span class="regex">z</span>&#39; in English, but <i>does</i> include it in Swedish). </li>
  </ul>
  <p>If both tailored and default regular expressions are supported, then a number of different mechanism are affected. There are two main alternatives for control of tailored support:</p>
  <ul>
    <li><i>coarse-grained support:</i> the whole regular expression (or the whole script in which the regular expression occurs) can be marked as being tailored. </li>
    <li><i>fine-grained support:</i> any part of the regular expression can be marked in some way as being tailored. </li>
  </ul>
  <p>For example, fine-grained support could use some syntax like the following to indicate tailoring to a locale within a certain range. <span class="changedspan">Locale (or language) IDs should use the syntax from locale identifier definition in [<a href="tr18-12.html#LDML">LDML</a>], <i>Section 3.
  <a href="http://unicode.org/reports/tr35/#Identifiers">Identifiers</a></i>.</span></p>
  <table class="syntax">
    <tr>
      <td width="100%">
      <pre>\T{&lt;locale_id&gt;}..\E</pre>
      </td>
    </tr>
  </table>
  <p><span class="changedspan">There must be some sort of syntax that will allow Level 3 support to be turned on and off, for two reasons. Level 3 support may be considerably slower than Level 2, and most regular expressions may require Level 1 or Level 2 matches to work properly. The syntax should 
  also specify the particular locale or other tailoring customization that the pattern was designed for, because tailored regular expression patterns are usually quite specific to the locale, and will generally not work across different locales.</span></p>
  <p>Sections 3.6 and following describe some additional capabilities of regular expression engines that are very useful in a Unicode environment, especially in dealing with the complexities of the large number of writing systems and languages expressible in Unicode.</p>
  <h3><a name="Tailored_Properties">3.1 Tailored Punctuation</a></h3>
  <p>The Unicode character properties for punctuation may vary from language to language or from country to country. In most cases, the effects of such changes will be apparent in other operations, such as a determination of word breaks. But there are other circumstances where the effects should be 
  apparent in the general APIs, such as when testing whether a curly quotation mark is <i>opening</i> or <i>closing</i> punctuation.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.1</td>
      <td class="rule_head">Tailored Punctuation</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall allow for punctuation properties to be tailored according to locale<span class="changedspan">, using the </span></i><span class="changedspan">locale identifier definition in [<a href="tr18-12.html#LDML">LDML</a>], <i>Section 3.
      <a href="http://unicode.org/reports/tr35/#Identifiers">Identifiers</a>.</i></span></td>
    </tr>
  </table>
  <p>As just described, there must be the capability of turning this support on or off.</p>
  <h3><a name="Tailored_Graphemes_Clusters">3.2 Tailored Grapheme Clusters</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.2</td>
      <td class="rule_head">Tailored Grapheme Clusters</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for collation grapheme clusters matches based on a locale&#39;s collation order.</i></td>
    </tr>
  </table>
  <p>Tailored grapheme clusters may be somewhat different than the extended grapheme clusters discussed in Level 2. They are coordinated with the collation ordering for a given language in the following way. A collation ordering determines a <i>collation grapheme cluster</i>, which is a sequence of 
  characters that is treated as a unit by the ordering. For example, <i>ch</i> is a collation character for a traditional Spanish ordering. More specifically, a collation character is the longest sequence of characters that maps to a sequence of one or more collation elements where the first 
  collation element has a primary weight and subsequent elements do not, and no completely ignorable characters are included.</p>
  <p>The tailored grapheme clusters for a particular locale are the collation characters for the collation ordering for that locale. The determination of tailored grapheme clusters requires the regular expression engine to either draw upon the platform&#39;s collation data, or incorporate its own 
  tailored data for each supported locale.</p>
  <p>See <a href="../tr10/index.html">UTS #10: Unicode Collation Algorithm</a> [<a href="tr18-12.html#Collation">Collation</a>] for more information about collation, and <a href="tr18-12.html#Sample_Collation_Character_Code">Annex B. Sample Collation Character Code</a> for sample code.</p>
  <h3><a name="Tailored_Word_Boundaries">3.3 Tailored Word Boundaries</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.3</td>
      <td class="rule_head">Tailored Word Boundaries</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall allow for the ability to have word boundaries to be tailored according to locale.</i></td>
    </tr>
  </table>
  <p>Semantic analysis may be required for correct word boundary detection in languages that do not require spaces, such as Thai, Japanese, Chinese or Korean. This can require fairly sophisticated support if Level 3 word boundary detection is required, and usually requires drawing on platform OS 
  services.</p>
  <h3><a name="Tailored_Loose_Matches">3.4 Tailored Loose Matches</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.4</td>
      <td class="rule_head">Tailored Loose Matches</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for loose matches based on a locale&#39;s collation order, with at least 3 levels.</i></td>
    </tr>
  </table>
  <p>In Level 1 and 2, caseless matches are described, but there are other interesting linguistic features that users may want to match. For example, <i>V</i> and <i>W</i> are considered equivalent in Swedish collations, and so <span class="regex">[V]</span> should match <i>W</i> in Swedish. In line 
  with the <a href="../tr10/index.html">UTS #10: Unicode Collation Algorithm</a> [<a href="tr18-12.html#Collation">Collation</a>], the following four levels of equivalences are recommended:</p>
  <ul>
    <li>exact match: bit-for-bit identity </li>
    <li>tertiary match: disregard 4th level differences (language tailorings) </li>
    <li>secondary match: disregard 3rd level differences such as upper/lowercase and compatibility variation (that is, matching both half-width and full-width katakana). </li>
    <li>primary match: disregard accents, case and compatibility variation; also disregard differences between katakana and hiragana. </li>
  </ul>
  <p>If users are to have control over these equivalence classes, here is an example of how the sample syntax could be modified to account for this. The syntax for switching the strength or type of matching varies widely. Note that these tags switch behavior on and off in the middle of a regular 
  expression; they do not match a character.</p>
  <table class="syntax">
    <tr>
      <td width="100%">
      <pre>ITEM := \v{PRIMARY}   // match primary only
ITEM := \v{SECONDARY} // match primary and secondary only
ITEM := \v{TERTIARY}  // match primary, secondary, and tertiary
ITEM := \v{EXACT}     // match all levels, normal state</pre>
      </td>
    </tr>
  </table>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><span class="regex">[\v{SECONDARY}a-m]</span></td>
      <td>Match a-m, plus case variants A-M, plus compatibility variants</td>
    </tr>
  </table>
  <p>Basic information for these equivalence classes can be derived from the data tables referenced by <a href="../tr10/index.html">UTS #10: Unicode Collation Algorithm</a> [<a href="tr18-12.html#Collation">Collation</a>].</p>
  <h3><a name="Tailored_Ranges">3.5 Tailored Ranges</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.5</td>
      <td class="rule_head">Tailored Ranges</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for ranges based on a locale&#39;s collation order.</i></td>
    </tr>
  </table>
  <p>Tailored character ranges will include tailored grapheme clusters, as discussed above. This broadens the set of grapheme clusters — in traditional Spanish, for example, <span class="regex">[b-d]</span> would match against &quot;<span class="regex">c</span>&quot; and against &quot;<span class="regex">ch</span>&quot;. 
  That is because in that collation, &quot;<span class="regex">ch</span>&quot; sorts as a single letter between &quot;<span class="regex">c</span>&quot; and &quot;<span class="regex">d</span>&quot;.</p>
  <blockquote>
    <p><b>Note: </b>This is another reason why a property for all characters <span class="regex">\p{Any}</span> is needed—it is possible for a locale&#39;s collation to not have <span class="regex">[\u0000-\U0010FFFF]</span> encompass all characters.</p>
  </blockquote>
  <p>Tailored ranges can be quite difficult to implement properly, and can have very unexpected results in practice. For example, languages may also vary whether they consider lowercase below uppercase or the reverse. This can have some surprising results: <span class="regex">[a-Z]</span> may not 
  match anything if <i>Z &lt; a</i> in that locale. Thus implementers should be cautious about implementing this feature.</p>
  <h3>3.6 <a name="Context_Matching">Context Matching</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.6</td>
      <td class="rule_head">Context Matching</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for a restrictive match against input text, allowing for context before and after the match.</i></td>
    </tr>
  </table>
  <p>For parallel, filtered transformations, such as those involved in script transliteration, it is important to restrict the matching of a regular expression to a substring of a given string, and yet allow for context before and after the affected area. Here is a sample API that implements such 
  functionality, where m is an extension of a Regex <a href="http://java.sun.com/j2se/1.4.1/docs/api/java/util/regex/Matcher.html">Matcher</a>.</p>
  <pre>  if (m.matches(text, contextStart, targetStart, targetLimit, contextLimit)) {
    int end = p.getMatchEnd();
  }</pre>
  <p>The range of characters between <span class="regex">contextStart</span> and <span class="regex">targetStart</span> define a <i>precontext</i>; the characters between <span class="regex">targetStart</span> and <span class="regex">targetLimit</span> define a <i>target</i>, and the offsets between
  <span class="regex">targetLimit</span> and <span class="regex">contextLimit</span> define a <i>postcontext</i>. Thus <span class="regex">contextStart</span> ≤ <span class="regex">targetStart</span> ≤ <span class="regex">targetLimit</span> ≤ <span class="regex">contextLimit</span>. The meaning of 
  this function is that:</p>
  <ul>
    <li>a match is attempted beginning at <span class="regex">targetStart</span>.</li>
    <li>the match will only succeed with an endpoint at or less than <span class="regex">targetLimit</span>.</li>
    <li>any zero-width look-arounds (look-aheads or look-behinds) can match characters inside or outside of the target, but cannot match characters outside of the context.</li>
  </ul>
  <p><i>Examples:</i></p>
  <p>In these examples, the text in the pre- and postcontext is italicized and the target is underlined. In the output column, the text in <b>bold<font color="#00FF00"> </font></b>is the matched portion. The pattern syntax &quot;(←x)&quot; means a backwards match for <i>x</i> (without moving the cursor) This 
  would be <span class="regex">(?&lt;=x)</span> in Perl. The pattern &quot;(→x)&quot; means a forwards match for <i>x</i> (without moving the cursor). This would be <span class="regex">(?=x)</span> in Perl.</p>
  <div align="center">
    <center>
    <table border="1" cellspacing="0" cellpadding="4">
      <tr>
        <th width="30%" align="center">Pattern</th>
        <th width="10%" align="center">Input</th>
        <th width="10%" align="center">Output</th>
        <th align="center">Comment</th>
      </tr>
      <tr>
        <td align="center">/(←a) (bc)* (→d)/</td>
        <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
        <td align="center">1<i>a</i><u><b>bcbc</b></u><i>d</i>2</td>
        <td align="center">matching with context</td>
      </tr>
      <tr>
        <td align="center">/(←a) (bc)* (→bcd)/</td>
        <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
        <td align="center">1<i>a</i><u><b>bc</b>bc</u><i>d</i>2</td>
        <td align="center">stops early, because otherwise &#39;d&#39; would not match.</td>
      </tr>
      <tr>
        <td align="center">/(bc)*d/</td>
        <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
        <td align="center"><i>no match</i></td>
        <td align="center">&#39;d&#39; ca not be matched in the target, only in the postcontext</td>
      </tr>
      <tr>
        <td align="center">/(←a) (bc)* (→d)/</td>
        <td align="center">1a<u>bcbc</u><i>d</i>2</td>
        <td align="center"><i>no match</i></td>
        <td align="center">&#39;a&#39; ca not be matched, because it is before the precontext (which is zero-length, in this case)</td>
      </tr>
    </table>
    </center>
  </div>
  <p>While it would be possible to simulate this API call with other regular expression calls, it would require subdividing the string and making multiple regular expression engine calls, significantly affecting performance.</p>
  <p>There should also be pattern syntax for matches (like ^ and $) for the <span class="regex">contextStart</span> and <span class="regex">contextLimit</span> positions.</p>
  <blockquote>
    <p>Internally, this can be implemented by modifying the regular expression engine so that all matches are limited to characters between <span class="regex">contextStart</span> and <span class="regex">contextLimit</span>, and so that all matches that are not zero-width look-arounds are limited to 
    the characters between <span class="regex">targetStart</span> and <span class="regex">targetLimit</span>.</p>
  </blockquote>
  <h3>3.7 <a name="Partial_Matches">Incremental Matches</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.7</td>
      <td class="rule_head">Incremental Matches</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for incremental matching.</i></td>
    </tr>
  </table>
  <p>For buffered matching, one needs to be able to return whether there is a partial match; that is, whether there <i>would be</i> a match if additional characters were added after the <span class="regex">targetLimit</span>. This can be done with a separate method having an enumerated return value:
  <i>match</i>, <i>no_match</i>, or <i>partial_match</i>.</p>
  <pre>  if (m.incrementalmatches(text, cs, ts, tl, cl) == Matcher.MATCH) {
    ...
  }</pre>
  <p>Thus performing an incremental match of <span class="regex">/bcbce(→d)/</span> against &quot;1a<u>bcbc</u><i>d</i>2&quot; would return a <i>partial_match</i> because the addition of an <i>e</i> to the end of the target would allow it to match. Note that <span class="regex">/(bc)*(→d)/</span> would <i>
  also</i> return a partial match, because if <i>bc</i> were added at the end of the target, it would match.</p>
  <p>Here is the above table, when an incremental match method is called:</p>
  <table border="1" cellspacing="0" cellpadding="4">
    <tr>
      <th width="30%" align="center">Pattern</th>
      <th width="10%" align="center">Input</th>
      <th width="10%" align="center">Output</th>
      <th align="center">Comment</th>
    </tr>
    <tr>
      <td align="center">/(←a) (bc)* (→d)/</td>
      <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
      <td align="center"><i>partial match</i></td>
      <td align="center">&#39;bc&#39; could be inserted.</td>
    </tr>
    <tr>
      <td align="center">/(←a) (bc)* (→bcd)/</td>
      <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
      <td align="center"><i>partial match</i></td>
      <td align="center">&#39;bc&#39; could be inserted.</td>
    </tr>
    <tr>
      <td align="center">/(bc)*d/</td>
      <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
      <td align="center"><i>partial match</i></td>
      <td align="center">&#39;d&#39; could be inserted.</td>
    </tr>
    <tr>
      <td align="center">/(←a) (bc)* (→d)/</td>
      <td align="center">1a<u>bcbc</u><i>d</i>2</td>
      <td align="center"><i>no match</i></td>
      <td align="center">as with the matches function; the backwards search for &#39;a&#39; fails.</td>
    </tr>
  </table>
  <p>The typical usage of incremental matching is to make a series of incremental match calls, marching through a buffer with each successful match. At the end, if there is a partial match, one loads another buffer (or waits for other input). When the process terminates (no more buffers or input are 
  available), then a regular match call is made.</p>
  <p>Internally, incremental matching can be implemented in the regular expression engine by detecting whether the matching process ever fails when the current position is at or after <span class="regex">targetLimit</span>, and setting a flag if so. If the overall match fails, and this flag is set, 
  then the return value is set to <i>partial_match</i>. Otherwise, either <i>match</i> or <i>no_match</i> is returned, as appropriate.</p>
  <p>The return value <i>partial_match</i> indicates that there was a partial match: if further characters were added there could be a match to the resulting string. It may be useful to divide this return value into two, instead:</p>
  <ul>
    <li><i>extendable_match</i>: in addition to there being a partial match, there was also a match somewhere in the string. For example, when matching /(ab)*/ against &quot;aba&quot;, there is a match, <i>and</i> if other characters were added (&quot;a&quot;, &quot;aba&quot;,...) there could also be another match.</li>
    <li><i>only_partial_match</i>: there was no other match in the string. For example, when matching /abcd/ against &quot;abc&quot;, there is only a partial match; there would be no match unless additional characters were added.</li>
  </ul>
  <h3>3.8 <a name="Unicode_Set_Sharing">Unicode Set Sharing</a></h3>
  <p>For script transliteration and similar applications, there may be a hundreds of regular expressions, sharing a number of Unicode sets in common. These Unicode sets, such as <span class="regex">[\p{Alphabetic} -<span class="changedspan">-</span> \p{Latin}]</span>, could take a fair amount of 
  memory, because they would typically be expanded into an internal memory representation that allows for fast lookup. If these sets are separately stored, this means an excessive memory burden.</p>
  <p>To reduce the storage requirements, an API may allow regular expressions to share storage of these and other constructs, by having a &#39;pool&#39; of data associated with a set of compiled regular expressions.</p>
  <pre>rules.registerSet(&quot;$lglow&quot;, &quot;[\p{lowercase}&amp;<span class="changedspan">&amp;</span>[\p{latin}\p{greek}]] &quot;);
rules.registerSet(&quot;$mark&quot;, &quot;[\p{Mark}]&quot;);
...
rules.add(&quot;θ&quot;, &quot;th&quot;);
rules.add(&quot;Θ(→$mark*$lglow)&quot;, &quot;Th&quot;);
rules.add(&quot;Θ&quot;, &quot;TH&quot;);
...
rules.add(&quot;φ&quot;, &quot;th&quot;);
rules.add(&quot;Ψ(→$mark*$lglow)&quot;, &quot;Ps&quot;);
rules.add(&quot;Ψ&quot;, &quot;PS&quot;);
...</pre>
  <h3>3.9 <a name="Possible_Match_Sets">Possible Match Sets</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.9</td>
      <td class="rule_head">Possible Match Sets</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for the generation of possible match sets from any regular expression pattern.</i></td>
    </tr>
  </table>
  <p>There are a number of circumstances where additional functions on regular expression patterns can be useful for performance or analysis of those patterns. These are functions that return information about the sets of characters that a regular expression can match.</p>
  <p>When applying a list of regular expressions (with replacements) against a given piece of text, one can do that either serially or in parallel. With a serial application, each regular expression is applied the text, repeatedly from start to end. With parallel application, each position in the 
  text is checked against the entire list, with the first match winning. After the replacement, the next position in the text is checked, and so on.</p>
  <p>For such a parallel process to be efficient, one needs to be able to winnow out the regular expressions that simply could not match text starting with a given code point. For that, it is very useful to have a function on a regular expression pattern that returns a set of all the code points 
  that the pattern would partially or fully match.</p>
  <pre>   myFirstMatchingSet = pattern.getFirstMatchSet(Regex.POSSIBLE_FIRST_CODEPOINT);</pre>
  <p>For example, the pattern <span class="regex">/[[\u0000-\u00FF] &amp;<span class="changedspan">&amp;</span> [:Latin:]] * [0-9]/</span> would return the set {0..9, A..Z, a..z}. Logically, this is the set of all code points that would be at least partial matches (if considered in isolation).</p>
  <blockquote>
    <p><b>Note: </b>An additional useful function would be one that returned the set of all code points that could be matched at any point. Thus a code point outside of this set cannot be in any part of a matching range.</p>
  </blockquote>
  <p>The second useful case is the set of all code points that could be matched in any particular group, that is, that could be set in the standard $0, $1, $2, ... variables.</p>
  <pre>   myAllMatchingSet = pattern.getAllMatchSet(Regex.POSSIBLE_IN$0);</pre>
  <p>Internally, this can be implemented by analysing the regular expression (or parts of it) recursively to determine which characters match. For example, the first match set of an alternation <i>(a | b)</i> is the union of the first match sets of the terms <i>a</i> and <i>b</i>.</p>
  <p>The set that is returned is only guaranteed to <i>include</i> all possible first characters; if an expression gets too complicated it could be a proper superset of all the possible characters.</p>
  <h3>3.10 <a name="Folded_Matching">Folded Matching</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.10</td>
      <td class="rule_head">Folded Matching</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for registration of folding functions for providing insensitive matching for linguistic features other than case.</i></td>
    </tr>
  </table>
  <p>Regular expressions typically provide for case-sensitive or case-insensitive matching. This accounts for the fact that in English and many other languages, users quite often want to disregard the differences between characters that are solely due to case. It would be quite awkward to do this 
  manually: for example, to do a caseless match against the last name in <span class="regex">/Mark\sDavis/</span>, one would have to use the pattern <span class="regex">/Mark\s<u><font color="#0000FF">[Dd][Aa][Vv][Ii][Ss]</font></u>/</span>, instead of some syntax that can indicate that the target 
  text is to be matched after folding case, such as <span class="regex">/Mark\s<font color="#0000FF"><u>\C</u></font>Davis<font color="#0000FF"><u>\E</u></font>/</span>.</p>
  <p>For many languages and writing systems, there are other differences besides case where users want to allow a loose match. Once such way to do this was discussed earlier, in the discussion of matching according to collation strength. There are others: for example, for Ethiopic one may need to 
  match characters independent of their inherent vowel, or match certain types of vowels. It is difficult to tell exactly which ways users might want to match text for different languages, so the most flexible way to provide such support is by giving a general mechanism for overriding the way that 
  regular expressions match literals.</p>
  <p>One way to do this is to use <i>folding</i> functions. These are functions that map strings to strings, and are idempotent (applying a function more than once produces the same result: <i>f(f(x)) = f(x)</i>. There are two parts to this: (a) allow folding functions to be registered, and (b) 
  extend patterns so that registered folding functions can be activated. During the span of text in which a folding function is activated, both the pattern literals and the input text will be processed according to the folding before comparing. For example:</p>
  <pre><span class="CComment">// Folds katakana and hiragana together</span>
class KanaFolder implements RegExFolder {
<span class="CComment">// from RegExFolder, must be overridden in subclasses</span>
String fold(String source) {...}

<span class="CComment">// from RegExFolder, may be overridden for efficiency</span>
RegExFolder clone(String parameter, Locale locale) {...}
  int fold(int source) {...}
  UnicodeSet fold(UnicodeSet source) {...}
}
  ...

  RegExFolder.registerFolding(&quot;k_h&quot;, new KanaFolder());

  ...

  p = Pattern.compile(&quot;(<span style="color: #0000FF">\F{k_h=argument}</span>マルク (\s)* ダ (ヸ | ビ) ス <span style="color: #0000FF">\E</span> : \s+)*&quot;);</pre>
  <p>In the above example, the Kana folding is in force until terminated with <span style="color: #0000FF">\E</span>. Within the scope of the folding, all text in the target would be folded before matching (the literal text in the pattern would also be folded). This only affects literals; regular 
  expression syntax such as &#39;(&#39; or &#39;*&#39; are unaffected.</p>
  <p>While it is sufficient to provide a folding function for strings, for efficiency one can also provide functions for folding single code points and Unicode sets (such as <span class="regex">[a-z...]</span>). For more information, see [<a href="tr18-12.html#Folding">Folding</a>].</p>
  <h3>3.11 <a name="Submatchers">Submatchers</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.11</td>
      <td class="rule_head">Submatchers</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for general registration of matching functions for providing matching for general linguistic features.</i></td>
    </tr>
  </table>
  <p>There are over 70 properties in the Unicode character database, yet there are many other sequences of characters that users may want to match, many of them specific to given languages. For example, characters that are used as vowels may vary by language. This goes beyond single-character 
  properties, because certain sequences of characters may need to be matched; such sequences may not be easy themselves to express using regular expressions. Extending the regular expression syntax to provide for registration of arbitrary properties of characters allows these requirements to be 
  handled.</p>
  <p>The following provides an example of this. The actual function is just for illustration.</p>
  <pre>class MultipleMatcher implements RegExSubmatcher {
<span class="CComment">// from RegExFolder, must be overridden in subclasses
  /**
   * Returns -1 if there is no match; otherwise returns the endpoint;
   * an offset indicating how far the match got.
   * The endpoint is always between targetStart and targetLimit, inclusive.
   * Note that there may be zero-width matches.
   */</span>
int match(String text, int contextStart, int targetStart, int targetLimit, int contextLimit) {
<span class="CComment">// code for matching numbers according to numeric value.</span>
}

<span class="CComment">// from RegExFolder, may be overridden for efficiency
  /**
   * The parameter is a number. The match will match any numeric value that is a multiple.
   * Example: for &quot;2.3&quot;, it will match &quot;0002.3000&quot;, &quot;4.6&quot;, &quot;11.5&quot;, and any non-Western
   * script variants, like Indic numbers.
   */</span>
RegExSubmatcher clone(String parameter, Locale locale) {...}
}
  ...

  RegExSubmatcher.registerMatcher(&quot;multiple&quot;, new MultipleMatcher());

  ...

  p = Pattern.compile(&quot;xxx<span style="color: #0000FF">\M{multiple=2.3}</span>xxx&quot;);</pre>
  <p>In this example, the match function can be written to parse numbers according to the conventions of different locales, based on OS functions available for such parsing. If there are mechanisms for setting a locale for a portion of a regular expression, then that locale would be used; otherwise 
  the default locale would be used.</p>
  <blockquote>
    <p align="left"><b>Note:</b> It might be advantageous to make the Submatcher API identical to the Matcher API; that is, only have one base class &quot;Matcher&quot;, and have user extensions derive from the base class. The base class itself can allow for nested matchers.</p>
  </blockquote>
  <hr>
  <h2><a name="Character_Blocks">Annex A. Character Blocks</a></h2>
  <p>The Block property from the Unicode Character Database can be a useful property for quickly describing a set of Unicode characters. It assigns a name to segments of the Unicode codepoint space; for example, <span class="regex">[\u0370-\u03FF]</span> is the Greek block.</p>
  <p>However, block names need to be used with discretion; they are very easy to misuse because they only supply a very coarse view of the Unicode character allocation. For example:</p>
  <ul>
    <li><b>Blocks are not at all exclusive.</b> There are many mathematical operators that are not in the Mathematical Operators block; there are many currency symbols not in Currency Symbols, and so on.</li>
    <li><b>Blocks may include characters not assigned in the current version of Unicode. </b>This can be both an advantage and disadvantage. Like the General Property, this allows an implementation to handle characters correctly that are not defined at the time the implementation is released. 
    However, it also means that depending on the current properties of assigned characters in a block may fail. For example, all characters in a block may currently be letters, but this may not be true in the future.</li>
    <li><b>Writing systems may use characters from multiple blocks: </b>English uses characters from Basic Latin and General Punctuation, Syriac uses characters from both the Syriac and Arabic blocks, various languages use Cyrillic plus a few letters from Latin, and so on.</li>
    <li><b>Characters from a single writing system may be split across multiple blocks.</b> See the following table on Writing Systems versus Blocks. Moreover, presentation forms for a number of different scripts may be collected in blocks like Alphabetic Presentation Forms or Halfwidth and 
    Fullwidth Forms.</li>
  </ul>
  <p>The following table illustrates the mismatch between writing systems and blocks. These are only examples; this table is not a complete analysis. It also does not include common punctuation used with all of these writing systems.</p>
  <table>
    <caption>Writing Systems versus Blocks</caption>
    <tr>
      <th align="left">Writing Systems</th>
      <th align="left">Blocks</th>
    </tr>
    <tr>
      <td>Latin&nbsp; </td>
      <td>Basic Latin, Latin-1 Supplement, Latin Extended-A, Latin Extended-B, Latin Extended Additional, Diacritics</td>
    </tr>
    <tr>
      <td>Greek&nbsp; </td>
      <td>Greek, Greek Extended, Diacritics</td>
    </tr>
    <tr>
      <td>Arabic&nbsp; </td>
      <td>Arabic, Arabic Presentation Forms-A, Arabic Presentation Forms-B</td>
    </tr>
    <tr>
      <td>Korean</td>
      <td>Hangul Jamo, Hangul Compatibility Jamo, Hangul Syllables, CJK Unified Ideographs, CJK Unified Ideographs Extension A, CJK Compatibility Ideographs, CJK Compatibility Forms, Enclosed CJK Letters and Months, Small Form Variants</td>
    </tr>
    <tr>
      <td>Yi&nbsp; </td>
      <td>Yi Syllables, Yi Radicals</td>
    </tr>
    <tr>
      <td>Chinese</td>
      <td>CJK Unified Ideographs, CJK Unified Ideographs Extension A, CJK Compatibility Ideographs, CJK Compatibility Forms, Enclosed CJK Letters and Months, Small Form Variants, Bopomofo, Bopomofo Extended</td>
    </tr>
  </table>
  <p>For the above reasons, Script values are generally preferred to Block values. Even there, they should be used in accordance with the guidelines in <a href="../tr24/index.html">UTR #24: Script Names</a> [<a href="tr18-12.html#ScriptDoc">ScriptDoc</a>].</p>
  <h2><a name="Sample_Collation_Character_Code">Annex B: Sample Collation Character Code</a></h2>
  <p>The following provides sample code for doing Level 3 collation character detection. This code is meant to be illustrative, and has not been optimized. Although written in Java, it could be easily expressed in any programming language that allows access to the Unicode Collation Algorithm 
  mappings.</p>
  <pre><span style="color: #0000FF">/**
 * Return the end of a collation character.
 * @param s         the source string
 * @param start     the position in the string to search
 *                  forward from
 * @param collator  the collator used to produce collation elements.
 * This can either be a custom-built one, or produced from
 * the factory method Collator.getInstance(someLocale).
 * @return          the end position of the collation character
 */</span>

static int getLocaleCharacterEnd(String s,
  int start, RuleBasedCollator collator) {
    int lastPosition = start;
    CollationElementIterator it 
      = collator.getCollationElementIterator(
          s.substring(start, s.length()));
    it.next(); <span style="color: #0000FF">// discard first collation element</span>
int primary;
        
<span style="color: #0000FF">// accumulate characters until we get to a non-zero primary</span>
        
do {
        lastPosition = it.getOffset();
        int ce = it.next();
        if (ce == CollationElementIterator.NULLORDER) break;
        primary = CollationElementIterator.primaryOrder(ce);
    } while (primary == 0);
    return lastPosition;
}</pre>
  <h2>Annex C: <a name="Compatibility_Properties">Compatibility Properties</a></h2>
  <p>The following are recommended assignments for compatibility property names, for use in Regular Expressions.<span> There are two alternatives: the Standard Recommendation and the POSIX Compatible versions. </span>Applications should use the former wherever possible. The latter is modified to 
  meet the formal requirements of [POSIX], and also to maintain (as much as possible) compatibility with the POSIX usage in practice. That involves some compromises, because POSIX does not have as fine-grained a set of character properties as in the Unicode Standard, and also has some additional 
  constraints. So, for example, POSIX does not allow more than 20 characters to be categorized as digits, whereas there are many more than 20 digit characters in Unicode.</p>
  <table border="1" cellspacing="0" cellpadding="2">
    <tr>
      <th class="heading">Property</th>
      <th class="heading"><span>Standard Recommendation</span></th>
      <th class="heading"><span>POSIX Compatible</span></th>
      <th class="heading">Comments</th>
    </tr>
    <tr>
      <td><b><a name="alpha">alpha</a></b></td>
      <td class="recommended"><span class="regex">\p{Alphabetic}</span></td>
      <td class="recommended"><span class="regex">\p{Alphabetic}</span></td>
      <td>Alphabetic includes more than gc = Letter. Note that marks (Me, Mn, Mc) are required for words of many languages. While they could be applied to non-alphabetics, their principal use is on alphabetics. See <a href="http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt">
      DerivedCoreProperties</a> [<a href="tr18-12.html#UCD">UCD</a>] for Alphabetic, also <a href="http://www.unicode.org/Public/UNIDATA/extracted/DerivedGeneralCategory.txt">DerivedGeneralCategory</a> [<a href="tr18-12.html#UCD">UCD</a>].<p>Alphabetic should <i>not</i> be used as an approximation for word boundaries: see
      <a href="tr18-12.html#word">word</a> below.</td>
    </tr>
    <tr>
      <td><b><a name="lower">lower</a></b></td>
      <td class="recommended"><span class="regex">\p{Lowercase}</span></td>
      <td class="recommended"><span class="regex">\p{Lowercase}</span></td>
      <td>Lowercase includes more than gc = Lowercase_Letter (Ll). See <a href="http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt">DerivedCoreProperties</a> [<a href="tr18-12.html#UCD">UCD</a>]. </td>
    </tr>
    <tr>
      <td><b><a name="upper">upper</a></b></td>
      <td class="recommended"><span class="regex">\p{Uppercase}</span></td>
      <td class="recommended"><span class="regex">\p{Uppercase}</span></td>
      <td>Uppercase includes more than gc = Uppercase_Letter (Lu).</td>
    </tr>
    <tr>
      <td><b><a name="punct">punct</a></b></td>
      <td class="recommended"><span class="regex">\p{gc=Punctuation}</span></td>
      <td class="recommended"><span class="regex"><span>\p{gc=Punctuation}<br>
      \p{gc=Symbol}<br>
      </span>--<span> \p{alpha}</span></span></td>
      <td>POSIX adds symbols. Not recommended generally, due to the confusion of having <i>punct</i> include non-punctuation marks.</td>
    </tr>
    <tr>
      <td><b><a name="digit">digit</a><br>
      (\d)</b></td>
      <td class="recommended"><span class="regex">\p{gc=Decimal_Number}</span></td>
      <td class="recommended"><span class="regex"><span>[0..9]</span></span></td>
      <td>Non-decimal numbers (like Roman numerals) are normally excluded. In U4.0+, the recommended column is the same as gc = Decimal_Number (Nd). See <a href="http://www.unicode.org/Public/UNIDATA/extracted/DerivedNumericType.txt">DerivedNumericType</a> [<a href="tr18-12.html#UCD">UCD</a>].</td>
    </tr>
    <tr>
      <td><b><a name="xdigit">xdigit</a></b><br>
      </td>
      <td class="recommended"><span class="regex">\p{gc=Decimal_Number}<br>
      <span>\p{Hex_Digit}</span></span></td>
      <td class="recommended"><span class="regex"><span>[0-9 A-F a-f]</span></span></td>
      <td>Hex_Digit contains 0-9 A-F, fullwidth and halfwidth, upper and lowercase.</td>
    </tr>
    <tr>
      <td><b><a name="alnum">alnum</a></b></td>
      <td class="recommended"><span class="regex">\p{alpha}<br>
      \p{digit}</span></td>
      <td class="recommended"><span class="regex">\p{alpha}<br>
      \p{digit}</span></td>
      <td>Simple combination of other properties</td>
    </tr>
    <tr>
      <td><b><a name="space">space<br>
      </a>\s</b></td>
      <td class="recommended"><span class="regex">\p{Whitespace}</span></td>
      <td class="recommended"><span class="regex">\p{Whitespace}</span></td>
      <td>See <a href="http://www.unicode.org/Public/UNIDATA/PropList.txt">PropList</a> [<a href="tr18-12.html#UCD">UCD</a>] for the definition of Whitespace.</td>
    </tr>
    <tr>
      <td><b><a name="blank">blank</a></b></td>
      <td class="recommended"><span class="regex">\p{Whitespace} --<br>
      [\N{LF} \N{VT} \N{FF} \N{CR} \N{NEL} \p{gc=Line_Separator} \p{gc=Paragraph_Separator}]</span></td>
      <td class="recommended"><span class="regex">\p{Whitespace} --<br>
      [\N{LF} \N{VT} \N{FF} \N{CR} \N{NEL} \p{gc=Line_Separator} \p{gc=Paragraph_Separator}]</span></td>
      <td>&quot;horizontal&quot; whitespace.</td>
    </tr>
    <tr>
      <td><b><a name="cntrl">cntrl</a></b></td>
      <td class="recommended"><span class="regex">\p{gc=Control}</span></td>
      <td class="recommended"><span class="regex">\p{gc=Control}</span></td>
      <td>The characters in <span class="regex">\p{gc=Format}</span> share some, but not all aspects of control characters. Many format characters are required in the representation of plain text.</td>
    </tr>
    <tr>
      <td><b><a name="graph">graph</a></b></td>
      <td class="recommended"><span class="regex">[^<br>
      \p{space}<br>
      \p{gc=Control}<br>
      \p{gc=Surrogate}<br>
      \p{gc=Unassigned}]</span></td>
      <td class="recommended"><span class="regex">[^<br>
      \p{space}<br>
      \p{gc=Control}<br>
      \p{gc=Surrogate}<br>
      \p{gc=Unassigned}]</span></td>
      <td><i>Warning: </i>the set to the left is defined by <i>excluding </i>space, controls, and so on with ^.
      <p><span class="removedspan">Perl 5.8.0 is similar except that it excludes: Z, Cc, Cf, Cs, Cn. The intent is for Perl 5.8.1 to align with the specification here.</span></td>
    </tr>
    <tr>
      <td><b>print</b></td>
      <td class="recommended"><span class="regex">\p{graph}<br>
      <span>\p{blank}<br>
      </span>--<span> \p{cntrl}</span></span></td>
      <td class="recommended"><span class="regex">\p{graph}<br>
      <span>\p{blank}<br>
      </span>--<span> \p{cntrl}</span></span></td>
      <td>Includes graph and space-like characters.</td>
    </tr>
    <tr>
      <td><b><a name="word">word</a><br>
      (\w)</b></td>
      <td class="recommended"><span class="regex">\p{alpha}<br>
      \p{gc=Mark}<br>
      \p{digit}<br>
      \p{gc=Connector_Punctuation}</span></td>
      <td class="recommended"><span>n/a</span></td>
      <td>This is only an approximation to Word Boundaries (see <a href="tr18-12.html#b">b</a> below). The Connector Punctuation is added in for programming language identifiers, thus adding &quot;_&quot; and similar characters.</td>
    </tr>
    <tr>
      <td><b>\<a name="X">X</a></b></td>
      <td class="recommended">Extended Grapheme Clusters</td>
      <td class="recommended"><span>n/a</span></td>
      <td>See [<a href="tr18-12.html#Boundaries">Boundaries</a>], also <a href="../tr29/GraphemeClusterBreakTest.html">GraphemeClusterBreakTest</a>. Other functions are used for programming language identifier boundaries.</td>
    </tr>
    <tr>
      <td><b>\<a name="b">b</a></b></td>
      <td class="recommended">Default Word Boundaries</td>
      <td class="recommended"><span>n/a</span></td>
      <td>If there is a requirement that \b align with \w, then it would use the approximation above instead. See [<a href="tr18-12.html#Boundaries">Boundaries</a>], also <a href="../tr29/WordBreakTest.html">WordBreakTest</a>.<p>Note that different functions are used for programming 
      language identifier boundaries. See also [<a href="tr18-12.html#Syntax">Syntax</a>].</td>
    </tr>
  </table>
  <h2><a name="References">References</a></h2>
  <table class="noborder" cellpadding="4">
    <tr>
      <td width="1" class="noborder">[<a name="Boundaries">Boundaries</a>]</td>
      <td class="noborder">Unicode Standard Annex #29: Text Boundaries<br>
      <a href="../tr29.1">http://www.unicode.org/reports/tr29/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Case">Case</a>]</td>
      <td class="noborder">Section 3.13 [<a href="tr18-12.html#Unicode">Unicode</a>]<br>
      <a href="http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992">http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="CaseData">CaseData</a>]</td>
      <td class="noborder"><a href="http://www.unicode.org/Public/UNIDATA/CaseFolding.txt">http://www.unicode.org/Public/UNIDATA/CaseFolding.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Collation">Collation</a>]</td>
      <td class="noborder">Unicode Technical Standard #10: Unicode Collation Algorithm<br>
      <a href="../tr10/index.html">http://www.unicode.org/reports/tr10/</a> </td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="FAQ">FAQ</a>]</td>
      <td class="noborder">Unicode Frequently Asked Questions<br>
      <a href="http://www.unicode.org/faq/">http://www.unicode.org/faq/<br>
      </a><i>For answers to common questions on technical issues.</i></td>
    </tr>
    <tr>
      <td valign="top" width="1" class="noborder">[<a name="Feedback">Feedback</a>]</td>
      <td valign="top" class="noborder">Reporting Errors and Requesting Information Online<i><br>
      </i><a href="http://www.unicode.org/reporting.html">http://www.unicode.org/reporting.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Folding">Folding</a>]</td>
      <td class="noborder"><a href="../tr30/index.html">UTR #30 Character Foldings</a> <i>(Current Status: Draft)<br>
      <a href="../tr30/index.html">http://www.unicode.org/reports/tr30/</a></i></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Friedl">Friedl</a>]</td>
      <td class="noborder">Jeffrey Friedl, &quot;Mastering Regular Expressions&quot;, 2nd Edition 2002, O&#39;Reilly and Associates, ISBN 0-596-00289-0</td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Glossary">Glossary</a>]</td>
      <td class="noborder">Unicode Glossary<a href="http://www.unicode.org/glossary/"><br>
      http://www.unicode.org/glossary/<br>
      </a><i>For explanations of terminology used in this and other documents.</i></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="LineBreak">LineBreak</a>]</td>
      <td class="noborder">Unicode Standard Annex #14: Line Breaking Properties<br>
      <a href="../tr14/index.html">http://www.unicode.org/reports/tr14/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Norm">Norm</a>]</td>
      <td class="noborder">Unicode Standard Annex #15: Unicode Normalization<br>
      <a href="../tr15.1">&nbsp;http://www.unicode.org/reports/tr15/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[Online]</td>
      <td class="noborder"><a href="http://www.unicode.org/onlinedat/online.html">http://www.unicode.org/onlinedat/online.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Perl">Perl</a>]</td>
      <td class="noborder"><a href="http://www.perl.com/pub/q/documentation">http://www.perl.com/pub/q/documentation<br>
      </a>See especially:<br>
      <a href="http://www.perldoc.com/perl5.8.0/lib/charnames.html">http://www.perldoc.com/perl5.8.0/lib/charnames.html</a><br>
      <a href="http://www.perldoc.com/perl5.8.0/pod/perlre.html">http://www.perldoc.com/perl5.8.0/pod/perlre.html</a><br>
      <a href="http://www.perldoc.com/perl5.8.0/pod/perluniintro.html">http://www.perldoc.com/perl5.8.0/pod/perluniintro.html</a><br>
      <a href="http://www.perldoc.com/perl5.8.0/pod/perlunicode.html">http://www.perldoc.com/perl5.8.0/pod/perlunicode.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="POSIX">POSIX</a>]</td>
      <td class="noborder">The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2003 Edition, &quot;Locale&quot; chapter<br>
      <a href="http://www.opengroup.org/onlinepubs/007904975/basedefs/xbd_chap07.html">http://www.opengroup.org/onlinepubs/007904975/basedefs/xbd_chap07.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Prop">Prop</a>]</td>
      <td class="noborder"><a href="http://www.unicode.org/Public/UNIDATA/PropertyAliases.txt">http://www.unicode.org/Public/UNIDATA/PropertyAliases.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="PropValue">PropValue</a>]</td>
      <td class="noborder"><a href="http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt">http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Reports">Reports</a>]</td>
      <td class="noborder">Unicode Technical Reports<br>
      <a href="../index.html">http://www.unicode.org/reports/<br>
      </a><i>For information on the status and development process for technical reports, and for a list of technical reports.</i></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="ScriptData">ScriptData</a>]</td>
      <td class="noborder"><a href="http://www.unicode.org/Public/UNIDATA/Scripts.txt">http://www.unicode.org/Public/UNIDATA/Scripts.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="ScriptDoc">ScriptDoc</a>]</td>
      <td class="noborder">Unicode Technical Report #24: Script Names<br>
      <a href="../tr24/index.html">http://www.unicode.org/reports/tr24/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="SpecialCasing">SpecialCasing</a>]</td>
      <td class="noborder"><a href="http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt">http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Syntax">Syntax</a>]</td>
      <td class="noborder">Unicode Standard Annex #31: Identifier and Pattern Syntax<i><br>
      <a href="../tr31/index.html">http://www.unicode.org/reports/tr31/</a></i></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="UCD">UCD</a>]</td>
      <td class="noborder">Unicode Character Database <a href="http://www.unicode.org/ucd/">http://www.unicode.org/ucd/</a><br>
      <i>For an overview of the Unicode Character Database and a list of its associated files see </i><a href="http://www.unicode.org/Public/UNIDATA/UCD.html">http://www.unicode.org/Public/UNIDATA/UCD.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="UData">UData</a>]</td>
      <td class="noborder"><a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">http://www.unicode.org/Public/UNIDATA/UnicodeData.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="UDataDoc">UDataDoc</a>]</td>
      <td class="noborder"><a href="http://www.unicode.org/Public/UNIDATA/UCD.html">http://www.unicode.org/Public/UNIDATA/UCD.html</a></td>
    </tr>
    <tr>
      <td valign="top" width="1" class="noborder">[<a name="Unicode">Unicode</a>]</td>
      <td valign="top" class="noborder">The Unicode Consortium. <a href="http://www.unicode.org/versions/Unicode4.0.0/">The Unicode Standard, Version 4.0</a>. Reading, MA, Addison-Wesley, 2003. 0-321-18578-1.</td>
    </tr>
    <tr>
      <td width="1" class="noborder">[<a name="Versions">Versions</a>]</td>
      <td class="noborder">Versions of the Unicode Standard<br>
      <a href="http://www.unicode.org/versions/">http://www.unicode.org/versions/<br>
      </a><i>For details on the precise contents of each version of the Unicode Standard, and how to cite them.</i></td>
    </tr>
  </table>
  <p>&nbsp; </p>
  <h2><a name="Acknowledgments">Acknowledgments</a></h2>
  <p>Thanks to Jeffrey Friedl, Andy Heninger, Peter Linsley, Alan Liu, Kent Karlsson, Jarkko Hietaniemi, Gurusamy Sarathy, Henry Spencer, Tom Watson, and Kento Tamura for their feedback on the document.</p>
  <h2><a name="Modifications">Modifications</a></h2>
  <p>The following summarizes modifications from the previous revision of this document.</p>
  <table class="noborder">
    <tr>
      <td width="1" class="noborder"><span class="changedspan"><a name="TrackingNumber12">12</a></span></td>
      <td class="noborder"><span class="changedspan">Draft 3</span><ul>
        <li><span class="changedspan">Clearer discussion of the importance of levels, and features within level 2.</span></li>
        <li><span class="changedspan">Updated syntax</span></li>
        <li><span class="changedspan">Fixed precedence to be neutral, just noting the two main alternatives.</span></li>
        <li><span class="changedspan">Discussion of the use of hex notation to prevent unwanted normalization in literals</span></li>
        <li><span class="changedspan">Examples of normalization and casing properties</span></li>
        <li><span class="changedspan">Improved end-of-line treatment</span></li>
        <li><span class="changedspan">Revised treatment of (extended) grapheme clusters (U5.1), and the connection to normalization support. (Instances of changes from "default" to "extended" are not flagged.)</span></li>
        <li><span class="changedspan">Clearer description of the use of wildcards in property values</span></li>
      </ul>
      <p><span class="changedspan">Draft 2</span></p>
      <ul>
        <li><span class="changedspan">Clarified conformance requirements for &quot;.&quot; and CRLF.</span></li>
        <li><span class="changedspan">Pointed to LDML for the locale ID syntax</span></li>
        <li><span class="changedspan">Made the importance of the levels (and sublevels) clearer.</span></li>
        <li><span class="changedspan">Added ≠ in property expressions, ~~ for symmetric difference</span></li>
        <li><span class="changedspan">Changed operators to use doubled characters: --, &amp;&amp;, ||, ~~</span></li>
        <li><span class="changedspan">Added multiple property values. \p{gc=L|M|Nd} is equivalent to [\p{gc=L}\p{gc=M}\p{gc=Nd}]</span></li>
        <li><span class="changedspan">Fixed case where &#39;arbitrary character pattern&#39; matches a newline sequence</span></li>
        <li><span class="changedspan">Added order of priority for level 2 items</span></li>
        <li><span class="changedspan">Described implementation of canonical equivalence through extended grapheme clusters</span></li>
        <li><span class="changedspan">Moved extended grapheme clusters (2.2) to level 3.</span></li>
        <li><span class="changedspan">Added named sequences, such as \N{KHMER CONSONANT SIGN COENG KA}</span></li>
        <li><span class="changedspan">Added some example links to Unicode utilities.</span></li>
      </ul>
      </td>
    </tr>
    <tr>
      <td width="1" class="noborder"><a name="TrackingNumber11">11</a></td>
      <td class="noborder">
      <ul>
        <li>Annex C:<ul>
          <li>Clarified first paragraph and removed review notes.</li>
          <li>Changed <i>upper</i> definition in Annex C, because the UTC has changed the properties so that it will always be the case (from 4.1.0 onward) that Alphabetic ⊇ Uppercase and Alphabetic ⊇ Lowercase</li>
          <li>Added \p{gc=Format} to graph, for better compatibility with POSIX usage.</li>
        </ul>
        </li>
        <li>Added a caution about use of Tailored Ranges, and a note about the option of pre-normalization with newlines.</li>
        <li>Removed conformance clause for Unicode Set Sharing</li>
        <li>Misc Edits, including:<ul>
          <li>Added note on limit of 1-9 for \n</li>
          <li>Fixed ^.*$ to ^$</li>
          <li>Added parentheses to ([a-z ä] | (a \u0308))</li>
        </ul>
        </li>
      </ul>
      </td>
    </tr>
    <tr>
      <td width="1" class="noborder"><span><a name="TrackingNumber9">10</a></span></td>
      <td class="noborder">
      <ul>
        <li><span>R1.4, item 2 changed for ZW(N)J</span></li>
        <li><span>Added conformance clause to allow a claim of conformance to the Compatibility properties.</span></li>
        <li><span>Split the Compatibility properties into two, to allow for regular vs. strict POSIX properties.</span></li>
        <li><span>Added other notation for use here and in other Unicode Standards</span></li>
        <li><span>Added vertical tab to newline sequences. Reorganized text slightly to only list codepoints once.</span></li>
        <li><span>Minor Editing</span></li>
      </ul>
      </td>
    </tr>
    <tr>
      <td width="1" class="noborder"><a name="TrackingNumber9">9</a></td>
      <td class="noborder">
      <ul>
        <li>Split 2.5 into two sections, expanding latter.</li>
        <li>Misc. editing and clarifications.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td width="1" class="noborder"><a name="TrackingNumber8">8</a></td>
      <td class="noborder">
      <ul>
        <li>Renumbered sections to match levels</li>
        <li>Introduced &quot;RL&quot; numbering on clauses</li>
        <li>Misc. editing and clarifications.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td width="1" class="noborder"><a name="TrackingNumber7">7</a></td>
      <td class="noborder">
      <ul>
        <li>Now proposed as a UTS, adding <a href="tr18-12.html#Conformance">Conformance</a> and specific wording in each relevant section.</li>
        <li>Move hex notation for surrogates from <a href="tr18-12.html#Supplementary_Characters">1.7 Surrogates</a> into <a href="tr18-12.html#Hex_notation">1.1 Hex notation</a>.</li>
        <li>Added <a href="tr18-12.html#Context_Matching">3.6 Context Matching</a> and following.</li>
        <li>Updated to Unicode 4.0</li>
        <li>Minor editing</li>
        <li><b>Note:</b> paragraphs with major changes are highlighted in this document; less substantive wording changes may not be.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td width="1" class="noborder"><a name="TrackingNumber6">6</a></td>
      <td class="noborder">
      <ul>
        <li>Fixed 16-bit reference, moved Supplementary characters support (surrogates) to level 1. </li>
        <li>Generally changed &quot;locale-dependent&quot; to &quot;default&quot;, &quot;locale-independent&quot; to &quot;tailored&quot; and &quot;grapheme&quot; to &quot;grapheme cluster&quot;</li>
        <li>Changed syntax slightly to be more like Perl</li>
        <li>Added explicit table of General Category values</li>
        <li>Added clarifications about scripts and blocks</li>
        <li>Added descriptions of other properties, and a pointer to the default names</li>
        <li>Referred to TR 29 for grapheme cluster and word boundaries</li>
        <li>Removed old annex B (word boundary code)</li>
        <li>Removed spaces from anchors</li>
        <li>Added references, modification sections </li>
        <li>Rearranged property section</li>
        <li>Minor editing</li>
      </ul>
      </td>
    </tr>
  </table>
  <p class="copyright">Copyright © 2000-2008 Unicode, Inc. All Rights Reserved. The Unicode Consortium makes no expressed or implied warranty of any kind, and assumes no liability for errors or omissions. No liability is assumed for incidental and consequential damages in connection with or arising 
  out of the use of the information or programs contained or accompanying this technical report. The Unicode <a href="http://www.unicode.org/copyright.html">Terms of Use</a> apply.</p>
  <p class="copyright">Unicode and the Unicode logo are trademarks of Unicode, Inc., and are registered in some jurisdictions.</div>

</body>

</html>
